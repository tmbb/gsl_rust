


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Special Functions &mdash; GSL 2.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Vectors and Matrices" href="vectors.html" />
    <link rel="prev" title="Polynomials" href="poly.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GSL
          

          
          </a>

          
            
            
              <div class="version">
                2.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Using the Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="err.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Mathematical Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="poly.html">Polynomials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Special Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-gsl-sf-result-struct">The gsl_sf_result struct</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modes">Modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#airy-functions-and-derivatives">Airy Functions and Derivatives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#airy-functions">Airy Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#derivatives-of-airy-functions">Derivatives of Airy Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zeros-of-airy-functions">Zeros of Airy Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zeros-of-derivatives-of-airy-functions">Zeros of Derivatives of Airy Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bessel-functions">Bessel Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#regular-cylindrical-bessel-functions">Regular Cylindrical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irregular-cylindrical-bessel-functions">Irregular Cylindrical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-modified-cylindrical-bessel-functions">Regular Modified Cylindrical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irregular-modified-cylindrical-bessel-functions">Irregular Modified Cylindrical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-spherical-bessel-functions">Regular Spherical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irregular-spherical-bessel-functions">Irregular Spherical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-modified-spherical-bessel-functions">Regular Modified Spherical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irregular-modified-spherical-bessel-functions">Irregular Modified Spherical Bessel Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-bessel-function-fractional-order">Regular Bessel Function—Fractional Order</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irregular-bessel-functions-fractional-order">Irregular Bessel Functions—Fractional Order</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-modified-bessel-functions-fractional-order">Regular Modified Bessel Functions—Fractional Order</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irregular-modified-bessel-functions-fractional-order">Irregular Modified Bessel Functions—Fractional Order</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zeros-of-regular-bessel-functions">Zeros of Regular Bessel Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#clausen-functions">Clausen Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coulomb-functions">Coulomb Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#normalized-hydrogenic-bound-states">Normalized Hydrogenic Bound States</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coulomb-wave-functions">Coulomb Wave Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coulomb-wave-function-normalization-constant">Coulomb Wave Function Normalization Constant</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coupling-coefficients">Coupling Coefficients</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#j-symbols">3-j Symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">6-j Symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">9-j Symbols</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dawson-function">Dawson Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#debye-functions">Debye Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dilogarithm">Dilogarithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#real-argument">Real Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complex-argument">Complex Argument</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#elementary-operations">Elementary Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#elliptic-integrals">Elliptic Integrals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definition-of-legendre-forms">Definition of Legendre Forms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definition-of-carlson-forms">Definition of Carlson Forms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#legendre-form-of-complete-elliptic-integrals">Legendre Form of Complete Elliptic Integrals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#legendre-form-of-incomplete-elliptic-integrals">Legendre Form of Incomplete Elliptic Integrals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#carlson-forms">Carlson Forms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#elliptic-functions-jacobi">Elliptic Functions (Jacobi)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error-functions">Error Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#error-function">Error Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complementary-error-function">Complementary Error Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#log-complementary-error-function">Log Complementary Error Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#probability-functions">Probability functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exponential-functions">Exponential Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exponential-function">Exponential Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relative-exponential-functions">Relative Exponential Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exponentiation-with-error-estimate">Exponentiation With Error Estimate</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exponential-integrals">Exponential Integrals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exponential-integral">Exponential Integral</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ei-x">Ei(x)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hyperbolic-integrals">Hyperbolic Integrals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ei-3-x">Ei_3(x)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trigonometric-integrals">Trigonometric Integrals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arctangent-integral">Arctangent Integral</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fermi-dirac-function">Fermi-Dirac Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#complete-fermi-dirac-integrals">Complete Fermi-Dirac Integrals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#incomplete-fermi-dirac-integrals">Incomplete Fermi-Dirac Integrals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gamma-and-beta-functions">Gamma and Beta Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gamma-functions">Gamma Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#factorials">Factorials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pochhammer-symbol">Pochhammer Symbol</a></li>
<li class="toctree-l3"><a class="reference internal" href="#incomplete-gamma-functions">Incomplete Gamma Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#beta-functions">Beta Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#incomplete-beta-function">Incomplete Beta Function</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gegenbauer-functions">Gegenbauer Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hermite-polynomials-and-functions">Hermite Polynomials and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hermite-polynomials">Hermite Polynomials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#derivatives-of-hermite-polynomials">Derivatives of Hermite Polynomials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hermite-functions">Hermite Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#derivatives-of-hermite-functions">Derivatives of Hermite Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zeros-of-hermite-polynomials-and-hermite-functions">Zeros of Hermite Polynomials and Hermite Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hypergeometric-functions">Hypergeometric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#laguerre-functions">Laguerre Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lambert-w-functions">Lambert W Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#legendre-functions-and-spherical-harmonics">Legendre Functions and Spherical Harmonics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#legendre-polynomials">Legendre Polynomials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#associated-legendre-polynomials-and-spherical-harmonics">Associated Legendre Polynomials and Spherical Harmonics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conical-functions">Conical Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#radial-functions-for-hyperbolic-space">Radial Functions for Hyperbolic Space</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#logarithm-and-related-functions">Logarithm and Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mathieu-functions">Mathieu Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mathieu-function-workspace">Mathieu Function Workspace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mathieu-function-characteristic-values">Mathieu Function Characteristic Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#angular-mathieu-functions">Angular Mathieu Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#radial-mathieu-functions">Radial Mathieu Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#power-function">Power Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#psi-digamma-function">Psi (Digamma) Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#digamma-function">Digamma Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trigamma-function">Trigamma Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polygamma-function">Polygamma Function</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#synchrotron-functions">Synchrotron Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transport-functions">Transport Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trigonometric-functions">Trigonometric Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#circular-trigonometric-functions">Circular Trigonometric Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trigonometric-functions-for-complex-arguments">Trigonometric Functions for Complex Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hyperbolic-trigonometric-functions">Hyperbolic Trigonometric Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion-functions">Conversion Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restriction-functions">Restriction Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trigonometric-functions-with-error-estimates">Trigonometric Functions With Error Estimates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#zeta-functions">Zeta Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#riemann-zeta-function">Riemann Zeta Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#riemann-zeta-function-minus-one">Riemann Zeta Function Minus One</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hurwitz-zeta-function">Hurwitz Zeta Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eta-function">Eta Function</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-1-bessel-function-j-0">Example 1: Bessel function <img class="math" src="_images/math/9d3ed64c11cbeaa0f6694f61488f9b44cc3474dc.png" alt="J_0"/></a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-2-associated-legendre-functions">Example 2: Associated Legendre Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="vectors.html">Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiset.html">Multisets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="eigen.html">Eigensystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Fast Fourier Transforms (FFTs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Numerical Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="rng.html">Random Number Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="qrng.html">Quasi-Random Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="randist.html">Random Number Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="rstat.html">Running Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="movstat.html">Moving Window Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Digital Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="histogram.html">Histograms</a></li>
<li class="toctree-l1"><a class="reference internal" href="ntuple.html">N-tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="montecarlo.html">Monte Carlo Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="siman.html">Simulated Annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="ode-initval.html">Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="interp.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="diff.html">Numerical Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheb.html">Chebyshev Approximations</a></li>
<li class="toctree-l1"><a class="reference internal" href="sum.html">Series Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dwt.html">Wavelet Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dht.html">Discrete Hankel Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="roots.html">One Dimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="min.html">One Dimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiroots.html">Multidimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="multimin.html">Multidimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="lls.html">Linear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="nls.html">Nonlinear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="bspline.html">Basis Splines</a></li>
<li class="toctree-l1"><a class="reference internal" href="spmatrix.html">Sparse Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="spblas.html">Sparse BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="splinalg.html">Sparse Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="const.html">Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="ieee754.html">IEEE floating-point arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debugging Numerical Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributors to GSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoconf.html">Autoconf Macros</a></li>
<li class="toctree-l1"><a class="reference internal" href="cblas.html">GSL CBLAS Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpl.html">GNU General Public License</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdl.html">GNU Free Documentation License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GSL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Special Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/specfunc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="vectors.html" class="btn btn-neutral float-right" title="Vectors and Matrices" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="poly.html" class="btn btn-neutral float-left" title="Polynomials" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="special-functions">
<span id="index-0"></span><h1>Special Functions<a class="headerlink" href="#special-functions" title="Permalink to this heading">¶</a></h1>
<p>This chapter describes the GSL special function library.  The library
includes routines for calculating the values of Airy functions, Bessel
functions, Clausen functions, Coulomb wave functions, Coupling
coefficients, the Dawson function, Debye functions, Dilogarithms,
Elliptic integrals, Jacobi elliptic functions, Error functions,
Exponential integrals, Fermi-Dirac functions, Gamma functions,
Gegenbauer functions, Hermite polynomials and functions, Hypergeometric functions, Laguerre functions,
Legendre functions and Spherical Harmonics, the Psi (Digamma) Function,
Synchrotron functions, Transport functions, Trigonometric functions and
Zeta functions.  Each routine also computes an estimate of the numerical
error in the calculated value of the function.</p>
<p>The functions in this chapter are declared in individual header files,
such as <code class="file docutils literal notranslate"><span class="pre">gsl_sf_airy.h</span></code>, <code class="file docutils literal notranslate"><span class="pre">gsl_sf_bessel.h</span></code>, etc.  The complete
set of header files can be included using the file <code class="file docutils literal notranslate"><span class="pre">gsl_sf.h</span></code>.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this heading">¶</a></h2>
<p>The special functions are available in two calling conventions, a
<em>natural form</em> which returns the numerical value of the function and
an <em>error-handling form</em> which returns an error code.  The two types
of function provide alternative ways of accessing the same underlying
code.</p>
<p>The <em>natural form</em> returns only the value of the function and can be
used directly in mathematical expressions.  For example, the following
function call will compute the value of the Bessel function
<img class="math" src="_images/math/596c757495a55561b57f4fb478ab0041f951a151.png" alt="J_0(x)"/>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gsl_sf_bessel_J0</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>There is no way to access an error code or to estimate the error using
this method.  To allow access to this information the alternative
error-handling form stores the value and error in a modifiable argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gsl_sf_result</span> <span class="n">result</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">gsl_sf_bessel_J0_e</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>The error-handling functions have the suffix <code class="code docutils literal notranslate"><span class="pre">_e</span></code>. The returned
status value indicates error conditions such as overflow, underflow or
loss of precision.  If there are no errors the error-handling functions
return <code class="code docutils literal notranslate"><span class="pre">GSL_SUCCESS</span></code>.</p>
</div>
<div class="section" id="the-gsl-sf-result-struct">
<h2>The gsl_sf_result struct<a class="headerlink" href="#the-gsl-sf-result-struct" title="Permalink to this heading">¶</a></h2>
<p>The error handling form of the special functions always calculate an
error estimate along with the value of the result.  Therefore,
structures are provided for amalgamating a value and error estimate.
These structures are declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_result.h</span></code>.</p>
<p>The following struct contains value and error fields.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_sf_result">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_result</span></span></span><a class="headerlink" href="#c.gsl_sf_result" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span> <span class="n">gsl_sf_result</span><span class="p">;</span>
</pre></div>
</div>
<p>The field <code class="xref c c-data docutils literal notranslate"><span class="pre">val</span></code> contains the value and the field <code class="xref c c-data docutils literal notranslate"><span class="pre">err</span></code> contains
an estimate of the absolute error in the value.</p>
</dd></dl>

<p>In some cases, an overflow or underflow can be detected and handled by a
function.  In this case, it may be possible to return a scaling exponent
as well as an error/value pair in order to save the result from
exceeding the dynamic range of the built-in types.  The
following struct contains value and error fields as well
as an exponent field such that the actual result is obtained as
<code class="code docutils literal notranslate"><span class="pre">result</span> <span class="pre">*</span> <span class="pre">10^(e10)</span></code>.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_sf_result_e10">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_result_e10</span></span></span><a class="headerlink" href="#c.gsl_sf_result_e10" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">err</span><span class="p">;</span>
  <span class="nb">int</span>    <span class="n">e10</span><span class="p">;</span>
<span class="p">}</span> <span class="n">gsl_sf_result_e10</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="modes">
<h2>Modes<a class="headerlink" href="#modes" title="Permalink to this heading">¶</a></h2>
<p>The goal of the library is to achieve double precision accuracy wherever
possible.  However the cost of evaluating some special functions to
double precision can be significant, particularly where very high order
terms are required.  In these cases a <code class="code docutils literal notranslate"><span class="pre">mode</span></code> argument, of type
<a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_mode_t</span></code></a> allows the
accuracy of the function to be reduced in order to improve performance.
The following precision levels are available for the mode argument,</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_mode_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_mode_t</span></span></span><a class="headerlink" href="#c.gsl_mode_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_mode_t.GSL_PREC_DOUBLE">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_PREC_DOUBLE</span></span></span><a class="headerlink" href="#c.gsl_mode_t.GSL_PREC_DOUBLE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Double-precision, a relative accuracy of approximately <img class="math" src="_images/math/b2e0649ee97d90153e338c0894021920061e06e4.png" alt="2 * 10^{-16}"/>.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_mode_t.GSL_PREC_SINGLE">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_PREC_SINGLE</span></span></span><a class="headerlink" href="#c.gsl_mode_t.GSL_PREC_SINGLE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Single-precision, a relative accuracy of approximately <img class="math" src="_images/math/5340c340f21a5bb82b14ab70ad1e8bcf3ffe37d1.png" alt="10^{-7}"/>.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_mode_t.GSL_PREC_APPROX">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_PREC_APPROX</span></span></span><a class="headerlink" href="#c.gsl_mode_t.GSL_PREC_APPROX" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Approximate values, a relative accuracy of approximately <img class="math" src="_images/math/8d670abbd3eb26812dcd154f2fcf1590839b7afb.png" alt="5 * 10^{-4}"/>.</p>
</dd></dl>

</dd></dl>

<p>The approximate mode provides the fastest evaluation at the lowest
accuracy.</p>
</div>
<div class="section" id="airy-functions-and-derivatives">
<h2>Airy Functions and Derivatives<a class="headerlink" href="#airy-functions-and-derivatives" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-1"></span><span class="target" id="index-2"></span><p id="index-3">The Airy functions <img class="math" src="_images/math/e5beeb76ccf84528747db4099eeaed51e2d10cfd.png" alt="Ai(x)"/> and <img class="math" src="_images/math/17d4b4a3f7b7c9e128d53241d7fc47b2919f06fa.png" alt="Bi(x)"/> are defined by the
integral representations,</p>
<div class="math">
<p><img src="_images/math/f89dcef7bca7bdaf08e482da332e2b4ed87b3655.png" alt="Ai(x) &amp; = {1\over\pi} \int_0^\infty \cos(t^3/3 + xt ) \,dt \\
Bi(x) &amp; = {1\over\pi} \int_0^\infty (e^{-t^3/3 + xt} + \sin(t^3/3 + xt)) \,dt"/></p>
</div><p>For further information see Abramowitz &amp; Stegun, Section 10.4. The Airy
functions are defined in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_airy.h</span></code>.</p>
<div class="section" id="airy-functions">
<h3>Airy Functions<a class="headerlink" href="#airy-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Airy function <img class="math" src="_images/math/e5beeb76ccf84528747db4099eeaed51e2d10cfd.png" alt="Ai(x)"/> with an accuracy
specified by <a class="reference internal" href="#c.gsl_sf_airy_Ai_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Airy function <img class="math" src="_images/math/17d4b4a3f7b7c9e128d53241d7fc47b2919f06fa.png" alt="Bi(x)"/> with an accuracy
specified by <a class="reference internal" href="#c.gsl_sf_airy_Bi_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute a scaled version of the Airy function
<img class="math" src="_images/math/72aec279ebe8f6fbfc49b0e44aa299d7bf7333c0.png" alt="S_A(x) Ai(x)"/>.  For <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/> the scaling factor <img class="math" src="_images/math/c021661c3be1b3c98920c056a9ea6beb6243959a.png" alt="S_A(x)"/> is
<img class="math" src="_images/math/6ba1517b6a36150320b4c3f1f58fef072eadc2fb.png" alt="\exp(+(2/3) x^{3/2})"/>,
and is 1 for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute a scaled version of the Airy function
<img class="math" src="_images/math/3d8ed47442423b966a19ba1a47f82a27ad49d166.png" alt="S_B(x) Bi(x)"/>.  For <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/> the scaling factor <img class="math" src="_images/math/453625eb615d425d7931cbfeb6c6e27c349f616d.png" alt="S_B(x)"/> is
<img class="math" src="_images/math/5f1fbccd2d62724e7a060549f5c604b93988f433.png" alt="exp(-(2/3) x^{3/2})"/>, and is 1 for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="derivatives-of-airy-functions">
<h3>Derivatives of Airy Functions<a class="headerlink" href="#derivatives-of-airy-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai_deriv">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai_deriv</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai_deriv_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai_deriv_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai_deriv_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Airy function derivative <img class="math" src="_images/math/1c492b20f0e7e53bcf9ff65433f948321950fde1.png" alt="Ai'(x)"/> with
an accuracy specified by <a class="reference internal" href="#c.gsl_sf_airy_Ai_deriv_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi_deriv">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi_deriv</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi_deriv_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi_deriv_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi_deriv_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Airy function derivative <img class="math" src="_images/math/2ae8e4ac4c5eb99c18195cde3c1d87bfca89b20c.png" alt="Bi'(x)"/> with
an accuracy specified by <a class="reference internal" href="#c.gsl_sf_airy_Bi_deriv_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai_deriv_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai_deriv_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai_deriv_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Ai_deriv_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Ai_deriv_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Ai_deriv_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled Airy function derivative
<img class="math" src="_images/math/7d5bf638809ad5c3a0f05211252068c209259147.png" alt="S_A(x) Ai'(x)"/>.
For <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/> the scaling factor <img class="math" src="_images/math/c021661c3be1b3c98920c056a9ea6beb6243959a.png" alt="S_A(x)"/> is
<img class="math" src="_images/math/6ba1517b6a36150320b4c3f1f58fef072eadc2fb.png" alt="\exp(+(2/3) x^{3/2})"/>, and is 1 for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi_deriv_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi_deriv_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi_deriv_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_Bi_deriv_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_Bi_deriv_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_Bi_deriv_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled Airy function derivative
<img class="math" src="_images/math/0455bccc0e6e92b6f7cfa68e6f9bb70fe45243ba.png" alt="S_B(x) Bi'(x)"/>.
For <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/> the scaling factor <img class="math" src="_images/math/453625eb615d425d7931cbfeb6c6e27c349f616d.png" alt="S_B(x)"/> is
<img class="math" src="_images/math/5f1fbccd2d62724e7a060549f5c604b93988f433.png" alt="exp(-(2/3) x^{3/2})"/>, and is 1 for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="zeros-of-airy-functions">
<h3>Zeros of Airy Functions<a class="headerlink" href="#zeros-of-airy-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Ai">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Ai</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Ai" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Ai_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Ai_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Ai_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the location of the <a class="reference internal" href="#c.gsl_sf_airy_zero_Ai_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th zero of the Airy
function <img class="math" src="_images/math/e5beeb76ccf84528747db4099eeaed51e2d10cfd.png" alt="Ai(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Bi">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Bi</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Bi" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Bi_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Bi_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Bi_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the location of the <a class="reference internal" href="#c.gsl_sf_airy_zero_Bi_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th zero of the Airy
function <img class="math" src="_images/math/17d4b4a3f7b7c9e128d53241d7fc47b2919f06fa.png" alt="Bi(x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="zeros-of-derivatives-of-airy-functions">
<h3>Zeros of Derivatives of Airy Functions<a class="headerlink" href="#zeros-of-derivatives-of-airy-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Ai_deriv">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Ai_deriv</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Ai_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Ai_deriv_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Ai_deriv_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Ai_deriv_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the location of the <a class="reference internal" href="#c.gsl_sf_airy_zero_Ai_deriv_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th zero of the Airy
function derivative <img class="math" src="_images/math/1c492b20f0e7e53bcf9ff65433f948321950fde1.png" alt="Ai'(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Bi_deriv">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Bi_deriv</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Bi_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_airy_zero_Bi_deriv_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_airy_zero_Bi_deriv_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_airy_zero_Bi_deriv_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the location of the <a class="reference internal" href="#c.gsl_sf_airy_zero_Bi_deriv_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th zero of the Airy
function derivative <img class="math" src="_images/math/2ae8e4ac4c5eb99c18195cde3c1d87bfca89b20c.png" alt="Bi'(x)"/>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="bessel-functions">
<h2>Bessel Functions<a class="headerlink" href="#bessel-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-4">The routines described in this section compute the Cylindrical Bessel
functions <img class="math" src="_images/math/c76a5732cfcc8829fe3dfd6069330c88ce587230.png" alt="J_n(x)"/>, <img class="math" src="_images/math/3035e58718859d61fb3032fe78af0f2943a0022b.png" alt="Y_n(x)"/>, Modified cylindrical Bessel
functions <img class="math" src="_images/math/b925957f17c9276ff9524b361fabd326470dbec4.png" alt="I_n(x)"/>, <img class="math" src="_images/math/7d213610a6208db6f73ec4b30267a1b1891ed433.png" alt="K_n(x)"/>, Spherical Bessel functions
<img class="math" src="_images/math/bd52aafac694d00fa3c97f920cbf89c459b9807d.png" alt="j_l(x)"/>, <img class="math" src="_images/math/c7d4394c49f9b8a3fcc89b00bb201b57edaf3b53.png" alt="y_l(x)"/>, and Modified Spherical Bessel functions
<img class="math" src="_images/math/8ea78a92cc1e5785e55a81dc6586dd7e6f407c5e.png" alt="i_l(x)"/>, <img class="math" src="_images/math/6be72408109377345980dca8dd24da7060c64555.png" alt="k_l(x)"/>.  For more information see Abramowitz &amp; Stegun,
Chapters 9 and 10.  The Bessel functions are defined in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_bessel.h</span></code>.</p>
<div class="section" id="regular-cylindrical-bessel-functions">
<h3>Regular Cylindrical Bessel Functions<a class="headerlink" href="#regular-cylindrical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-5"></span><span class="target" id="index-6"></span><span class="target" id="index-7"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_J0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_J0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_J0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_J0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_J0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_J0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular cylindrical Bessel function of zeroth
order, <img class="math" src="_images/math/596c757495a55561b57f4fb478ab0041f951a151.png" alt="J_0(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_J1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_J1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_J1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_J1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_J1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_J1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular cylindrical Bessel function of first
order, <img class="math" src="_images/math/b025eafeb12efef3cd3517edb4962d3fea0e00c1.png" alt="J_1(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Jn">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Jn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Jn" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Jn_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Jn_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Jn_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular cylindrical Bessel function of
order <a class="reference internal" href="#c.gsl_sf_bessel_Jn_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/c76a5732cfcc8829fe3dfd6069330c88ce587230.png" alt="J_n(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Jn_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Jn_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Jn_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the regular cylindrical Bessel
functions <img class="math" src="_images/math/c76a5732cfcc8829fe3dfd6069330c88ce587230.png" alt="J_n(x)"/> for <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from <a class="reference internal" href="#c.gsl_sf_bessel_Jn_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to <a class="reference internal" href="#c.gsl_sf_bessel_Jn_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a>
inclusive, storing the results in the array <a class="reference internal" href="#c.gsl_sf_bessel_Jn_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.  The
values are computed using recurrence relations for efficiency, and
therefore may differ slightly from the exact values.</p>
</dd></dl>

</div>
<div class="section" id="irregular-cylindrical-bessel-functions">
<h3>Irregular Cylindrical Bessel Functions<a class="headerlink" href="#irregular-cylindrical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Y0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Y0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Y0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Y0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Y0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Y0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular cylindrical Bessel function of zeroth
order, <img class="math" src="_images/math/9b5cd2263fe3212d9f891da1a4a10ba09411d326.png" alt="Y_0(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Y1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Y1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Y1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Y1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Y1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Y1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular cylindrical Bessel function of first
order, <img class="math" src="_images/math/335af7c7fb12e3bf1f410b8022b24d64403a681c.png" alt="Y_1(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Yn">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Yn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Yn" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Yn_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Yn_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Yn_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular cylindrical Bessel function of
order <a class="reference internal" href="#c.gsl_sf_bessel_Yn_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/3035e58718859d61fb3032fe78af0f2943a0022b.png" alt="Y_n(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Yn_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Yn_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Yn_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the irregular cylindrical Bessel
functions <img class="math" src="_images/math/3035e58718859d61fb3032fe78af0f2943a0022b.png" alt="Y_n(x)"/> for <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from <a class="reference internal" href="#c.gsl_sf_bessel_Yn_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to <a class="reference internal" href="#c.gsl_sf_bessel_Yn_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a>
inclusive, storing the results in the array <a class="reference internal" href="#c.gsl_sf_bessel_Yn_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.  The
domain of the function is <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.  The values are computed using
recurrence relations for efficiency, and therefore may differ slightly
from the exact values.</p>
</dd></dl>

</div>
<div class="section" id="regular-modified-cylindrical-bessel-functions">
<h3>Regular Modified Cylindrical Bessel Functions<a class="headerlink" href="#regular-modified-cylindrical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular modified cylindrical Bessel function
of zeroth order, <img class="math" src="_images/math/4280f606a04096bdac5e20544aad4c1be39207b3.png" alt="I_0(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular modified cylindrical Bessel function
of first order, <img class="math" src="_images/math/52937c2701be5f3f164d1ef932f346d0935b1373.png" alt="I_1(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_In">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_In</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_In" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_In_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_In_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_In_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular modified cylindrical Bessel function
of order <a class="reference internal" href="#c.gsl_sf_bessel_In_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/b925957f17c9276ff9524b361fabd326470dbec4.png" alt="I_n(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_In_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_In_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_In_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the regular modified cylindrical
Bessel functions <img class="math" src="_images/math/b925957f17c9276ff9524b361fabd326470dbec4.png" alt="I_n(x)"/> for <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from <a class="reference internal" href="#c.gsl_sf_bessel_In_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to
<a class="reference internal" href="#c.gsl_sf_bessel_In_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> inclusive, storing the results in the array
<a class="reference internal" href="#c.gsl_sf_bessel_In_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.  The start of the range <a class="reference internal" href="#c.gsl_sf_bessel_In_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I0_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I0_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I0_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I0_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I0_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I0_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified cylindrical Bessel
function of zeroth order <img class="math" src="_images/math/371578e62946d40996f106c786949186fa69ce19.png" alt="\exp(-|x|) I_0(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I1_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I1_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I1_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_I1_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_I1_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_I1_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified cylindrical Bessel
function of first order <img class="math" src="_images/math/8dde151a646802a4e802cca612807a34bb689bf3.png" alt="\exp(-|x|) I_1(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_In_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_In_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_In_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_In_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_In_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_In_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified cylindrical Bessel
function of order <a class="reference internal" href="#c.gsl_sf_bessel_In_scaled_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/d0fc4dfa9bbc01a597c002b86d4f666bfd87ad35.png" alt="\exp(-|x|) I_n(x)"/></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_In_scaled_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_In_scaled_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_In_scaled_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the scaled regular cylindrical
Bessel functions <img class="math" src="_images/math/d0fc4dfa9bbc01a597c002b86d4f666bfd87ad35.png" alt="\exp(-|x|) I_n(x)"/> for <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from
<a class="reference internal" href="#c.gsl_sf_bessel_In_scaled_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to <a class="reference internal" href="#c.gsl_sf_bessel_In_scaled_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> inclusive, storing the results in the array
<a class="reference internal" href="#c.gsl_sf_bessel_In_scaled_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>. The start of the range <a class="reference internal" href="#c.gsl_sf_bessel_In_scaled_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> must be positive
or zero.  The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.</p>
</dd></dl>

</div>
<div class="section" id="irregular-modified-cylindrical-bessel-functions">
<h3>Irregular Modified Cylindrical Bessel Functions<a class="headerlink" href="#irregular-modified-cylindrical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-13"></span><span class="target" id="index-14"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular modified cylindrical Bessel
function of zeroth order, <img class="math" src="_images/math/2e96c2226f1ebe36298204a597a2eb041c26fc65.png" alt="K_0(x)"/>, for <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular modified cylindrical Bessel
function of first order, <img class="math" src="_images/math/b6e05bd96a363074e8ad9511da417fdbcb6e44ec.png" alt="K_1(x)"/>, for <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Kn">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Kn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Kn" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Kn_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Kn_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Kn_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular modified cylindrical Bessel
function of order <a class="reference internal" href="#c.gsl_sf_bessel_Kn_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/7d213610a6208db6f73ec4b30267a1b1891ed433.png" alt="K_n(x)"/>, for <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Kn_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Kn_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Kn_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the irregular modified cylindrical
Bessel functions <img class="math" src="_images/math/7d213610a6208db6f73ec4b30267a1b1891ed433.png" alt="K_n(x)"/> for <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from <a class="reference internal" href="#c.gsl_sf_bessel_Kn_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to
<a class="reference internal" href="#c.gsl_sf_bessel_Kn_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> inclusive, storing the results in the array
<a class="reference internal" href="#c.gsl_sf_bessel_Kn_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>. The start of the range <a class="reference internal" href="#c.gsl_sf_bessel_Kn_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> must be positive
or zero. The domain of the function is <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K0_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K0_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K0_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K0_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K0_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K0_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified cylindrical Bessel
function of zeroth order <img class="math" src="_images/math/3090d32d0d22c0ffcfabc574120a5a1b07ae047d.png" alt="\exp(x) K_0(x)"/> for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K1_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K1_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K1_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_K1_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_K1_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_K1_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified cylindrical Bessel
function of first order <img class="math" src="_images/math/f43fec436bb8120616718214628b8205bdce796a.png" alt="\exp(x) K_1(x)"/> for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Kn_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Kn_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Kn_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Kn_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Kn_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Kn_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified cylindrical Bessel
function of order <a class="reference internal" href="#c.gsl_sf_bessel_Kn_scaled_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/726ecad0946835612cf1518c4a61bc040cce6923.png" alt="\exp(x) K_n(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Kn_scaled_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Kn_scaled_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Kn_scaled_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the scaled irregular cylindrical
Bessel functions <img class="math" src="_images/math/726ecad0946835612cf1518c4a61bc040cce6923.png" alt="\exp(x) K_n(x)"/> for <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from <a class="reference internal" href="#c.gsl_sf_bessel_Kn_scaled_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to
<a class="reference internal" href="#c.gsl_sf_bessel_Kn_scaled_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> inclusive, storing the results in the array
<a class="reference internal" href="#c.gsl_sf_bessel_Kn_scaled_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>. The start of the range <a class="reference internal" href="#c.gsl_sf_bessel_Kn_scaled_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> must be positive
or zero.  The domain of the function is <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>. The values are
computed using recurrence relations for efficiency, and therefore
may differ slightly from the exact values.</p>
</dd></dl>

</div>
<div class="section" id="regular-spherical-bessel-functions">
<h3>Regular Spherical Bessel Functions<a class="headerlink" href="#regular-spherical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_j0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_j0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_j0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_j0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_j0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_j0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular spherical Bessel function of zeroth
order, <img class="math" src="_images/math/f2f0f8468dfee88353f70e03ac11cbcad470e388.png" alt="j_0(x) = \sin(x)/x"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_j1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_j1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_j1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_j1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_j1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_j1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular spherical Bessel function of first
order, <img class="math" src="_images/math/bd5e828d07879658af86ef4d81eec91a4efcab71.png" alt="j_1(x) = (\sin(x)/x - \cos(x))/x"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_j2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_j2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_j2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_j2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_j2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_j2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular spherical Bessel function of second
order, <img class="math" src="_images/math/ceec27b41de233085ef05bdde499744c7cf6c26c.png" alt="j_2(x) = ((3/x^2 - 1)\sin(x) - 3\cos(x)/x)/x"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_jl">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_jl</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_jl" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_jl_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_jl_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_jl_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular spherical Bessel function of
order <a class="reference internal" href="#c.gsl_sf_bessel_jl_e" title="l"><code class="xref c c-data docutils literal notranslate"><span class="pre">l</span></code></a>, <img class="math" src="_images/math/bd52aafac694d00fa3c97f920cbf89c459b9807d.png" alt="j_l(x)"/>, for
<img class="math" src="_images/math/55d02babf13bdfbd128010d0eedf95481b9fa3f3.png" alt="l \geq 0"/> and <img class="math" src="_images/math/8e00266444306967471bb405944f186076a7e07a.png" alt="x \geq 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_jl_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_jl_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_jl_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the regular spherical Bessel
functions <img class="math" src="_images/math/bd52aafac694d00fa3c97f920cbf89c459b9807d.png" alt="j_l(x)"/> for <img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> from 0 to <a class="reference internal" href="#c.gsl_sf_bessel_jl_array" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a>
inclusive  for
<img class="math" src="_images/math/b01b40466656695d5ee66121344d1d8d63430835.png" alt="lmax \geq 0"/> and
<img class="math" src="_images/math/8e00266444306967471bb405944f186076a7e07a.png" alt="x \geq 0"/>, storing the results in the array <a class="reference internal" href="#c.gsl_sf_bessel_jl_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_jl_steed_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_jl_steed_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_jl_steed_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine uses Steed’s method to compute the values of the regular
spherical Bessel functions <img class="math" src="_images/math/bd52aafac694d00fa3c97f920cbf89c459b9807d.png" alt="j_l(x)"/> for <img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> from 0 to
<a class="reference internal" href="#c.gsl_sf_bessel_jl_steed_array" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a> inclusive for
<img class="math" src="_images/math/b01b40466656695d5ee66121344d1d8d63430835.png" alt="lmax \geq 0"/> and
<img class="math" src="_images/math/8e00266444306967471bb405944f186076a7e07a.png" alt="x \geq 0"/>, storing the results in the array
<a class="reference internal" href="#c.gsl_sf_bessel_jl_steed_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.
The Steed/Barnett algorithm is described in Comp. Phys. Comm. 21,
297 (1981).  Steed’s method is more stable than the
recurrence used in the other functions but is also slower.</p>
</dd></dl>

</div>
<div class="section" id="irregular-spherical-bessel-functions">
<h3>Irregular Spherical Bessel Functions<a class="headerlink" href="#irregular-spherical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-18"></span><span class="target" id="index-19"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_y0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_y0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_y0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_y0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_y0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_y0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular spherical Bessel function of zeroth
order, <img class="math" src="_images/math/16791a6e8c0931b1b54e18e7de9f7cde795f526b.png" alt="y_0(x) = -\cos(x)/x"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_y1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_y1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_y1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_y1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_y1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_y1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular spherical Bessel function of first
order, <img class="math" src="_images/math/dae2ac0c5cc4508dc2b3df730504f3923816c464.png" alt="y_1(x) = -(\cos(x)/x + \sin(x))/x"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_y2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_y2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_y2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_y2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_y2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_y2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular spherical Bessel function of second
order, <img class="math" src="_images/math/b4861d9c77f369aa645c8463723d7f0feaf3e451.png" alt="y_2(x) = (-3/x^3 + 1/x)\cos(x) - (3/x^2)\sin(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_yl">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_yl</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_yl" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_yl_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_yl_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_yl_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular spherical Bessel function of
order <a class="reference internal" href="#c.gsl_sf_bessel_yl_e" title="l"><code class="xref c c-data docutils literal notranslate"><span class="pre">l</span></code></a>, <img class="math" src="_images/math/c7d4394c49f9b8a3fcc89b00bb201b57edaf3b53.png" alt="y_l(x)"/>, for
<img class="math" src="_images/math/55d02babf13bdfbd128010d0eedf95481b9fa3f3.png" alt="l \geq 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_yl_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_yl_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_yl_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the irregular spherical Bessel
functions <img class="math" src="_images/math/c7d4394c49f9b8a3fcc89b00bb201b57edaf3b53.png" alt="y_l(x)"/> for <img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> from 0 to <a class="reference internal" href="#c.gsl_sf_bessel_yl_array" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a>
inclusive for
<img class="math" src="_images/math/b01b40466656695d5ee66121344d1d8d63430835.png" alt="lmax \geq 0"/>, storing the results in the array <a class="reference internal" href="#c.gsl_sf_bessel_yl_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.</p>
</dd></dl>

</div>
<div class="section" id="regular-modified-spherical-bessel-functions">
<h3>Regular Modified Spherical Bessel Functions<a class="headerlink" href="#regular-modified-spherical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-20"></span><span class="target" id="index-21"></span><p id="index-22">The regular modified spherical Bessel functions <img class="math" src="_images/math/8ea78a92cc1e5785e55a81dc6586dd7e6f407c5e.png" alt="i_l(x)"/>
are related to the modified Bessel functions of fractional order,
<img class="math" src="_images/math/163ebaf19761c35f249f036ea59feb82ec4a889e.png" alt="i_l(x) = \sqrt{\pi/(2x)} I_{l+1/2}(x)"/></p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_i0_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_i0_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_i0_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_i0_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_i0_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_i0_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified spherical Bessel
function of zeroth order, <img class="math" src="_images/math/ccb4098e86d3dffe86a82c8d8e8ec255d3508563.png" alt="\exp(-|x|) i_0(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_i1_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_i1_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_i1_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_i1_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_i1_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_i1_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified spherical Bessel
function of first order, <img class="math" src="_images/math/f1d3644880843c33bc573f8d75002619a2021a0f.png" alt="\exp(-|x|) i_1(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_i2_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_i2_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_i2_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_i2_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_i2_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_i2_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified spherical Bessel
function of second order, <img class="math" src="_images/math/959d91f7560143b25b945b4a5988e5b7896a8b10.png" alt="\exp(-|x|) i_2(x)"/></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_il_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_il_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_il_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_il_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_il_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_il_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified spherical Bessel
function of order <a class="reference internal" href="#c.gsl_sf_bessel_il_scaled_e" title="l"><code class="xref c c-data docutils literal notranslate"><span class="pre">l</span></code></a>, <img class="math" src="_images/math/bae11c964ec54384b190cf803c8a7f771b99f764.png" alt="\exp(-|x|) i_l(x)"/></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_il_scaled_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_il_scaled_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_il_scaled_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the scaled regular modified
spherical Bessel functions <img class="math" src="_images/math/bae11c964ec54384b190cf803c8a7f771b99f764.png" alt="\exp(-|x|) i_l(x)"/> for <img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> from
0 to <a class="reference internal" href="#c.gsl_sf_bessel_il_scaled_array" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a> inclusive for
<img class="math" src="_images/math/b01b40466656695d5ee66121344d1d8d63430835.png" alt="lmax \geq 0"/>, storing the results in
the array <a class="reference internal" href="#c.gsl_sf_bessel_il_scaled_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.</p>
</dd></dl>

</div>
<div class="section" id="irregular-modified-spherical-bessel-functions">
<h3>Irregular Modified Spherical Bessel Functions<a class="headerlink" href="#irregular-modified-spherical-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-23"></span><p id="index-24">The irregular modified spherical Bessel functions <img class="math" src="_images/math/6be72408109377345980dca8dd24da7060c64555.png" alt="k_l(x)"/>
are related to the irregular modified Bessel functions of fractional order,
<img class="math" src="_images/math/7efc19f265df0db31ac37f173e3c1a5405fff71a.png" alt="k_l(x) = \sqrt{\pi/(2x)} K_{l+1/2}(x)"/>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_k0_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_k0_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_k0_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_k0_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_k0_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_k0_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified spherical Bessel
function of zeroth order, <img class="math" src="_images/math/2b5f2d785a72c48ec80da60ee6a32a5c90bd67b0.png" alt="\exp(x) k_0(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_k1_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_k1_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_k1_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_k1_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_k1_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_k1_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified spherical Bessel
function of first order, <img class="math" src="_images/math/f6a29d3e88ba4e3c720943ac7a30cca0bf07368a.png" alt="\exp(x) k_1(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_k2_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_k2_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_k2_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_k2_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_k2_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_k2_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified spherical Bessel
function of second order, <img class="math" src="_images/math/9f42a8daa51eca1559a20825cf495c246b1a0b9b.png" alt="\exp(x) k_2(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_kl_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_kl_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_kl_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_kl_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_kl_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_kl_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified spherical Bessel
function of order <a class="reference internal" href="#c.gsl_sf_bessel_kl_scaled_e" title="l"><code class="xref c c-data docutils literal notranslate"><span class="pre">l</span></code></a>, <img class="math" src="_images/math/cad3e71603a284153755ede6a19c6613cf4cdafb.png" alt="\exp(x) k_l(x)"/>, for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_kl_scaled_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_kl_scaled_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_kl_scaled_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the values of the scaled irregular modified
spherical Bessel functions <img class="math" src="_images/math/cad3e71603a284153755ede6a19c6613cf4cdafb.png" alt="\exp(x) k_l(x)"/> for <img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> from
0 to <a class="reference internal" href="#c.gsl_sf_bessel_kl_scaled_array" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a> inclusive for
<img class="math" src="_images/math/b01b40466656695d5ee66121344d1d8d63430835.png" alt="lmax \geq 0"/> and <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>, storing the results in
the array <a class="reference internal" href="#c.gsl_sf_bessel_kl_scaled_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.
The values are computed using recurrence relations for
efficiency, and therefore may differ slightly from the exact values.</p>
</dd></dl>

</div>
<div class="section" id="regular-bessel-function-fractional-order">
<h3>Regular Bessel Function—Fractional Order<a class="headerlink" href="#regular-bessel-function-fractional-order" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-25"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Jnu">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Jnu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Jnu" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Jnu_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Jnu_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Jnu_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular cylindrical Bessel function of
fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/721af3180b910c69b28951705a832f948f7d86b1.png" alt="J_\nu(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_sequence_Jnu_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_sequence_Jnu_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_sequence_Jnu_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the regular cylindrical Bessel function of
fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/721af3180b910c69b28951705a832f948f7d86b1.png" alt="J_\nu(x)"/>, evaluated at a series of
<img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> values.  The array <a class="reference internal" href="#c.gsl_sf_bessel_sequence_Jnu_e" title="v"><code class="xref c c-data docutils literal notranslate"><span class="pre">v</span></code></a> of length <a class="reference internal" href="#c.gsl_sf_bessel_sequence_Jnu_e" title="size"><code class="xref c c-data docutils literal notranslate"><span class="pre">size</span></code></a> contains the
<img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> values.  They are assumed to be strictly ordered and positive.
The array is over-written with the values of <img class="math" src="_images/math/b1299d958636b419497a49380845fb344e8211d8.png" alt="J_\nu(x_i)"/>.</p>
</dd></dl>

</div>
<div class="section" id="irregular-bessel-functions-fractional-order">
<h3>Irregular Bessel Functions—Fractional Order<a class="headerlink" href="#irregular-bessel-functions-fractional-order" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Ynu">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Ynu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Ynu" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Ynu_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Ynu_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Ynu_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular cylindrical Bessel function of
fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/485088e8b10f78b08f6bc5128ac129125fb778a4.png" alt="Y_\nu(x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="regular-modified-bessel-functions-fractional-order">
<h3>Regular Modified Bessel Functions—Fractional Order<a class="headerlink" href="#regular-modified-bessel-functions-fractional-order" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-26"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Inu">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Inu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Inu" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Inu_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Inu_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Inu_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular modified Bessel function of
fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/2cd42343788b68eff1364760d7929dbf9de4128b.png" alt="I_\nu(x)"/> for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>,
<img class="math" src="_images/math/7c3d7694902609c6eda89eb6bcea1101f885f6b3.png" alt="\nu&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Inu_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Inu_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Inu_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Inu_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Inu_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Inu_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled regular modified Bessel function of
fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/f1fa3f08cb173bfb3352856b3e4831939220e616.png" alt="\exp(-|x|)I_\nu(x)"/> for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>,
<img class="math" src="_images/math/7c3d7694902609c6eda89eb6bcea1101f885f6b3.png" alt="\nu&gt;0"/>.</p>
</dd></dl>

</div>
<div class="section" id="irregular-modified-bessel-functions-fractional-order">
<h3>Irregular Modified Bessel Functions—Fractional Order<a class="headerlink" href="#irregular-modified-bessel-functions-fractional-order" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-27"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Knu">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Knu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Knu" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Knu_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Knu_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Knu_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular modified Bessel function of
fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/769d978009e876c472a482d78ddaeceab8c8fadb.png" alt="K_\nu(x)"/> for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>,
<img class="math" src="_images/math/7c3d7694902609c6eda89eb6bcea1101f885f6b3.png" alt="\nu&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_lnKnu">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_lnKnu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_lnKnu" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_lnKnu_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_lnKnu_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_lnKnu_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the irregular modified Bessel
function of fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/b2168b3b35ce765b7fe78b27cf909fb26472f3ff.png" alt="\ln(K_\nu(x))"/> for
<img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>, <img class="math" src="_images/math/7c3d7694902609c6eda89eb6bcea1101f885f6b3.png" alt="\nu&gt;0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Knu_scaled">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Knu_scaled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Knu_scaled" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_Knu_scaled_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_Knu_scaled_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_Knu_scaled_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the scaled irregular modified Bessel function of
fractional order <img class="math" src="_images/math/25f363e3892b0d108cd45bfa18382aca47f09dc2.png" alt="\nu"/>, <img class="math" src="_images/math/4897761728b82691e68b89c47b367de544042608.png" alt="\exp(+|x|) K_\nu(x)"/> for <img class="math" src="_images/math/33cbef73b5aa33f44f9f5702632dfec8868b7627.png" alt="x&gt;0"/>,
<img class="math" src="_images/math/7c3d7694902609c6eda89eb6bcea1101f885f6b3.png" alt="\nu&gt;0"/>.</p>
</dd></dl>

</div>
<div class="section" id="zeros-of-regular-bessel-functions">
<h3>Zeros of Regular Bessel Functions<a class="headerlink" href="#zeros-of-regular-bessel-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-28"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_zero_J0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_zero_J0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_zero_J0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_zero_J0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_zero_J0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_zero_J0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the location of the <a class="reference internal" href="#c.gsl_sf_bessel_zero_J0_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th positive zero of
the Bessel function <img class="math" src="_images/math/596c757495a55561b57f4fb478ab0041f951a151.png" alt="J_0(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_zero_J1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_zero_J1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_zero_J1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_zero_J1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_zero_J1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_zero_J1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the location of the <a class="reference internal" href="#c.gsl_sf_bessel_zero_J1_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th positive zero of
the Bessel function <img class="math" src="_images/math/b025eafeb12efef3cd3517edb4962d3fea0e00c1.png" alt="J_1(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_bessel_zero_Jnu">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_zero_Jnu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_zero_Jnu" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_bessel_zero_Jnu_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_bessel_zero_Jnu_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">nu</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_bessel_zero_Jnu_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the location of the <a class="reference internal" href="#c.gsl_sf_bessel_zero_Jnu_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th positive zero of
the Bessel function <img class="math" src="_images/math/721af3180b910c69b28951705a832f948f7d86b1.png" alt="J_\nu(x)"/>.  The current implementation does not
support negative values of <a class="reference internal" href="#c.gsl_sf_bessel_zero_Jnu_e" title="nu"><code class="xref c c-data docutils literal notranslate"><span class="pre">nu</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="clausen-functions">
<h2>Clausen Functions<a class="headerlink" href="#clausen-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-29">The Clausen function is defined by the following integral,</p>
<div class="math">
<p><img src="_images/math/37f6f9608552d06096cdddbb494ab1fd89af1e24.png" alt="Cl_2(x) = - \int_0^x dt \log{\left( 2 \sin{(t/2)} \right)}"/></p>
</div><p>It is related to the <a class="reference internal" href="#dilog-function"><span class="std std-ref">dilogarithm</span></a> by
<img class="math" src="_images/math/edd0b4ad29b04a426738e226a089a85bbfa52247.png" alt="Cl_2(\theta) = \Im Li_2(\exp(i\theta))"/>.
The Clausen functions are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_clausen.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_clausen">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_clausen</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_clausen" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_clausen_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_clausen_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_clausen_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Clausen integral <img class="math" src="_images/math/7ef98810e46f14e9dcd2d515e81a5384490ea16e.png" alt="Cl_2(x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="coulomb-functions">
<h2>Coulomb Functions<a class="headerlink" href="#coulomb-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-30">The prototypes of the Coulomb functions are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_coulomb.h</span></code>.  Both bound state and scattering solutions are
available.</p>
<div class="section" id="normalized-hydrogenic-bound-states">
<h3>Normalized Hydrogenic Bound States<a class="headerlink" href="#normalized-hydrogenic-bound-states" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hydrogenicR_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hydrogenicR_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">Z</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hydrogenicR_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hydrogenicR_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hydrogenicR_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">Z</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hydrogenicR_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction
<img class="math" src="_images/math/2aa79f10f69fb712dcf1e71a50afe9fe2a7efca9.png" alt="R_1 := 2Z \sqrt{Z} \exp(-Z r)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hydrogenicR">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hydrogenicR</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">Z</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hydrogenicR" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hydrogenicR_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hydrogenicR_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">Z</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hydrogenicR_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the <a class="reference internal" href="#c.gsl_sf_hydrogenicR_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>-th normalized hydrogenic bound state
radial wavefunction,</p>
<div class="math">
<p><img src="_images/math/bb0a4c46c3d94d6c42d999eb079e8535f31155d4.png" alt="R_n := {2 Z^{3/2} \over n^2}  \left({2Z r \over n}\right)^l  \sqrt{(n-l-1)! \over (n+l)!} \exp(-Z r/n) L^{2l+1}_{n-l-1}(2Z r / n)."/></p>
</div><p>where <img class="math" src="_images/math/611f4cd9a1f8d33d1c8354bad6fcb8195230c464.png" alt="L^a_b(x)"/> is the <a class="reference internal" href="#laguerre-functions"><span class="std std-ref">generalized Laguerre polynomial</span></a>.
The normalization is chosen such that the wavefunction <img class="math" src="_images/math/46bcc3713a4764034c7b901e6230d4dcd4a02b0f.png" alt="\psi"/> is
given by <img class="math" src="_images/math/6728eeb75ce966b13e9ac1d0192cf9c56c577fe5.png" alt="\psi(n,l,r) = R_n Y_{lm}"/>.</p>
</dd></dl>

</div>
<div class="section" id="coulomb-wave-functions">
<h3>Coulomb Wave Functions<a class="headerlink" href="#coulomb-wave-functions" title="Permalink to this heading">¶</a></h3>
<p>The Coulomb wave functions <img class="math" src="_images/math/81cccf0bc16f667bc65f3e2e76877612cc8b2338.png" alt="F_L(\eta,x)"/>, <img class="math" src="_images/math/a2d1755bb2a1f3c4846d8a923ab3bfb7e9beed88.png" alt="G_L(\eta,x)"/> are
described in Abramowitz &amp; Stegun, Chapter 14.  Because there can be a
large dynamic range of values for these functions, overflows are handled
gracefully.  If an overflow occurs, <code class="code docutils literal notranslate"><span class="pre">GSL_EOVRFLW</span></code> is signalled and
exponent(s) are returned through the modifiable parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">exp_F</span></code>,
<code class="xref c c-data docutils literal notranslate"><span class="pre">exp_G</span></code>. The full solution can be reconstructed from the following
relations,</p>
<div class="math">
<p><img src="_images/math/6190fd08dc74c14aa85c0b7c42a5d364ceb6aa30.png" alt="F_L(\eta,x) &amp;= fc[k_L] * \exp(exp_F) \\
G_L(\eta,x) &amp;= gc[k_L] * \exp(exp_G)"/></p>
</div><div class="math">
<p><img src="_images/math/f3620d8d9a3906043a593fe219a6825784b0282a.png" alt="F_L'(\eta,x) &amp;= fcp[k_L] * \exp(exp_F) \\
G_L'(\eta,x) &amp;= gcp[k_L] * \exp(exp_G)"/></p>
</div><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coulomb_wave_FG_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coulomb_wave_FG_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">L_F</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">F</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Fp</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">G</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Gp</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_F</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_G</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coulomb_wave_FG_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the Coulomb wave functions <img class="math" src="_images/math/81cccf0bc16f667bc65f3e2e76877612cc8b2338.png" alt="F_L(\eta,x)"/>,
<img class="math" src="_images/math/e14b28aa12e999e11abf6b1c8b8c2ccf52828f11.png" alt="G_{L-k}(\eta,x)"/> and their derivatives
<img class="math" src="_images/math/5fc04ad3f06fb18c5e34152de30c4af8546cf2a3.png" alt="F'_L(\eta,x)"/>,
<img class="math" src="_images/math/a5b121c4e5f48fc0bd89438734e602b770dd64ec.png" alt="G'_{L-k}(\eta,x)"/>
with respect to <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>.  The parameters are restricted to <img class="math" src="_images/math/041cd23622f83f6b32c6d712b0b142e552be4d5d.png" alt="L, L-k &gt; -1/2"/>,
<img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/> and integer <img class="math" src="_images/math/71e6c03676f7f43b827bdaf404bc29149f5d99d7.png" alt="k"/>.  Note that <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>
itself is not restricted to being an integer. The results are stored in
the parameters F, G for the function values and <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_e" title="Fp"><code class="xref c c-data docutils literal notranslate"><span class="pre">Fp</span></code></a>,
<a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_e" title="Gp"><code class="xref c c-data docutils literal notranslate"><span class="pre">Gp</span></code></a> for the derivative values.  If an overflow occurs,
<code class="code docutils literal notranslate"><span class="pre">GSL_EOVRFLW</span></code> is returned and scaling exponents are stored in
the modifiable parameters <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_e" title="exp_F"><code class="xref c c-data docutils literal notranslate"><span class="pre">exp_F</span></code></a>, <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_e" title="exp_G"><code class="xref c c-data docutils literal notranslate"><span class="pre">exp_G</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coulomb_wave_F_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coulomb_wave_F_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">L_min</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">fc_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">F_exponent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coulomb_wave_F_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the Coulomb wave function <img class="math" src="_images/math/81cccf0bc16f667bc65f3e2e76877612cc8b2338.png" alt="F_L(\eta,x)"/> for
<img class="math" src="_images/math/eb20baba0bdd20ec09171b3f609a6ac8d9e8b9a5.png" alt="L = Lmin \dots Lmin + kmax"/>, storing the results in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_F_array" title="fc_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">fc_array</span></code></a>.
In the case of overflow the exponent is stored in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_F_array" title="F_exponent"><code class="xref c c-data docutils literal notranslate"><span class="pre">F_exponent</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coulomb_wave_FG_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coulomb_wave_FG_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">L_min</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">fc_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">gc_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">F_exponent</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">G_exponent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coulomb_wave_FG_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the functions <img class="math" src="_images/math/81cccf0bc16f667bc65f3e2e76877612cc8b2338.png" alt="F_L(\eta,x)"/>,
<img class="math" src="_images/math/a2d1755bb2a1f3c4846d8a923ab3bfb7e9beed88.png" alt="G_L(\eta,x)"/> for <img class="math" src="_images/math/eb20baba0bdd20ec09171b3f609a6ac8d9e8b9a5.png" alt="L = Lmin \dots Lmin + kmax"/> storing the
results in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_array" title="fc_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">fc_array</span></code></a> and <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_array" title="gc_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">gc_array</span></code></a>.  In the case of overflow the
exponents are stored in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_array" title="F_exponent"><code class="xref c c-data docutils literal notranslate"><span class="pre">F_exponent</span></code></a> and <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FG_array" title="G_exponent"><code class="xref c c-data docutils literal notranslate"><span class="pre">G_exponent</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coulomb_wave_FGp_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coulomb_wave_FGp_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">L_min</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">fc_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">fcp_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">gc_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">gcp_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">F_exponent</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">G_exponent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coulomb_wave_FGp_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the functions <img class="math" src="_images/math/81cccf0bc16f667bc65f3e2e76877612cc8b2338.png" alt="F_L(\eta,x)"/>,
<img class="math" src="_images/math/a2d1755bb2a1f3c4846d8a923ab3bfb7e9beed88.png" alt="G_L(\eta,x)"/> and their derivatives <img class="math" src="_images/math/5fc04ad3f06fb18c5e34152de30c4af8546cf2a3.png" alt="F'_L(\eta,x)"/>,
<img class="math" src="_images/math/a52ffba447f34a8be9ed8b3dfdd57a98bb95c2a7.png" alt="G'_L(\eta,x)"/> for <img class="math" src="_images/math/eb20baba0bdd20ec09171b3f609a6ac8d9e8b9a5.png" alt="L = Lmin \dots Lmin + kmax"/> storing the
results in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FGp_array" title="fc_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">fc_array</span></code></a>, <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FGp_array" title="gc_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">gc_array</span></code></a>, <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FGp_array" title="fcp_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">fcp_array</span></code></a> and <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FGp_array" title="gcp_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">gcp_array</span></code></a>.
In the case of overflow the exponents are stored in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FGp_array" title="F_exponent"><code class="xref c c-data docutils literal notranslate"><span class="pre">F_exponent</span></code></a>
and <a class="reference internal" href="#c.gsl_sf_coulomb_wave_FGp_array" title="G_exponent"><code class="xref c c-data docutils literal notranslate"><span class="pre">G_exponent</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coulomb_wave_sphF_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coulomb_wave_sphF_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">L_min</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">fc_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">F_exponent</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coulomb_wave_sphF_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the Coulomb wave function divided by the argument
<img class="math" src="_images/math/5d7d20d8bafe9edd724d8bace8d6cd4e51ca8b9a.png" alt="F_L(\eta, x)/x"/> for <img class="math" src="_images/math/eb20baba0bdd20ec09171b3f609a6ac8d9e8b9a5.png" alt="L = Lmin \dots Lmin + kmax"/>, storing the
results in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_sphF_array" title="fc_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">fc_array</span></code></a>.  In the case of overflow the exponent is
stored in <a class="reference internal" href="#c.gsl_sf_coulomb_wave_sphF_array" title="F_exponent"><code class="xref c c-data docutils literal notranslate"><span class="pre">F_exponent</span></code></a>. This function reduces to spherical Bessel
functions in the limit <img class="math" src="_images/math/5f9024414e9b22677b79d02b1451151eefedf782.png" alt="\eta \to 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="coulomb-wave-function-normalization-constant">
<h3>Coulomb Wave Function Normalization Constant<a class="headerlink" href="#coulomb-wave-function-normalization-constant" title="Permalink to this heading">¶</a></h3>
<p>The Coulomb wave function normalization constant is defined in
Abramowitz 14.1.7.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coulomb_CL_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coulomb_CL_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">L</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coulomb_CL_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the Coulomb wave function normalization constant
<img class="math" src="_images/math/5bf3e8b6a3db92bead96e14dde8397d181ecd979.png" alt="C_L(\eta)"/> for <img class="math" src="_images/math/68e405c90c606e198c3f43fa10d591ea7be4de52.png" alt="L &gt; -1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coulomb_CL_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coulomb_CL_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">Lmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">cl</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coulomb_CL_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the Coulomb wave function normalization constant
<img class="math" src="_images/math/5bf3e8b6a3db92bead96e14dde8397d181ecd979.png" alt="C_L(\eta)"/> for <img class="math" src="_images/math/eb20baba0bdd20ec09171b3f609a6ac8d9e8b9a5.png" alt="L = Lmin \dots Lmin + kmax"/>, <img class="math" src="_images/math/1e098b98debf155aec361e3e49d19e6b1d0a3f68.png" alt="Lmin &gt; -1"/>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="coupling-coefficients">
<h2>Coupling Coefficients<a class="headerlink" href="#coupling-coefficients" title="Permalink to this heading">¶</a></h2>
<p id="index-31">The Wigner 3-j, 6-j and 9-j symbols give the coupling coefficients for
combined angular momentum vectors.  Since the arguments of the standard
coupling coefficient functions are integer or half-integer, the
arguments of the following functions are, by convention, integers equal
to twice the actual spin value.  For information on the 3-j coefficients
see Abramowitz &amp; Stegun, Section 27.9.  The functions described in this
section are declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_coupling.h</span></code>.</p>
<div class="section" id="j-symbols">
<h3>3-j Symbols<a class="headerlink" href="#j-symbols" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coupling_3j">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coupling_3j</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ja</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jc</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_mb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_mc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coupling_3j" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_coupling_3j_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coupling_3j_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ja</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jc</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_mb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_mc</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coupling_3j_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Wigner 3-j coefficient,</p>
<div class="math">
<p><img src="_images/math/542ccab404fae5d5291a27288af7bf3acc79bf8d.png" alt="\left(
\begin{array}{ccc}
  ja &amp; jb &amp; jc \\
  ma &amp; mb &amp; mc
\end{array}
\right)"/></p>
</div><p>where the arguments are given in half-integer units, <img class="math" src="_images/math/0f89b89cf9f1196976c95a1ca3765caa1a25c1e4.png" alt="ja"/> =
<a class="reference internal" href="#c.gsl_sf_coupling_3j_e" title="two_ja"><code class="xref c c-data docutils literal notranslate"><span class="pre">two_ja</span></code></a>/2, <img class="math" src="_images/math/711ded38e4b27e1d6c49fb773948e85d3a75df81.png" alt="ma"/> = <a class="reference internal" href="#c.gsl_sf_coupling_3j_e" title="two_ma"><code class="xref c c-data docutils literal notranslate"><span class="pre">two_ma</span></code></a>/2, etc.</p>
</dd></dl>

</div>
<div class="section" id="id1">
<h3>6-j Symbols<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coupling_6j">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coupling_6j</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ja</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jc</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_je</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coupling_6j" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_coupling_6j_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coupling_6j_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ja</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jc</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_je</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jf</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coupling_6j_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Wigner 6-j coefficient,</p>
<div class="math">
<p><img src="_images/math/4da367ab5b2d9e3aa0cc00fcd00f981785b19745.png" alt="\left\{
\begin{array}{ccc}
  ja &amp; jb &amp; jc \\
  jd &amp; je &amp; jf
\end{array}
\right\}"/></p>
</div><p>where the arguments are given in half-integer units, <img class="math" src="_images/math/0f89b89cf9f1196976c95a1ca3765caa1a25c1e4.png" alt="ja"/> =
<a class="reference internal" href="#c.gsl_sf_coupling_6j_e" title="two_ja"><code class="xref c c-data docutils literal notranslate"><span class="pre">two_ja</span></code></a>/2, <img class="math" src="_images/math/711ded38e4b27e1d6c49fb773948e85d3a75df81.png" alt="ma"/> = <code class="xref c c-data docutils literal notranslate"><span class="pre">two_ma</span></code>/2, etc.</p>
</dd></dl>

</div>
<div class="section" id="id2">
<h3>9-j Symbols<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_coupling_9j">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coupling_9j</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ja</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jc</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_je</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jh</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ji</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coupling_9j" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_coupling_9j_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_coupling_9j_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ja</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jc</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_je</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_jh</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">two_ji</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_coupling_9j_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Wigner 9-j coefficient,</p>
<div class="math">
<p><img src="_images/math/fe451aff14b1d9b7f547dbdb477c9a5656d3d439.png" alt="\left\{
\begin{array}{ccc}
  ja &amp; jb &amp; jc \\
  jd &amp; je &amp; jf \\
  jg &amp; jh &amp; ji
\end{array}
\right\}"/></p>
</div><p>where the arguments are given in half-integer units, <img class="math" src="_images/math/0f89b89cf9f1196976c95a1ca3765caa1a25c1e4.png" alt="ja"/> =
<a class="reference internal" href="#c.gsl_sf_coupling_9j_e" title="two_ja"><code class="xref c c-data docutils literal notranslate"><span class="pre">two_ja</span></code></a>/2, <img class="math" src="_images/math/711ded38e4b27e1d6c49fb773948e85d3a75df81.png" alt="ma"/> = <code class="xref c c-data docutils literal notranslate"><span class="pre">two_ma</span></code>/2, etc.</p>
</dd></dl>

</div>
</div>
<div class="section" id="dawson-function">
<h2>Dawson Function<a class="headerlink" href="#dawson-function" title="Permalink to this heading">¶</a></h2>
<p id="index-32">The Dawson integral is defined by</p>
<div class="math">
<p><img src="_images/math/8d263a7cc44125df488e402158bd06bc1db69bf9.png" alt="\exp(-x^2) \int_0^x dt \exp(t^2)"/></p>
</div><p>A table of Dawson’s integral can be found in Abramowitz &amp;
Stegun, Table 7.5.  The Dawson functions are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_dawson.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_dawson">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_dawson</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_dawson" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_dawson_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_dawson_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_dawson_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the value of Dawson’s integral for <a class="reference internal" href="#c.gsl_sf_dawson_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="debye-functions">
<h2>Debye Functions<a class="headerlink" href="#debye-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-33">The Debye functions <img class="math" src="_images/math/148a9016f1f6b008d146265ce281563a630a66b3.png" alt="D_n(x)"/> are defined by the following integral,</p>
<div class="math">
<p><img src="_images/math/88b96ee8e86ca4c2b9b2fb652f6337b05dc03001.png" alt="D_n(x) = {n \over x^n} \int_0^x dt {t^n \over e^t - 1}"/></p>
</div><p>For further information see Abramowitz &amp;
Stegun, Section 27.1.  The Debye functions are declared in the header
file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_debye.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_debye_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_debye_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the first-order Debye function <img class="math" src="_images/math/fd1a374afcf8ac56173726b51b2ac093dffd3fab.png" alt="D_1(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_debye_2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_debye_2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the second-order Debye function <img class="math" src="_images/math/d32f20c557fe40159204296ed5803ddea1a73458.png" alt="D_2(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_debye_3">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_3</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_3" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_debye_3_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_3_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_3_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the third-order Debye function <img class="math" src="_images/math/05f8d09a3cee9bf6d3d667266f816025f36235de.png" alt="D_3(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_debye_4">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_4</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_4" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_debye_4_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_4_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_4_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the fourth-order Debye function <img class="math" src="_images/math/f8b5badece6c5b660e47f859a54ae78d33be9854.png" alt="D_4(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_debye_5">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_5</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_5" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_debye_5_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_5_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_5_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the fifth-order Debye function <img class="math" src="_images/math/e9623919bc001e398b689381003cca2c860fa16e.png" alt="D_5(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_debye_6">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_6</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_6" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_debye_6_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_debye_6_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_debye_6_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the sixth-order Debye function <img class="math" src="_images/math/0edd8d9f9864045c40c972c3503833cfd56238c2.png" alt="D_6(x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="dilogarithm">
<span id="dilog-function"></span><h2>Dilogarithm<a class="headerlink" href="#dilogarithm" title="Permalink to this heading">¶</a></h2>
<p id="index-34">The dilogarithm is defined as</p>
<div class="math">
<p><img src="_images/math/2e003f330425f77e55943a452f238edab0fcff7e.png" alt="Li_2(z) = - \int_0^z ds {\log{(1-s)} \over s}"/></p>
</div><p>The functions described in this section are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_dilog.h</span></code>.</p>
<div class="section" id="real-argument">
<h3>Real Argument<a class="headerlink" href="#real-argument" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_dilog">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_dilog</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_dilog" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_dilog_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_dilog_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_dilog_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the dilogarithm for a real argument. In Lewin’s
notation this is <img class="math" src="_images/math/a020b40a1c3e107adb9fed070c9dce3de5ccc925.png" alt="Li_2(x)"/>, the real part of the dilogarithm of a
real <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>.  It is defined by the integral representation</p>
<div class="math">
<p><img src="_images/math/506124e21b49bb406f29da0c8333e9634e94dee4.png" alt="Li_2(x) = - \Re \int_0^x ds \log(1-s) / s"/></p>
</div><p>Note that <img class="math" src="_images/math/795a34200417ced7135d0ec929bb5f1330344044.png" alt="\Im(Li_2(x)) = 0"/> for
<img class="math" src="_images/math/28c14601254ce03137f0534004443a4b631948f2.png" alt="x \le 1"/>, and <img class="math" src="_images/math/5180c8b98d1a379d686c7e553eceaebd88d07cab.png" alt="-\pi\log(x)"/> for <img class="math" src="_images/math/41364fa3783c7e2559862af3745071919076c710.png" alt="x &gt; 1"/>.</p>
<p>Note that Abramowitz &amp; Stegun refer to the Spence integral
<img class="math" src="_images/math/a50946b5b860d02ea293276c44bd16e2f0f49c51.png" alt="S(x) = Li_2(1 - x)"/> as the dilogarithm rather than <img class="math" src="_images/math/a020b40a1c3e107adb9fed070c9dce3de5ccc925.png" alt="Li_2(x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="complex-argument">
<h3>Complex Argument<a class="headerlink" href="#complex-argument" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_complex_dilog_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_complex_dilog_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">theta</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_re</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_im</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_complex_dilog_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the full complex-valued dilogarithm for the
complex argument <img class="math" src="_images/math/cb723cb2f856cc2fbbf7754a11915ab7187e4258.png" alt="z = r \exp(i \theta)"/>. The real and imaginary
parts of the result are returned in <a class="reference internal" href="#c.gsl_sf_complex_dilog_e" title="result_re"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_re</span></code></a>, <a class="reference internal" href="#c.gsl_sf_complex_dilog_e" title="result_im"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_im</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="elementary-operations">
<h2>Elementary Operations<a class="headerlink" href="#elementary-operations" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-35"></span><p id="index-36">The following functions allow for the propagation of errors when
combining quantities by multiplication.  The functions are declared in
the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_elementary.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_multiply">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_multiply</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_multiply" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_multiply_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_multiply_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_multiply_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function multiplies <a class="reference internal" href="#c.gsl_sf_multiply_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> and <a class="reference internal" href="#c.gsl_sf_multiply_e" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> storing the product and its
associated error in <a class="reference internal" href="#c.gsl_sf_multiply_e" title="result"><code class="xref c c-data docutils literal notranslate"><span class="pre">result</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_multiply_err_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_multiply_err_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dx</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dy</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_multiply_err_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function multiplies <a class="reference internal" href="#c.gsl_sf_multiply_err_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> and <a class="reference internal" href="#c.gsl_sf_multiply_err_e" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> with associated absolute
errors <a class="reference internal" href="#c.gsl_sf_multiply_err_e" title="dx"><code class="xref c c-data docutils literal notranslate"><span class="pre">dx</span></code></a> and <a class="reference internal" href="#c.gsl_sf_multiply_err_e" title="dy"><code class="xref c c-data docutils literal notranslate"><span class="pre">dy</span></code></a>.  The product
<img class="math" src="_images/math/c5cfe9be1b530528df015d296934e4404dc0cad4.png" alt="xy \pm xy \sqrt{(dx/x)^2 +(dy/y)^2}"/>
is stored in <a class="reference internal" href="#c.gsl_sf_multiply_err_e" title="result"><code class="xref c c-data docutils literal notranslate"><span class="pre">result</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="elliptic-integrals">
<h2>Elliptic Integrals<a class="headerlink" href="#elliptic-integrals" title="Permalink to this heading">¶</a></h2>
<p id="index-37">The functions described in this section are declared in the header
file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_ellint.h</span></code>.  Further information about the elliptic
integrals can be found in Abramowitz &amp; Stegun, Chapter 17.</p>
<div class="section" id="definition-of-legendre-forms">
<h3>Definition of Legendre Forms<a class="headerlink" href="#definition-of-legendre-forms" title="Permalink to this heading">¶</a></h3>
<p id="index-38">The Legendre forms of elliptic integrals <img class="math" src="_images/math/ee11fc65a9e71c9ae5ec70964cb8b1b254545486.png" alt="F(\phi,k)"/>,
<img class="math" src="_images/math/5b21a234b72eb64d5c6e5dd50fee99c0c54018f7.png" alt="E(\phi,k)"/> and <img class="math" src="_images/math/b67092c99156b075567c9eaf532d35ff697ede3f.png" alt="\Pi(\phi,k,n)"/> are defined by,</p>
<div class="math">
<p><img src="_images/math/46fe2a6aee1a3de3865d1140ec626320b263b9c0.png" alt="F(\phi,k)   &amp;= \int_0^\phi dt {1 \over \sqrt{(1 - k^2 \sin^2(t))}} \\
E(\phi,k)   &amp;= \int_0^\phi dt   \sqrt{(1 - k^2 \sin^2(t))} \\
\Pi(\phi,k,n) &amp;= \int_0^\phi dt {1 \over (1 + n \sin^2(t)) \sqrt{1 - k^2 \sin^2(t)}}"/></p>
</div><p>The complete Legendre forms are denoted by <img class="math" src="_images/math/1480ce2bea74e7ad04ee14119492593bc7efdba5.png" alt="K(k) = F(\pi/2, k)"/> and
<img class="math" src="_images/math/32c6d3d89fa19b78723e698822ba0522b3deb230.png" alt="E(k) = E(\pi/2, k)"/>.</p>
<p>The notation used here is based on Carlson, “Numerische
Mathematik” 33 (1979) 1 and differs slightly from that used by
Abramowitz &amp; Stegun, where the functions are given in terms of the
parameter <img class="math" src="_images/math/6901b606508a76bf9e8b35413ac3c5ac4aa5238e.png" alt="m = k^2"/> and <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> is replaced by <img class="math" src="_images/math/b837f97d8a026150c6c871f14bfad49938b9d0e4.png" alt="-n"/>.</p>
</div>
<div class="section" id="definition-of-carlson-forms">
<h3>Definition of Carlson Forms<a class="headerlink" href="#definition-of-carlson-forms" title="Permalink to this heading">¶</a></h3>
<p id="index-39">The Carlson symmetric forms of elliptical integrals <img class="math" src="_images/math/6be9764fdf259c6f9d784ba95c61d30867a729bc.png" alt="RC(x,y)"/>,
<img class="math" src="_images/math/dad403588c0c2ff83bb19926d0a45da1bf310afb.png" alt="RD(x,y,z)"/>, <img class="math" src="_images/math/6c50c4322be09853ed80c766e4a98889a2697ec8.png" alt="RF(x,y,z)"/> and <img class="math" src="_images/math/4cef971a7519db4fc55306d0d951cab508e89714.png" alt="RJ(x,y,z,p)"/> are defined
by,</p>
<div class="math">
<p><img src="_images/math/faad1a956ba4ce394dd1fb171e843546838b60bb.png" alt="RC(x,y)   &amp;= 1/2 \int_0^\infty dt (t+x)^{-1/2} (t+y)^{-1} \\
RD(x,y,z) &amp;= 3/2 \int_0^\infty dt (t+x)^{-1/2} (t+y)^{-1/2} (t+z)^{-3/2} \\
RF(x,y,z) &amp;= 1/2 \int_0^\infty dt (t+x)^{-1/2} (t+y)^{-1/2} (t+z)^{-1/2} \\
RJ(x,y,z,p) &amp;= 3/2 \int_0^\infty dt (t+x)^{-1/2} (t+y)^{-1/2} (t+z)^{-1/2} (t+p)^{-1}"/></p>
</div></div>
<div class="section" id="legendre-form-of-complete-elliptic-integrals">
<h3>Legendre Form of Complete Elliptic Integrals<a class="headerlink" href="#legendre-form-of-complete-elliptic-integrals" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_Kcomp">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_Kcomp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_Kcomp" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_Kcomp_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_Kcomp_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_Kcomp_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete elliptic integral <img class="math" src="_images/math/d6ee0f4d2896c7cf53fa2359b07c6c0d2687d28c.png" alt="K(k)"/> to
the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_Kcomp_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter <img class="math" src="_images/math/6901b606508a76bf9e8b35413ac3c5ac4aa5238e.png" alt="m = k^2"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_Ecomp">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_Ecomp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_Ecomp" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_Ecomp_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_Ecomp_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_Ecomp_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete elliptic integral <img class="math" src="_images/math/75b369523995e4f8763ef022a7b0f38fcb374c15.png" alt="E(k)"/> to the
accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_Ecomp_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter <img class="math" src="_images/math/6901b606508a76bf9e8b35413ac3c5ac4aa5238e.png" alt="m = k^2"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_Pcomp">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_Pcomp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_Pcomp" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_Pcomp_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_Pcomp_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_Pcomp_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete elliptic integral <img class="math" src="_images/math/f440faed99a2d23a25a1987803e772c24c0e9076.png" alt="\Pi(k,n)"/> to the
accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_Pcomp_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters <img class="math" src="_images/math/6901b606508a76bf9e8b35413ac3c5ac4aa5238e.png" alt="m = k^2"/> and <img class="math" src="_images/math/d4ec188a573d07d97b450506d5b8ea9144cc780d.png" alt="\sin^2(\alpha) = k^2"/>, with the
change of sign <img class="math" src="_images/math/89ce50091117caae24a01c351a58f8d897f39efa.png" alt="n \to -n"/>.</p>
</dd></dl>

</div>
<div class="section" id="legendre-form-of-incomplete-elliptic-integrals">
<h3>Legendre Form of Incomplete Elliptic Integrals<a class="headerlink" href="#legendre-form-of-incomplete-elliptic-integrals" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_F">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_F</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_F" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_F_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_F_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_F_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/ee11fc65a9e71c9ae5ec70964cb8b1b254545486.png" alt="F(\phi,k)"/>
to the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_F_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter <img class="math" src="_images/math/6901b606508a76bf9e8b35413ac3c5ac4aa5238e.png" alt="m = k^2"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_E">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_E</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_E" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_E_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_E_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_E_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/5b21a234b72eb64d5c6e5dd50fee99c0c54018f7.png" alt="E(\phi,k)"/>
to the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_E_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameter <img class="math" src="_images/math/6901b606508a76bf9e8b35413ac3c5ac4aa5238e.png" alt="m = k^2"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_P">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_P</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_P" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_P_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_P_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_P_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/b67092c99156b075567c9eaf532d35ff697ede3f.png" alt="\Pi(\phi,k,n)"/>
to the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_P_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.
Note that Abramowitz &amp; Stegun define this function in terms of the
parameters <img class="math" src="_images/math/6901b606508a76bf9e8b35413ac3c5ac4aa5238e.png" alt="m = k^2"/> and <img class="math" src="_images/math/d4ec188a573d07d97b450506d5b8ea9144cc780d.png" alt="\sin^2(\alpha) = k^2"/>, with the
change of sign <img class="math" src="_images/math/89ce50091117caae24a01c351a58f8d897f39efa.png" alt="n \to -n"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_D">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_D</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_D" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_D_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_D_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_D_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions compute the incomplete elliptic integral
<img class="math" src="_images/math/bbb1b19bffcb30347c39f2e753f47071d928301e.png" alt="D(\phi,k)"/> which is defined through the Carlson form <img class="math" src="_images/math/dad403588c0c2ff83bb19926d0a45da1bf310afb.png" alt="RD(x,y,z)"/>
by the following relation,</p>
<div class="math">
<p><img src="_images/math/516205bb3a70b784458401b10a3a6ed62a774697.png" alt="D(\phi,k) = {1 \over 3} (\sin \phi)^3 RD (1-\sin^2(\phi), 1-k^2 \sin^2(\phi), 1)"/></p>
</div></dd></dl>

</div>
<div class="section" id="carlson-forms">
<h3>Carlson Forms<a class="headerlink" href="#carlson-forms" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RC">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RC</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RC" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RC_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RC_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RC_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/6be9764fdf259c6f9d784ba95c61d30867a729bc.png" alt="RC(x,y)"/>
to the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_RC_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RD">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RD</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RD" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RD_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RD_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RD_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/dad403588c0c2ff83bb19926d0a45da1bf310afb.png" alt="RD(x,y,z)"/>
to the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_RD_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RF">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RF</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RF" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RF_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RF_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RF_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/6c50c4322be09853ed80c766e4a98889a2697ec8.png" alt="RF(x,y,z)"/>
to the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_RF_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RJ">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RJ</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RJ" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_ellint_RJ_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_ellint_RJ_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="#c.gsl_mode_t" title="gsl_mode_t"><span class="n"><span class="pre">gsl_mode_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_ellint_RJ_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete elliptic integral <img class="math" src="_images/math/4cef971a7519db4fc55306d0d951cab508e89714.png" alt="RJ(x,y,z,p)"/>
to the accuracy specified by the mode variable <a class="reference internal" href="#c.gsl_sf_ellint_RJ_e" title="mode"><code class="xref c c-data docutils literal notranslate"><span class="pre">mode</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="elliptic-functions-jacobi">
<h2>Elliptic Functions (Jacobi)<a class="headerlink" href="#elliptic-functions-jacobi" title="Permalink to this heading">¶</a></h2>
<p id="index-40">The Jacobian Elliptic functions are defined in Abramowitz &amp; Stegun,
Chapter 16.  The functions are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_elljac.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_elljac_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_elljac_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sn</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cn</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_elljac_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the Jacobian elliptic functions <img class="math" src="_images/math/fa1037277536a91e154783fddedf87cd61de7280.png" alt="sn(u|m)"/>,
<img class="math" src="_images/math/05c8579c04c448c01e2886feb43e454c9351ef99.png" alt="cn(u|m)"/>, <img class="math" src="_images/math/5afdac3b8dc892007b6aa0be5a23938557711cda.png" alt="dn(u|m)"/> by descending Landen
transformations.</p>
</dd></dl>

</div>
<div class="section" id="error-functions">
<h2>Error Functions<a class="headerlink" href="#error-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-41">The error function is described in Abramowitz &amp; Stegun, Chapter 7.  The
functions in this section are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_erf.h</span></code>.</p>
<div class="section" id="error-function">
<h3>Error Function<a class="headerlink" href="#error-function" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_erf">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erf" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_erf_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erf_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erf_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the error function <img class="math" src="_images/math/b869816d7cc1eeb61150d9e28a0e62b7eeba4bff.png" alt="\erf(x)"/>,
where
<img class="math" src="_images/math/f74bd9235d89b28bad2f9f0c8352a423ffc3a74f.png" alt="\erf(x) = (2/\sqrt{\pi}) \int_0^x dt \exp(-t^2)"/>.</p>
</dd></dl>

</div>
<div class="section" id="complementary-error-function">
<h3>Complementary Error Function<a class="headerlink" href="#complementary-error-function" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_erfc">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erfc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erfc" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_erfc_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erfc_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erfc_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complementary error function
<img class="math" src="_images/math/cd1037be4239e3dfbf8aeba4ba11d7ab56ee467c.png" alt="\erfc(x) = 1 - \erf(x) = (2/\sqrt{\pi}) \int_x^\infty \exp(-t^2)"/></p>
</dd></dl>

</div>
<div class="section" id="log-complementary-error-function">
<h3>Log Complementary Error Function<a class="headerlink" href="#log-complementary-error-function" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_log_erfc">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_erfc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_erfc" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_log_erfc_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_erfc_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_erfc_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the complementary error function
<img class="math" src="_images/math/739c2abebe8f61af720ae1d8d713f5a04aa73710.png" alt="\log(\erfc(x))"/>.</p>
</dd></dl>

</div>
<div class="section" id="probability-functions">
<h3>Probability functions<a class="headerlink" href="#probability-functions" title="Permalink to this heading">¶</a></h3>
<p>The probability functions for the Normal or Gaussian distribution are
described in Abramowitz &amp; Stegun, Section 26.2.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_erf_Z">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erf_Z</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erf_Z" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_erf_Z_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erf_Z_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erf_Z_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Gaussian probability density function
<img class="math" src="_images/math/866b477c1f8010ce459f6a93cc0df1e733d5c679.png" alt="Z(x) = (1/\sqrt{2\pi}) \exp(-x^2/2)"/></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_erf_Q">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erf_Q</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erf_Q" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_erf_Q_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_erf_Q_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_erf_Q_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the upper tail of the Gaussian probability function
<img class="math" src="_images/math/801f42ed5915d0fe91eaa6efdc391738266b758b.png" alt="Q(x) = (1/\sqrt{2\pi}) \int_x^\infty dt \exp(-t^2/2)"/></p>
</dd></dl>

<p id="index-42">The <em>hazard function</em> for the normal distribution,
also known as the inverse Mills’ ratio, is defined as,</p>
<div class="math">
<p><img src="_images/math/186679e79ba2ec31272bed4f0115c035bdffb2bd.png" alt="h(x) = {Z(x) \over Q(x)} = \sqrt{2 \over \pi} {\exp(-x^2 / 2) \over \erfc(x/\sqrt 2)}"/></p>
</div><p>It decreases rapidly as <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> approaches <img class="math" src="_images/math/533634fe24ae42ba33b1d413afbe4a8f8a69370b.png" alt="-\infty"/> and asymptotes
to <img class="math" src="_images/math/9ff3b8d37bacc3e894cd8d35cd6bed4a4364336c.png" alt="h(x) \sim x"/> as <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> approaches <img class="math" src="_images/math/07c4e162ddf3c96166f275403d9613795cf00350.png" alt="+\infty"/>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hazard">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hazard</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hazard" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hazard_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hazard_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hazard_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the hazard function for the normal distribution.</p>
</dd></dl>

</div>
</div>
<div class="section" id="exponential-functions">
<h2>Exponential Functions<a class="headerlink" href="#exponential-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-43">The functions described in this section are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_exp.h</span></code>.</p>
<div class="section" id="exponential-function">
<h3>Exponential Function<a class="headerlink" href="#exponential-function" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_exp_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines provide an exponential function <img class="math" src="_images/math/9098e5bc46053545de293902c203eabb4f010f21.png" alt="\exp(x)"/> using GSL
semantics and error checking.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp_e10_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_e10_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><span class="n"><span class="pre">gsl_sf_result_e10</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_e10_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the exponential <img class="math" src="_images/math/9098e5bc46053545de293902c203eabb4f010f21.png" alt="\exp(x)"/> using the
<a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_sf_result_e10</span></code></a> type to return a result with extended range.
This function may be useful if the value of <img class="math" src="_images/math/9098e5bc46053545de293902c203eabb4f010f21.png" alt="\exp(x)"/> would
overflow the  numeric range of <code class="code docutils literal notranslate"><span class="pre">double</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp_mult">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_mult</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_mult" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_exp_mult_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_mult_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_mult_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines exponentiate <a class="reference internal" href="#c.gsl_sf_exp_mult_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> and multiply by the factor <a class="reference internal" href="#c.gsl_sf_exp_mult_e" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>
to return the product <img class="math" src="_images/math/ca50d09970843c13bc25276d08d6f86f80b9c683.png" alt="y \exp(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp_mult_e10_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_mult_e10_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><span class="n"><span class="pre">gsl_sf_result_e10</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_mult_e10_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the product <img class="math" src="_images/math/ca50d09970843c13bc25276d08d6f86f80b9c683.png" alt="y \exp(x)"/> using the
<a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_sf_result_e10</span></code></a> type to return a result with extended numeric
range.</p>
</dd></dl>

</div>
<div class="section" id="relative-exponential-functions">
<h3>Relative Exponential Functions<a class="headerlink" href="#relative-exponential-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_expm1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expm1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expm1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_expm1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expm1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expm1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the quantity <img class="math" src="_images/math/c0d87caf51504ee542b794a673bb47ae513f8bad.png" alt="\exp(x)-1"/> using an algorithm
that is accurate for small <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exprel">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exprel</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exprel" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_exprel_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exprel_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exprel_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the quantity <img class="math" src="_images/math/af6a8a3cecb53d9243a4e6bbd79d9518c7a12a8c.png" alt="(\exp(x)-1)/x"/> using an
algorithm that is accurate for small <a class="reference internal" href="#c.gsl_sf_exprel_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.  For small <a class="reference internal" href="#c.gsl_sf_exprel_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> the
algorithm is based on the expansion
<img class="math" src="_images/math/e04a1eb5c4cdd5f98c95ce850fbf704801cb94eb.png" alt="(\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \dots"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exprel_2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exprel_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exprel_2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_exprel_2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exprel_2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exprel_2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the quantity <img class="math" src="_images/math/888ed3697ce475d93ff729249aeb98bfdf3da045.png" alt="2(\exp(x)-1-x)/x^2"/> using an
algorithm that is accurate for small <a class="reference internal" href="#c.gsl_sf_exprel_2_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.  For small <a class="reference internal" href="#c.gsl_sf_exprel_2_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> the
algorithm is based on the expansion
<img class="math" src="_images/math/44bfe36ce8a2969a418f6b949f838dfe15106ca9.png" alt="2(\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \dots"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exprel_n">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exprel_n</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exprel_n" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_exprel_n_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exprel_n_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exprel_n_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the <img class="math" src="_images/math/cb5c0921ee22e878437766648c5925b76e462235.png" alt="N"/>-relative exponential, which is the
<a class="reference internal" href="#c.gsl_sf_exprel_n_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>-th generalization of the functions <a class="reference internal" href="#c.gsl_sf_exprel" title="gsl_sf_exprel"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_exprel()</span></code></a> and
<a class="reference internal" href="#c.gsl_sf_exprel_2" title="gsl_sf_exprel_2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_exprel_2()</span></code></a>.  The <img class="math" src="_images/math/cb5c0921ee22e878437766648c5925b76e462235.png" alt="N"/>-relative exponential is given by,</p>
<div class="math">
<p><img src="_images/math/67729d7e39267971e0224730f63cce3f49f049de.png" alt="\hbox{exprel}_N(x)
            &amp;= N!/x^N \left(\exp(x) - \sum_{k=0}^{N-1} x^k/k!\right)\cr
            &amp;= 1 + x/(N+1) + x^2/((N+1)(N+2)) + \dots\cr
            &amp;= {}_1F_1(1,1+N,x)\cr"/></p>
</div></dd></dl>

</div>
<div class="section" id="exponentiation-with-error-estimate">
<h3>Exponentiation With Error Estimate<a class="headerlink" href="#exponentiation-with-error-estimate" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp_err_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_err_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dx</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_err_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function exponentiates <a class="reference internal" href="#c.gsl_sf_exp_err_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> with an associated absolute error
<a class="reference internal" href="#c.gsl_sf_exp_err_e" title="dx"><code class="xref c c-data docutils literal notranslate"><span class="pre">dx</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp_err_e10_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_err_e10_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dx</span></span>, <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><span class="n"><span class="pre">gsl_sf_result_e10</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_err_e10_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function exponentiates a quantity <a class="reference internal" href="#c.gsl_sf_exp_err_e10_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> with an associated absolute
error <a class="reference internal" href="#c.gsl_sf_exp_err_e10_e" title="dx"><code class="xref c c-data docutils literal notranslate"><span class="pre">dx</span></code></a> using the <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_sf_result_e10</span></code></a> type to return a result with
extended range.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp_mult_err_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_mult_err_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dx</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dy</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_mult_err_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the product <img class="math" src="_images/math/ca50d09970843c13bc25276d08d6f86f80b9c683.png" alt="y \exp(x)"/> for the quantities
<a class="reference internal" href="#c.gsl_sf_exp_mult_err_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <a class="reference internal" href="#c.gsl_sf_exp_mult_err_e" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> with associated absolute errors <a class="reference internal" href="#c.gsl_sf_exp_mult_err_e" title="dx"><code class="xref c c-data docutils literal notranslate"><span class="pre">dx</span></code></a>, <a class="reference internal" href="#c.gsl_sf_exp_mult_err_e" title="dy"><code class="xref c c-data docutils literal notranslate"><span class="pre">dy</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_exp_mult_err_e10_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_exp_mult_err_e10_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dx</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dy</span></span>, <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><span class="n"><span class="pre">gsl_sf_result_e10</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_exp_mult_err_e10_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the product <img class="math" src="_images/math/ca50d09970843c13bc25276d08d6f86f80b9c683.png" alt="y \exp(x)"/> for the quantities
<a class="reference internal" href="#c.gsl_sf_exp_mult_err_e10_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <a class="reference internal" href="#c.gsl_sf_exp_mult_err_e10_e" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> with associated absolute errors <a class="reference internal" href="#c.gsl_sf_exp_mult_err_e10_e" title="dx"><code class="xref c c-data docutils literal notranslate"><span class="pre">dx</span></code></a>, <a class="reference internal" href="#c.gsl_sf_exp_mult_err_e10_e" title="dy"><code class="xref c c-data docutils literal notranslate"><span class="pre">dy</span></code></a> using the
<a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_sf_result_e10</span></code></a> type to return a result with extended range.</p>
</dd></dl>

</div>
</div>
<div class="section" id="exponential-integrals">
<h2>Exponential Integrals<a class="headerlink" href="#exponential-integrals" title="Permalink to this heading">¶</a></h2>
<p id="index-44">Information on the exponential integrals can be found in Abramowitz &amp;
Stegun, Chapter 5.  These functions are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_expint.h</span></code>.</p>
<div class="section" id="exponential-integral">
<h3>Exponential Integral<a class="headerlink" href="#exponential-integral" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-45"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_expint_E1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_E1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_E1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_expint_E1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_E1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_E1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the exponential integral <img class="math" src="_images/math/eb513812dfd9a5bb1f69da53f50533596861d917.png" alt="E_1(x)"/>,</p>
<div class="math">
<p><img src="_images/math/adf15213b3af0ca05549bb278e1b5fd8b674baff.png" alt="E_1(x) := \Re \int_1^\infty dt \exp(-xt)/t."/></p>
</div></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_expint_E2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_E2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_E2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_expint_E2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_E2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_E2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the second-order exponential integral <img class="math" src="_images/math/e0086a36a51112b89d59b4e880dfd10ae1a80ce8.png" alt="E_2(x)"/>,</p>
<div class="math">
<p><img src="_images/math/6feed0f1ada4ec50802c40fa5be2b836bb7c7423.png" alt="E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2"/></p>
</div></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_expint_En">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_En</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_En" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_expint_En_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_En_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_En_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the exponential integral <img class="math" src="_images/math/5d0558fc4b6fdff83ec5853043a19bea6500d107.png" alt="E_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_expint_En_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>,</p>
<div class="math">
<p><img src="_images/math/389de138ad4652c076f367c78e2a2fcdb8238030.png" alt="E_n(x) := \Re \int_1^\infty dt \exp(-xt)/t^n."/></p>
</div></dd></dl>

</div>
<div class="section" id="ei-x">
<h3>Ei(x)<a class="headerlink" href="#ei-x" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_expint_Ei">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_Ei</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_Ei" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_expint_Ei_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_Ei_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_Ei_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the exponential integral <img class="math" src="_images/math/5550b50bce646da636bd325b77277d86b9c64e6f.png" alt="Ei(x)"/>,</p>
<div class="math">
<p><img src="_images/math/ac63b6e8a2a0cd1c9a99c418e8cdaa844eb38223.png" alt="\hbox{Ei}(x) = - PV \left( \int_{-x}^\infty dt \exp(-t)/t \right)"/></p>
</div><p>where <img class="math" src="_images/math/78530355a39910c60c071044aebfa3477760ea5d.png" alt="PV"/> denotes the principal value of the integral.</p>
</dd></dl>

</div>
<div class="section" id="hyperbolic-integrals">
<h3>Hyperbolic Integrals<a class="headerlink" href="#hyperbolic-integrals" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-46"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_Shi">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Shi</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Shi" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_Shi_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Shi_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Shi_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the integral</p>
<div class="math">
<p><img src="_images/math/6ddcd74e5c7d8adaa4ffff3636ce1b7ef2f061df.png" alt="\hbox{Shi}(x) = \int_0^x dt \sinh(t)/t"/></p>
</div></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_Chi">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Chi</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Chi" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_Chi_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Chi_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Chi_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the integral</p>
<div class="math">
<p><img src="_images/math/8df3dad937a6dbd0ce68a7b32ea0646a2b1153d1.png" alt="\hbox{Chi}(x) := \Re \left[ \gamma_E + \log(x) + \int_0^x dt (\cosh(t)-1)/t \right]"/></p>
</div><p>where <img class="math" src="_images/math/459c054a2165474c321421765054c859d082df4c.png" alt="\gamma_E"/> is the Euler constant (available as the macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">M_EULER</span></code>).</p>
</dd></dl>

</div>
<div class="section" id="ei-3-x">
<h3>Ei_3(x)<a class="headerlink" href="#ei-3-x" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_expint_3">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_3</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_3" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_expint_3_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_expint_3_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_expint_3_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the third-order exponential integral</p>
<div class="math">
<p><img src="_images/math/37d7736185523f08230ab58370f3b247376811a4.png" alt="{\rm Ei}_3(x) = \int_0^x dt \exp(-t^3)"/></p>
</div><p>for <img class="math" src="_images/math/fb962f1d729e73f74976a1aaa75281e5c1589064.png" alt="x \ge 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="trigonometric-integrals">
<h3>Trigonometric Integrals<a class="headerlink" href="#trigonometric-integrals" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-47"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_Si">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Si</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Si" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_Si_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Si_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Si_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Sine integral</p>
<div class="math">
<p><img src="_images/math/fd95f29f2b824c38e2eeb2affe544ae15a2e1c78.png" alt="\hbox{Si}(x) = \int_0^x dt \sin(t)/t"/></p>
</div></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_Ci">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Ci</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Ci" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_Ci_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_Ci_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_Ci_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Cosine integral</p>
<div class="math">
<p><img src="_images/math/c418f7bafea7e6fe01a9b7e4e61e7bbe3b14b48e.png" alt="\hbox{Ci}(x) = -\int_x^\infty dt \cos(t)/t"/></p>
</div><p>for <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/></p>
</dd></dl>

</div>
<div class="section" id="arctangent-integral">
<h3>Arctangent Integral<a class="headerlink" href="#arctangent-integral" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-48"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_atanint">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_atanint</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_atanint" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_atanint_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_atanint_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_atanint_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Arctangent integral, which is defined as</p>
<div class="math">
<p><img src="_images/math/de77de3f49b40e94985b8561c0ef66742d48ad03.png" alt="\hbox{AtanInt}(x) = \int_0^x dt \arctan(t)/t"/></p>
</div></dd></dl>

</div>
</div>
<div class="section" id="fermi-dirac-function">
<h2>Fermi-Dirac Function<a class="headerlink" href="#fermi-dirac-function" title="Permalink to this heading">¶</a></h2>
<p id="index-49">The functions described in this section are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_fermi_dirac.h</span></code>.</p>
<div class="section" id="complete-fermi-dirac-integrals">
<h3>Complete Fermi-Dirac Integrals<a class="headerlink" href="#complete-fermi-dirac-integrals" title="Permalink to this heading">¶</a></h3>
<p id="index-50">The complete Fermi-Dirac integral <img class="math" src="_images/math/d23d1605a4f108edf529912125058ffaadf44833.png" alt="F_j(x)"/> is given by,</p>
<div class="math">
<p><img src="_images/math/8d3deb28e1b3c338c700133092cd5c977855ff62.png" alt="F_j(x) := {1\over\Gamma(j+1)} \int_0^\infty dt {t^j  \over (\exp(t-x) + 1)}"/></p>
</div><p>Note that the Fermi-Dirac integral is sometimes defined without the
normalisation factor in other texts.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_m1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_m1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_m1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_m1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_m1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_m1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral with an index of <img class="math" src="_images/math/c7bd6c49eb5a777cc2ce2788ac4455cc30ffecb2.png" alt="-1"/>.
This integral is given by
<img class="math" src="_images/math/0c56df38ec9fb14bf74112aac757313bc9eb6004.png" alt="F_{-1}(x) = e^x / (1 + e^x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral with an index of <img class="math" src="_images/math/77bfa83830305fac291e4e73b780e4cc9458b293.png" alt="0"/>.
This integral is given by <img class="math" src="_images/math/b5f3452e3634966f71c164cb68d309cd65e422cc.png" alt="F_0(x) = \ln(1 + e^x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral with an index of <img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/>,
<img class="math" src="_images/math/7232c47b64b1b772c4b01c419b1f4052b295c211.png" alt="F_1(x) = \int_0^\infty dt (t /(\exp(t-x)+1))"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral with an index
of <img class="math" src="_images/math/2a2702de739befc144e6b7371e7f63ac3aeb8bec.png" alt="2"/>,
<img class="math" src="_images/math/6d6219f5c2b52d9ca633ab93c9a70981413d8140.png" alt="F_2(x) = (1/2) \int_0^\infty dt (t^2 /(\exp(t-x)+1))"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral with an integer
index of <img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>,
<img class="math" src="_images/math/ab44e5edc5777460a79d738577d9e51a119a618b.png" alt="F_j(x) = (1/\Gamma(j+1)) \int_0^\infty dt (t^j /(\exp(t-x)+1))"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_mhalf">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_mhalf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_mhalf" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_mhalf_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_mhalf_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_mhalf_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral
<img class="math" src="_images/math/4aa8a1a7fb59826190cea4a29f424f52f3ddf0f8.png" alt="F_{-1/2}(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_half">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_half</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_half" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_half_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_half_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_half_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral
<img class="math" src="_images/math/0f08349c131249533dbd3ecb9e2a3b3d548f33e0.png" alt="F_{1/2}(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_3half">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_3half</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_3half" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_3half_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_3half_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_3half_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complete Fermi-Dirac integral
<img class="math" src="_images/math/fed892f636ec31e5fb1cdb4d2ba753fcf9489432.png" alt="F_{3/2}(x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="incomplete-fermi-dirac-integrals">
<h3>Incomplete Fermi-Dirac Integrals<a class="headerlink" href="#incomplete-fermi-dirac-integrals" title="Permalink to this heading">¶</a></h3>
<p id="index-51">The incomplete Fermi-Dirac integral <img class="math" src="_images/math/6e89511d53f805a6e307ae51ce7347be5412bc8d.png" alt="F_j(x,b)"/> is given by,</p>
<div class="math">
<p><img src="_images/math/c4b31ff4394b1c095112f677ca7fafec18083a46.png" alt="F_j(x,b) := {1\over\Gamma(j+1)} \int_b^\infty dt {t^j  \over (\exp(t-x) + 1)}"/></p>
</div><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_inc_0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_inc_0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_inc_0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fermi_dirac_inc_0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fermi_dirac_inc_0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fermi_dirac_inc_0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the incomplete Fermi-Dirac integral with an index
of zero,
<img class="math" src="_images/math/f8207ec7cd6085ae1d139157a11f8cf2af3dde38.png" alt="F_0(x,b) = \ln(1 + e^{b-x}) - (b-x)"/></p>
</dd></dl>

</div>
</div>
<div class="section" id="gamma-and-beta-functions">
<h2>Gamma and Beta Functions<a class="headerlink" href="#gamma-and-beta-functions" title="Permalink to this heading">¶</a></h2>
<p>The following routines compute the gamma and beta functions in their
full and incomplete forms, as well as various kinds of factorials.
The functions described in this section are declared in the header
file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_gamma.h</span></code>.</p>
<div class="section" id="gamma-functions">
<h3>Gamma Functions<a class="headerlink" href="#gamma-functions" title="Permalink to this heading">¶</a></h3>
<p id="index-52">The Gamma function is defined by the following integral,</p>
<div class="math">
<p><img src="_images/math/4e1b4c01d562c1e1d127730e7d033317089abbc6.png" alt="\Gamma(x) = \int_0^{\infty} dt t^{x-1} \exp(-t)"/></p>
</div><p>It is related to the factorial function by <img class="math" src="_images/math/48191f77d4b8f2cfd740f46141841db42233056f.png" alt="\Gamma(n) = (n-1)!"/>
for positive integer <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>.  Further information on the Gamma function
can be found in Abramowitz &amp; Stegun, Chapter 6.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gamma">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gamma_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Gamma function <img class="math" src="_images/math/9c4cdbbfd3fc11a5f303f03a50feb48665976938.png" alt="\Gamma(x)"/>, subject to <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>
not being a negative integer or zero.  The function is computed using the real
Lanczos method. The maximum value of <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> such that <img class="math" src="_images/math/9c4cdbbfd3fc11a5f303f03a50feb48665976938.png" alt="\Gamma(x)"/> is not
considered an overflow is given by the macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SF_GAMMA_XMAX</span></code>
and is 171.0.</p>
</dd></dl>

<span class="target" id="index-53"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lngamma">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lngamma</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lngamma" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lngamma_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lngamma_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lngamma_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the Gamma function,
<img class="math" src="_images/math/c03c67638e1c7ae6b9a8b2eb9a92b660f9dff433.png" alt="\log(\Gamma(x))"/>, subject to <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> not being a negative
integer or zero.  For <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/> the real part of <img class="math" src="_images/math/c03c67638e1c7ae6b9a8b2eb9a92b660f9dff433.png" alt="\log(\Gamma(x))"/> is
returned, which is equivalent to <img class="math" src="_images/math/bd87b1f2692c5311fbaa8bfa1e9f256e55ee577a.png" alt="\log(|\Gamma(x)|)"/>.  The function
is computed using the real Lanczos method.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lngamma_sgn_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lngamma_sgn_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_lg</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lngamma_sgn_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the sign of the gamma function and the logarithm of
its magnitude, subject to <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> not being a negative integer or zero.  The
function is computed using the real Lanczos method.  The value of the
gamma function and its error can be reconstructed using the relation
<img class="math" src="_images/math/a7925195df2775e95bb7ec64a3e87f6b744f5825.png" alt="\Gamma(x) = sgn * \exp(result\_lg)"/>, taking into account the two
components of <a class="reference internal" href="#c.gsl_sf_lngamma_sgn_e" title="result_lg"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_lg</span></code></a>.</p>
</dd></dl>

<span class="target" id="index-54"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gammastar">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gammastar</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gammastar" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gammastar_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gammastar_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gammastar_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regulated Gamma Function <img class="math" src="_images/math/0e4bba79a5a06985552e535ec92f20fdf0b05d79.png" alt="\Gamma^*(x)"/>
for <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/>. The regulated gamma function is given by,</p>
<div class="math">
<p><img src="_images/math/a9612317ef7e8ec76d3dcbad8935a7bbd0b2b9b7.png" alt="\Gamma^*(x) &amp;= \Gamma(x)/(\sqrt{2\pi} x^{(x-1/2)} \exp(-x))\cr
            &amp;= \left(1 + {1 \over 12x} + ...\right) \quad\hbox{for~} x\to \infty\cr"/></p>
</div><p>and is a useful suggestion of Temme.</p>
</dd></dl>

<span class="target" id="index-55"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gammainv">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gammainv</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gammainv" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gammainv_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gammainv_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gammainv_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the reciprocal of the gamma function,
<img class="math" src="_images/math/c555ff000efa96fade37c6442589fadb451c9873.png" alt="1/\Gamma(x)"/> using the real Lanczos method.</p>
</dd></dl>

<span class="target" id="index-56"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lngamma_complex_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lngamma_complex_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zr</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zi</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lnr</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lngamma_complex_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes <img class="math" src="_images/math/97bcf925abea7b9eac3f830f5ba80b78f5e08460.png" alt="\log(\Gamma(z))"/> for complex <img class="math" src="_images/math/8f79842f7b30ac690d371512a3dbc30e347d1faa.png" alt="z = z_r + i z_i"/>
and <img class="math" src="_images/math/829b663a4308c3e70ecaf2414dd9d6ef233969e3.png" alt="z"/> not a negative integer or zero, using the complex Lanczos
method.  The returned parameters are <img class="math" src="_images/math/28b1bc031231f37c488cce7a80a5c5d7f83088f1.png" alt="lnr = \log|\Gamma(z)|"/> and
<img class="math" src="_images/math/978079314d3223c5f43bc830e2f217785e6c9312.png" alt="arg = \arg(\Gamma(z))"/> in <img class="math" src="_images/math/f5aebcae7457b93a1bdbbaea798fa93f72a31d0d.png" alt="(-\pi,\pi]"/>.  Note that the phase
part (<a class="reference internal" href="#c.gsl_sf_lngamma_complex_e" title="arg"><code class="xref c c-data docutils literal notranslate"><span class="pre">arg</span></code></a>) is not well-determined when <img class="math" src="_images/math/5464c8d264836320dba23e5807e75dcac6acd38c.png" alt="|z|"/> is very large,
due to inevitable roundoff in restricting to <img class="math" src="_images/math/f5aebcae7457b93a1bdbbaea798fa93f72a31d0d.png" alt="(-\pi,\pi]"/>.  This
will result in a <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_ELOSS</span></code> error when it occurs.  The absolute
value part (<a class="reference internal" href="#c.gsl_sf_lngamma_complex_e" title="lnr"><code class="xref c c-data docutils literal notranslate"><span class="pre">lnr</span></code></a>), however, never suffers from loss of precision.</p>
</dd></dl>

</div>
<div class="section" id="factorials">
<h3>Factorials<a class="headerlink" href="#factorials" title="Permalink to this heading">¶</a></h3>
<p id="index-57">Although factorials can be computed from the Gamma function, using
the relation <img class="math" src="_images/math/b29f94e7adc2a0297176f2894c02063129e8fe3e.png" alt="n! = \Gamma(n+1)"/> for non-negative integer <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>,
it is usually more efficient to call the functions in this section,
particularly for small values of <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>, whose factorial values are
maintained in hardcoded tables.</p>
<span class="target" id="index-58"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_fact">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fact</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fact" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_fact_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_fact_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_fact_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the factorial <img class="math" src="_images/math/b5cc964827fe4e6c07229f7ce35ddd02e5955eb2.png" alt="n!"/>.  The factorial is
related to the Gamma function by <img class="math" src="_images/math/b29f94e7adc2a0297176f2894c02063129e8fe3e.png" alt="n! = \Gamma(n+1)"/>.
The maximum value of <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> such that <img class="math" src="_images/math/b5cc964827fe4e6c07229f7ce35ddd02e5955eb2.png" alt="n!"/> is not
considered an overflow is given by the macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SF_FACT_NMAX</span></code>
and is 170.</p>
</dd></dl>

<span class="target" id="index-59"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_doublefact">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_doublefact</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_doublefact" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_doublefact_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_doublefact_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_doublefact_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the double factorial <img class="math" src="_images/math/003d9298260fc4a2379f3749d1890c196e7e7ded.png" alt="n!! = n(n-2)(n-4) \dots"/>.
The maximum value of <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> such that <img class="math" src="_images/math/40229c10a4e6e7d400da8246382084918419f5d5.png" alt="n!!"/> is not
considered an overflow is given by the macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SF_DOUBLEFACT_NMAX</span></code>
and is 297.</p>
</dd></dl>

<span class="target" id="index-60"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lnfact">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnfact</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnfact" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lnfact_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnfact_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnfact_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the factorial of <a class="reference internal" href="#c.gsl_sf_lnfact_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>,
<img class="math" src="_images/math/bfac48bd8f60c996b0e22163eeb50f6669d7baf7.png" alt="\log(n!)"/>.  The algorithm is faster than computing
<img class="math" src="_images/math/e05b0b71f91627d907f4b93bab0bc5e4404be83a.png" alt="\ln(\Gamma(n+1))"/> via <a class="reference internal" href="#c.gsl_sf_lngamma" title="gsl_sf_lngamma"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_lngamma()</span></code></a> for <img class="math" src="_images/math/8fd057a42820c0cabded6a14520d633a9c16f6ff.png" alt="n &lt; 170"/>,
but defers for larger <a class="reference internal" href="#c.gsl_sf_lnfact_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
</dd></dl>

<span class="target" id="index-61"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lndoublefact">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lndoublefact</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lndoublefact" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lndoublefact_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lndoublefact_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lndoublefact_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the double factorial of <a class="reference internal" href="#c.gsl_sf_lndoublefact_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>,
<img class="math" src="_images/math/c58bb59c991ccdd95a4505d04114a8d77a1c43c1.png" alt="\log(n!!)"/>.</p>
</dd></dl>

<span class="target" id="index-62"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_choose">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_choose</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_choose" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_choose_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_choose_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_choose_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the combinatorial factor <code class="code docutils literal notranslate"><span class="pre">n</span> <span class="pre">choose</span> <span class="pre">m</span></code>
<img class="math" src="_images/math/ad5812ae5a6d07006f287caf34403010c34f595d.png" alt="= n!/(m!(n-m)!)"/></p>
</dd></dl>

<span class="target" id="index-63"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lnchoose">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnchoose</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnchoose" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lnchoose_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnchoose_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnchoose_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of <code class="code docutils literal notranslate"><span class="pre">n</span> <span class="pre">choose</span> <span class="pre">m</span></code>.  This is
equivalent to the sum <img class="math" src="_images/math/53f0335435da73fe7d60b5e236d983b6acf82823.png" alt="\log(n!) - \log(m!) - \log((n-m)!)"/>.</p>
</dd></dl>

<span class="target" id="index-64"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_taylorcoeff">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_taylorcoeff</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_taylorcoeff" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_taylorcoeff_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_taylorcoeff_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_taylorcoeff_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Taylor coefficient <img class="math" src="_images/math/db06ab0ca5c72a8784f7b384415dc8eea8181329.png" alt="x^n / n!"/> for
<img class="math" src="_images/math/fb962f1d729e73f74976a1aaa75281e5c1589064.png" alt="x \ge 0"/>, <img class="math" src="_images/math/7e3a223e0034ddc1ec94b09a7e2e36ce1ad2bb40.png" alt="n \ge 0"/></p>
</dd></dl>

</div>
<div class="section" id="pochhammer-symbol">
<span id="id3"></span><h3>Pochhammer Symbol<a class="headerlink" href="#pochhammer-symbol" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-65"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_poch">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_poch</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_poch" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_poch_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_poch_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_poch_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Pochhammer symbol <img class="math" src="_images/math/9ce8a7e40602d58f438a3dadb05922662395969f.png" alt="(a)_x = \Gamma(a + x)/\Gamma(a)"/>.
The Pochhammer symbol is also known as the Apell symbol and
sometimes written as <img class="math" src="_images/math/555eedf41faeff206456506f466f380dc7539447.png" alt="(a,x)"/>.  When <img class="math" src="_images/math/ab8ec5d5a907c2d63aba6be0e2e1abbe131f208c.png" alt="a"/> and <img class="math" src="_images/math/83b06e81a523dba8bab08dd2385424b44f945fdb.png" alt="a + x"/>
are negative integers or zero, the limiting value of the ratio is returned.</p>
</dd></dl>

<span class="target" id="index-66"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lnpoch">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnpoch</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnpoch" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lnpoch_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnpoch_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnpoch_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the Pochhammer symbol,
<img class="math" src="_images/math/e8b34b31be43b15eeac609d11912edfa51677642.png" alt="\log((a)_x) = \log(\Gamma(a + x)/\Gamma(a))"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lnpoch_sgn_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnpoch_sgn_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnpoch_sgn_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the sign of the Pochhammer symbol and the
logarithm of its magnitude.  The computed parameters are <img class="math" src="_images/math/437983c82de962314c560ad3f155a5d62fecb2bb.png" alt="result = \log(|(a)_x|)"/>
with a corresponding error term,  and <img class="math" src="_images/math/96a521f27f7bfead061941325577d0f5c410e2d7.png" alt="sgn = \sgn((a)_x)"/> where <img class="math" src="_images/math/9ce8a7e40602d58f438a3dadb05922662395969f.png" alt="(a)_x = \Gamma(a + x)/\Gamma(a)"/>.</p>
</dd></dl>

<span class="target" id="index-67"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_pochrel">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_pochrel</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_pochrel" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_pochrel_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_pochrel_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_pochrel_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the relative Pochhammer symbol <img class="math" src="_images/math/7f4592158a4cc2890a75a7d9f131fe1c304685cc.png" alt="((a)_x - 1)/x"/>
where <img class="math" src="_images/math/9ce8a7e40602d58f438a3dadb05922662395969f.png" alt="(a)_x = \Gamma(a + x)/\Gamma(a)"/>.</p>
</dd></dl>

</div>
<div class="section" id="incomplete-gamma-functions">
<h3>Incomplete Gamma Functions<a class="headerlink" href="#incomplete-gamma-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-68"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gamma_inc">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma_inc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma_inc" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gamma_inc_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma_inc_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma_inc_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions compute the unnormalized incomplete Gamma Function
<img class="math" src="_images/math/9403ee7e86808799fe384605cbbaea9f337e89e4.png" alt="\Gamma(a,x) = \int_x^\infty dt t^{(a-1)} \exp(-t)"/>
for <img class="math" src="_images/math/ab8ec5d5a907c2d63aba6be0e2e1abbe131f208c.png" alt="a"/> real and <img class="math" src="_images/math/fb962f1d729e73f74976a1aaa75281e5c1589064.png" alt="x \ge 0"/>.</p>
</dd></dl>

<span class="target" id="index-69"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gamma_inc_Q">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma_inc_Q</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma_inc_Q" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gamma_inc_Q_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma_inc_Q_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma_inc_Q_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the normalized incomplete Gamma Function
<img class="math" src="_images/math/99c3083f5e8ee9a5585610653bf18ccf4de233a1.png" alt="Q(a,x) = 1/\Gamma(a) \int_x^\infty dt t^{(a-1)} \exp(-t)"/>
for <img class="math" src="_images/math/3bd0e8e67aa93d0919735c1b64683dc7b1609d96.png" alt="a &gt; 0"/>, <img class="math" src="_images/math/fb962f1d729e73f74976a1aaa75281e5c1589064.png" alt="x \ge 0"/>.</p>
</dd></dl>

<span class="target" id="index-70"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gamma_inc_P">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma_inc_P</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma_inc_P" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gamma_inc_P_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gamma_inc_P_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gamma_inc_P_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the complementary normalized incomplete Gamma Function
<img class="math" src="_images/math/f852fb2c221e267d2c3a7d19d7ff6419c4d60308.png" alt="P(a,x) = 1 - Q(a,x) = 1/\Gamma(a) \int_0^x dt t^{(a-1)} \exp(-t)"/>
for <img class="math" src="_images/math/3bd0e8e67aa93d0919735c1b64683dc7b1609d96.png" alt="a &gt; 0"/>, <img class="math" src="_images/math/fb962f1d729e73f74976a1aaa75281e5c1589064.png" alt="x \ge 0"/>.</p>
<p>Note that Abramowitz &amp; Stegun call <img class="math" src="_images/math/4fdd7c104d7c8380a24d91065f7cbf19749a20fd.png" alt="P(a,x)"/> the incomplete gamma
function (section 6.5).</p>
</dd></dl>

</div>
<div class="section" id="beta-functions">
<h3>Beta Functions<a class="headerlink" href="#beta-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-71"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_beta">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_beta</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_beta" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_beta_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_beta_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_beta_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Beta Function, <img class="math" src="_images/math/f533af28cfe87cd8b85747c91151b3f9d264c9e6.png" alt="B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b)"/>
subject to <img class="math" src="_images/math/ab8ec5d5a907c2d63aba6be0e2e1abbe131f208c.png" alt="a"/> and <img class="math" src="_images/math/b9e7a11d6c55d13df40be0f0e33a142fd09d27af.png" alt="b"/> not being negative integers.</p>
</dd></dl>

<span class="target" id="index-72"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lnbeta">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnbeta</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnbeta" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lnbeta_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnbeta_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnbeta_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the Beta Function, <img class="math" src="_images/math/f4bb81cd3f3a396c621b5fa9af511ed41c57fdd2.png" alt="\log(B(a,b))"/>
subject to <img class="math" src="_images/math/ab8ec5d5a907c2d63aba6be0e2e1abbe131f208c.png" alt="a"/> and <img class="math" src="_images/math/b9e7a11d6c55d13df40be0f0e33a142fd09d27af.png" alt="b"/> not being negative integers.</p>
</dd></dl>

</div>
<div class="section" id="incomplete-beta-function">
<h3>Incomplete Beta Function<a class="headerlink" href="#incomplete-beta-function" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-73"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_beta_inc">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_beta_inc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_beta_inc" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_beta_inc_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_beta_inc_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_beta_inc_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the normalized incomplete Beta function
<img class="math" src="_images/math/c33648314aa92aedd6858f73b3fdf725d6aeffe0.png" alt="I_x(a,b) = B_x(a,b) / B(a,b)"/> where</p>
<div class="math">
<p><img src="_images/math/ede51848bd659c6cc441a769c05a4b98508ffb22.png" alt="B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt"/></p>
</div><p>for <img class="math" src="_images/math/1fcde2d4bb4a8586b8278165d07e1847d218b015.png" alt="0 \le x \le 1"/>.
For <img class="math" src="_images/math/3bd0e8e67aa93d0919735c1b64683dc7b1609d96.png" alt="a &gt; 0"/>, <img class="math" src="_images/math/fc7f7289b736a519dba9a9ea79bc5be18267634e.png" alt="b &gt; 0"/> the value is computed using
a continued fraction expansion.  For all other values it is computed using
the relation</p>
<div class="math">
<p><img src="_images/math/16a3a5ec806ce6b9685e2726706a28009839e2ed.png" alt="I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b)"/></p>
</div></dd></dl>

</div>
</div>
<div class="section" id="gegenbauer-functions">
<h2>Gegenbauer Functions<a class="headerlink" href="#gegenbauer-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-74">The Gegenbauer polynomials are defined in Abramowitz &amp; Stegun, Chapter
22, where they are known as Ultraspherical polynomials.  The functions
described in this section are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_gegenbauer.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_3">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_3</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_3" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_2_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_3_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_3_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_3_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions evaluate the Gegenbauer polynomials
<img class="math" src="_images/math/dae88d349c044f034a296db4cd4a801ad16f4f30.png" alt="C^{(\lambda)}_n(x)"/> using explicit
representations for <img class="math" src="_images/math/22181a81eb145ed016b1cbe7beaacc4c969739b5.png" alt="n = 1, 2, 3"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_n">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_n</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_n" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_n_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_n_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_n_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions evaluate the Gegenbauer polynomial <img class="math" src="_images/math/dae88d349c044f034a296db4cd4a801ad16f4f30.png" alt="C^{(\lambda)}_n(x)"/>
for a specific value of <a class="reference internal" href="#c.gsl_sf_gegenpoly_n_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>,
<a class="reference internal" href="#c.gsl_sf_gegenpoly_n_e" title="lambda"><code class="xref c c-data docutils literal notranslate"><span class="pre">lambda</span></code></a>, <a class="reference internal" href="#c.gsl_sf_gegenpoly_n_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> subject to <img class="math" src="_images/math/12a89a87b7a8c6bcf1b9f1f0419a84a88bd49911.png" alt="\lambda &gt; -1/2"/>, <img class="math" src="_images/math/7e3a223e0034ddc1ec94b09a7e2e36ce1ad2bb40.png" alt="n \ge 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_gegenpoly_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_gegenpoly_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_gegenpoly_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes an array of Gegenbauer polynomials
<img class="math" src="_images/math/dae88d349c044f034a296db4cd4a801ad16f4f30.png" alt="C^{(\lambda)}_n(x)"/>
for <img class="math" src="_images/math/20b3075d470b17bd2764331bdc037cdb017c00e7.png" alt="n = 0, 1, 2, \dots, nmax"/>, subject
to <img class="math" src="_images/math/12a89a87b7a8c6bcf1b9f1f0419a84a88bd49911.png" alt="\lambda &gt; -1/2"/>, <img class="math" src="_images/math/485a39f710f5a868e90949d6ccc828e580bed982.png" alt="nmax \ge 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="hermite-polynomials-and-functions">
<h2>Hermite Polynomials and Functions<a class="headerlink" href="#hermite-polynomials-and-functions" title="Permalink to this heading">¶</a></h2>
<p>Hermite polynomials and functions are discussed in Abramowitz &amp; Stegun, Chapter 22 and
Szego, Gabor (1939, 1958, 1967), Orthogonal Polynomials, American Mathematical Society.
The Hermite polynomials and functions are defined in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_hermite.h</span></code>.</p>
<div class="section" id="hermite-polynomials">
<span id="index-75"></span><h3>Hermite Polynomials<a class="headerlink" href="#hermite-polynomials" title="Permalink to this heading">¶</a></h3>
<p>The Hermite polynomials exist in two variants: the physicist version
<img class="math" src="_images/math/db45e5217adacf15214a9cbcb5bf7046952066e9.png" alt="H_n(x)"/> and the probabilist version <img class="math" src="_images/math/89592c34b4197838709283f1689f585f341d1e01.png" alt="He_n(x)"/>.
They are defined by the derivatives</p>
<div class="math">
<p><img src="_images/math/d4106a7cafee4ce6a1bb2cb875adf6b9b5aa0378.png" alt="H_n(x) &amp; = (-1)^n e^{x^2} \left({d \over dx}\right)^n e^{-x^2} \\
He_n(x) &amp; = (-1)^n e^{x^2/2} \left({d \over dx}\right)^n e^{-x^2/2}"/></p>
</div><p>They are connected via</p>
<div class="math">
<p><img src="_images/math/1564dd3aec24f1ff05cbe84bb3763e3e7fa6148a.png" alt="H_n(x) &amp; = 2^{n/2} He_n \left( \sqrt{2} x \right) \\
He_n(x) &amp; = 2^{-n/2} H_n \left( {x \over \sqrt{2}} \right)"/></p>
</div><p>and satisfy the ordinary differential equations</p>
<div class="math">
<p><img src="_images/math/2fc272fd3e77237f8caf231cc68aaa6a45b759ab.png" alt="H_n^{\prime\prime}(x) - 2x H_n^{\prime}(x) + 2n H_n(x) &amp; = 0 \\
He_n^{\prime\prime}(x) - x He_n^{\prime}(x) + n He_n(x) &amp; = 0"/></p>
</div><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the physicist Hermite polynomial <img class="math" src="_images/math/db45e5217adacf15214a9cbcb5bf7046952066e9.png" alt="H_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
If an overflow is detected, <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EOVRFLW</span></code> is returned without calling the error handler.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine evaluates all physicist Hermite polynomials <img class="math" src="_images/math/dbcc9dd864c7ea4f3f9d3b153ff181d9a23a4c56.png" alt="H_n"/> up to order <a class="reference internal" href="#c.gsl_sf_hermite_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_array" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
The results are stored in <a class="reference internal" href="#c.gsl_sf_hermite_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_series">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_series</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_series" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_series_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_series_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_series_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the series <img class="math" src="_images/math/50c7e3ffeb6725061be765058c2f4e12f282acd7.png" alt="\sum_{j=0}^n a_j H_j(x)"/> with <img class="math" src="_images/math/8a1698b7d2bfedb136ba42f09017fc81433e4a7d.png" alt="H_j"/> being
the <img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>-th physicist Hermite polynomial using the Clenshaw algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the probabilist Hermite polynomial <img class="math" src="_images/math/89592c34b4197838709283f1689f585f341d1e01.png" alt="He_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_prob_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_prob_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
If an overflow is detected, <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EOVRFLW</span></code> is returned without calling the error handler.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine evaluates all probabilist Hermite polynomials <img class="math" src="_images/math/89592c34b4197838709283f1689f585f341d1e01.png" alt="He_n(x)"/> up to order <a class="reference internal" href="#c.gsl_sf_hermite_prob_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_prob_array" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
The results are stored in <a class="reference internal" href="#c.gsl_sf_hermite_prob_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_series">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_series</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_series" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_series_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_series_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_series_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the series <img class="math" src="_images/math/671291165f67b76365b0b4b4594a385bb22b5776.png" alt="\sum_{j=0}^n a_j He_j(x)"/> with <img class="math" src="_images/math/1ff83d0db1601395fb72cf3a28f0f600feccdb6c.png" alt="He_j"/> being the
<img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>-th probabilist Hermite polynomial using the Clenshaw algorithm.</p>
</dd></dl>

</div>
<div class="section" id="derivatives-of-hermite-polynomials">
<h3>Derivatives of Hermite Polynomials<a class="headerlink" href="#derivatives-of-hermite-polynomials" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-76"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_deriv">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_deriv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_deriv_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_deriv_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_deriv_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the <a class="reference internal" href="#c.gsl_sf_hermite_deriv_e" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>-th derivative of the physicist Hermite polynomial <img class="math" src="_images/math/db45e5217adacf15214a9cbcb5bf7046952066e9.png" alt="H_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_deriv_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>
at position <a class="reference internal" href="#c.gsl_sf_hermite_deriv_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_array_deriv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_array_deriv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_array_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine evaluates the <a class="reference internal" href="#c.gsl_sf_hermite_array_deriv" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>-th derivative of all physicist Hermite polynomials <img class="math" src="_images/math/db45e5217adacf15214a9cbcb5bf7046952066e9.png" alt="H_n(x)"/> from
orders <img class="math" src="_images/math/0f903f52ef02b1f3ec89912295b2cecae88f9a76.png" alt="0, \dots, \text{nmax}"/> at position <a class="reference internal" href="#c.gsl_sf_hermite_array_deriv" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
The result <img class="math" src="_images/math/2096ff05104913acbf67b5e5827e55bd99af8778.png" alt="d^m/dx^m H_n(x)"/> is stored in <code class="code docutils literal notranslate"><span class="pre">result_array[n]</span></code>. The output
<a class="reference internal" href="#c.gsl_sf_hermite_array_deriv" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a> must have length at least <code class="code docutils literal notranslate"><span class="pre">nmax</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_deriv_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_deriv_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_deriv_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine evaluates all derivative orders from <img class="math" src="_images/math/6429ef9de1ef5b2fd12baeec2625b8fe5731ed76.png" alt="0, \dots, \text{mmax}"/> of the
physicist Hermite polynomial of order <a class="reference internal" href="#c.gsl_sf_hermite_deriv_array" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/dbcc9dd864c7ea4f3f9d3b153ff181d9a23a4c56.png" alt="H_n"/>, at position <a class="reference internal" href="#c.gsl_sf_hermite_deriv_array" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
The result <img class="math" src="_images/math/2096ff05104913acbf67b5e5827e55bd99af8778.png" alt="d^m/dx^m H_n(x)"/> is stored in <code class="code docutils literal notranslate"><span class="pre">result_array[m]</span></code>. The output
<a class="reference internal" href="#c.gsl_sf_hermite_deriv_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a> must have length at least <code class="code docutils literal notranslate"><span class="pre">mmax</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_deriv">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_deriv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_deriv_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_deriv_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_deriv_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the <a class="reference internal" href="#c.gsl_sf_hermite_prob_deriv_e" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>-th derivative of the probabilist Hermite polynomial <img class="math" src="_images/math/89592c34b4197838709283f1689f585f341d1e01.png" alt="He_n(x)"/>
of order <a class="reference internal" href="#c.gsl_sf_hermite_prob_deriv_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_prob_deriv_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_array_deriv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_array_deriv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_array_deriv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine evaluates the <a class="reference internal" href="#c.gsl_sf_hermite_prob_array_deriv" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>-th derivative of all probabilist Hermite polynomials <img class="math" src="_images/math/89592c34b4197838709283f1689f585f341d1e01.png" alt="He_n(x)"/> from
orders <img class="math" src="_images/math/0f903f52ef02b1f3ec89912295b2cecae88f9a76.png" alt="0, \dots, \text{nmax}"/> at position <a class="reference internal" href="#c.gsl_sf_hermite_prob_array_deriv" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
The result <img class="math" src="_images/math/d0c6fc9e71c09878fbac6390d3057e5c8287e901.png" alt="d^m/dx^m He_n(x)"/> is stored in <code class="code docutils literal notranslate"><span class="pre">result_array[n]</span></code>. The output
<a class="reference internal" href="#c.gsl_sf_hermite_prob_array_deriv" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a> must have length at least <code class="code docutils literal notranslate"><span class="pre">nmax</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_deriv_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_deriv_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_deriv_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine evaluates all derivative orders from <img class="math" src="_images/math/6429ef9de1ef5b2fd12baeec2625b8fe5731ed76.png" alt="0, \dots, \text{mmax}"/> of the
probabilist Hermite polynomial of order <a class="reference internal" href="#c.gsl_sf_hermite_prob_deriv_array" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>, <img class="math" src="_images/math/5fdaa5cac2a0222b3fbc992b144425aa40f82b7e.png" alt="He_n"/>, at position <a class="reference internal" href="#c.gsl_sf_hermite_prob_deriv_array" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.
The result <img class="math" src="_images/math/d0c6fc9e71c09878fbac6390d3057e5c8287e901.png" alt="d^m/dx^m He_n(x)"/> is stored in <code class="code docutils literal notranslate"><span class="pre">result_array[m]</span></code>. The output
<a class="reference internal" href="#c.gsl_sf_hermite_prob_deriv_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a> must have length at least <code class="code docutils literal notranslate"><span class="pre">mmax</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="hermite-functions">
<span id="index-77"></span><h3>Hermite Functions<a class="headerlink" href="#hermite-functions" title="Permalink to this heading">¶</a></h3>
<p>The Hermite functions are defined by</p>
<div class="math">
<p><img src="_images/math/f21c56889dc9b03b5bee0a36276fb78eda7217cd.png" alt="\psi_n(x) = \left( 2^n n! \sqrt{\pi} \right)^{-1/2} e^{-x^2/2} H_n \left( x \right)"/></p>
</div><p>and satisfy the Schrödinger equation for a quantum mechanical harmonic oscillator</p>
<div class="math">
<p><img src="_images/math/1ac895766afe4ad80f35f1ec6a8e354e623ae20b.png" alt="\psi_n^{\prime\prime}(x) + (2n + 1 - x^2) \psi_n(x) = 0"/></p>
</div><p>They are orthonormal,</p>
<div class="math">
<p><img src="_images/math/ec25e5c94a8cbb025659dbe7d7a63ad0097163eb.png" alt="\int_{-\infty}^{\infty} \psi_m(x) \psi_n(x) dx = \delta_{mn}"/></p>
</div><p>and form an orthonormal basis of <img class="math" src="_images/math/2f9f1149a53fe8e5f19b815f46193bb650aba6ec.png" alt="L^2(\mathbb{R})"/>. The Hermite functions
are also eigenfunctions of the continuous Fourier transform. GSL offers two
methods for evaluating the Hermite functions. The first uses the standard three-term
recurrence relation which has <img class="math" src="_images/math/8c9c88e7ccbfc1a8524f9121fb555eb486beb2ea.png" alt="O(n)"/> complexity and is the most accurate. The
second uses a Cauchy integral approach due to Bunck (2009) which has <img class="math" src="_images/math/2fa7e18fcd16ba8e04fb0b183bcfb43456c447c8.png" alt="O(\sqrt{n})"/>
complexity which represents a significant speed improvement for large <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>, although
it is slightly less accurate.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the Hermite function <img class="math" src="_images/math/3618342fa64afa9d29f52913ecdad309680221fe.png" alt="\psi_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_func_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_func_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>
using a three term recurrence relation. The algorithm complexity is <img class="math" src="_images/math/8c9c88e7ccbfc1a8524f9121fb555eb486beb2ea.png" alt="O(n)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_fast">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_fast</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_fast" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_fast_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_fast_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_fast_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the Hermite function <img class="math" src="_images/math/3618342fa64afa9d29f52913ecdad309680221fe.png" alt="\psi_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_func_fast_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_func_fast_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>
using a the Cauchy integral algorithm due to Bunck, 2009. The algorithm complexity is <img class="math" src="_images/math/2fa7e18fcd16ba8e04fb0b183bcfb43456c447c8.png" alt="O(\sqrt{n})"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result_array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine evaluates all Hermite functions <img class="math" src="_images/math/3618342fa64afa9d29f52913ecdad309680221fe.png" alt="\psi_n(x)"/> for orders <img class="math" src="_images/math/a5328c32d76979af2e176c76172030a5acb20cfc.png" alt="n = 0, \dots, \textrm{nmax}"/>
at position <a class="reference internal" href="#c.gsl_sf_hermite_func_array" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, using the recurrence relation algorithm. The results are stored in
<a class="reference internal" href="#c.gsl_sf_hermite_func_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a> which has length at least <code class="code docutils literal notranslate"><span class="pre">nmax</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_series">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_series</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_series" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_series_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_series_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_series_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the series <img class="math" src="_images/math/8ecba9ec4afbfc28b82a0b4168f02d2f5d2944e1.png" alt="\sum_{j=0}^n a_j \psi_j(x)"/> with <img class="math" src="_images/math/8b91562ee58bad5ba68356d0545170a860f8e2e0.png" alt="\psi_j"/> being
the <img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>-th Hermite function using the Clenshaw algorithm.</p>
</dd></dl>

</div>
<div class="section" id="derivatives-of-hermite-functions">
<h3>Derivatives of Hermite Functions<a class="headerlink" href="#derivatives-of-hermite-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-78"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_der">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_der</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_der" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_der_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_der_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_der_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the <a class="reference internal" href="#c.gsl_sf_hermite_func_der_e" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>-th derivative of the Hermite function <img class="math" src="_images/math/3618342fa64afa9d29f52913ecdad309680221fe.png" alt="\psi_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_func_der_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> at position <a class="reference internal" href="#c.gsl_sf_hermite_func_der_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="zeros-of-hermite-polynomials-and-hermite-functions">
<h3>Zeros of Hermite Polynomials and Hermite Functions<a class="headerlink" href="#zeros-of-hermite-polynomials-and-hermite-functions" title="Permalink to this heading">¶</a></h3>
<p id="index-79">These routines calculate the <img class="math" src="_images/math/00a0fb0ee72dd3b299c67c64d624f2cc01335d59.png" alt="s"/>-th zero of the Hermite polynomial/function of order
<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>. Since the zeros are symmetrical around zero, only positive zeros are calculated,
ordered from smallest to largest, starting from index 1. Only for odd polynomial orders a
zeroth zero exists, its value always being zero.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_zero">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_zero" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_zero_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_zero_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_zero_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the <a class="reference internal" href="#c.gsl_sf_hermite_zero_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th zero of the physicist Hermite polynomial <img class="math" src="_images/math/db45e5217adacf15214a9cbcb5bf7046952066e9.png" alt="H_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_zero_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_zero">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_zero" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_prob_zero_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_prob_zero_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_prob_zero_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the <a class="reference internal" href="#c.gsl_sf_hermite_prob_zero_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th zero of the probabilist Hermite polynomial <img class="math" src="_images/math/89592c34b4197838709283f1689f585f341d1e01.png" alt="He_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_prob_zero_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_zero">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_zero" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hermite_func_zero_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hermite_func_zero_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hermite_func_zero_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the <a class="reference internal" href="#c.gsl_sf_hermite_func_zero_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>-th zero of the Hermite function <img class="math" src="_images/math/3618342fa64afa9d29f52913ecdad309680221fe.png" alt="\psi_n(x)"/> of order <a class="reference internal" href="#c.gsl_sf_hermite_func_zero_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="hypergeometric-functions">
<h2>Hypergeometric Functions<a class="headerlink" href="#hypergeometric-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-80">Hypergeometric functions are described in Abramowitz &amp; Stegun, Chapters
13 and 15.  These functions are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_hyperg.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_0F1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_0F1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_0F1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_0F1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_0F1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_0F1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the hypergeometric function</p>
<div class="math">
<p><img src="_images/math/5a355b5f555f0d15ed8f9367ce71894299172f37.png" alt="{}_0F_1(c,x)"/></p>
</div></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_1F1_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_1F1_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_1F1_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_1F1_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_1F1_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_1F1_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the confluent hypergeometric function</p>
<div class="math">
<p><img src="_images/math/59ec69a0f96264fb2fbff9818c9f9bd7eea6cf44.png" alt="{}_1F_1(m,n,x) = M(m,n,x)"/></p>
</div><p>for integer parameters <a class="reference internal" href="#c.gsl_sf_hyperg_1F1_int_e" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>, <a class="reference internal" href="#c.gsl_sf_hyperg_1F1_int_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_1F1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_1F1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_1F1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_1F1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_1F1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_1F1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the confluent hypergeometric function</p>
<div class="math">
<p><img src="_images/math/97578ef8a12ce2c804cda8cc1b2811bead605947.png" alt="{}_1F_1(a,b,x) = M(a,b,x)"/></p>
</div><p>for general parameters <a class="reference internal" href="#c.gsl_sf_hyperg_1F1_e" title="a"><code class="xref c c-data docutils literal notranslate"><span class="pre">a</span></code></a>, <a class="reference internal" href="#c.gsl_sf_hyperg_1F1_e" title="b"><code class="xref c c-data docutils literal notranslate"><span class="pre">b</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_U_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_U_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_U_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_U_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_U_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_U_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the confluent hypergeometric function
<img class="math" src="_images/math/ed8293509eccf475b20c699ad3683f01566096d5.png" alt="U(m,n,x)"/> for integer parameters <a class="reference internal" href="#c.gsl_sf_hyperg_U_int_e" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>, <a class="reference internal" href="#c.gsl_sf_hyperg_U_int_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_U_int_e10_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_U_int_e10_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><span class="n"><span class="pre">gsl_sf_result_e10</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_U_int_e10_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the confluent hypergeometric function
<img class="math" src="_images/math/ed8293509eccf475b20c699ad3683f01566096d5.png" alt="U(m,n,x)"/> for integer parameters <a class="reference internal" href="#c.gsl_sf_hyperg_U_int_e10_e" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>, <a class="reference internal" href="#c.gsl_sf_hyperg_U_int_e10_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> using the
<a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_sf_result_e10</span></code></a> type to return a result with extended range.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_U">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_U</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_U" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_U_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_U_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_U_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the confluent hypergeometric function <img class="math" src="_images/math/585dde715465283a7b32f4ba83c00b187db2d47b.png" alt="U(a,b,x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_U_e10_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_U_e10_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><span class="n"><span class="pre">gsl_sf_result_e10</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_U_e10_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the confluent hypergeometric function
<img class="math" src="_images/math/585dde715465283a7b32f4ba83c00b187db2d47b.png" alt="U(a,b,x)"/> using the <a class="reference internal" href="#c.gsl_sf_result_e10" title="gsl_sf_result_e10"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_sf_result_e10</span></code></a> type to return a
result with extended range.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Gauss hypergeometric function</p>
<div class="math">
<p><img src="_images/math/6058dd5bc9c9ba6be8264f8ca13b7bd22398cda1.png" alt="{}_2F_1(a,b,c,x) = F(a,b,c,x)"/></p>
</div><p>for <img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>. If the arguments <img class="math" src="_images/math/c7f6464466d8af52446bc5fac4823a1194ec894d.png" alt="(a,b,c,x)"/> are too close to a singularity then
the function can return the error code <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EMAXITER</span></code> when the
series approximation converges too slowly.  This occurs in the region of
<img class="math" src="_images/math/4b4be4374fbe219b86ded4d335b151b27c8400c0.png" alt="x = 1"/>, <img class="math" src="_images/math/d5165ba5bb6d19c25304a80d12340d13e6ed61d9.png" alt="c - a - b = m"/> for integer m.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1_conj">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1_conj</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aR</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aI</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1_conj" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1_conj_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1_conj_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aR</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aI</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1_conj_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Gauss hypergeometric function</p>
<div class="math">
<p><img src="_images/math/ca20646abee31a19018cabd334dc58e0658dbbb7.png" alt="{}_2F_1(a_R + i a_I, aR - i aI, c, x)"/></p>
</div><p>with complex parameters for <img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1_renorm">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1_renorm</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1_renorm" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1_renorm_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1_renorm_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1_renorm_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the renormalized Gauss hypergeometric function</p>
<div class="math">
<p><img src="_images/math/262db00c7fc195aabf3072090e8f150087d6c689.png" alt="{}_2F_1(a,b,c,x) / \Gamma(c)"/></p>
</div><p>for <img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1_conj_renorm">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1_conj_renorm</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aR</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aI</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1_conj_renorm" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F1_conj_renorm_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F1_conj_renorm_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aR</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">aI</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F1_conj_renorm_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the renormalized Gauss hypergeometric function</p>
<div class="math">
<p><img src="_images/math/35e0e2654baa8be95abc5db4d776f9e08420a11b.png" alt="{}_2F_1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c)"/></p>
</div><p>for <img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hyperg_2F0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hyperg_2F0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hyperg_2F0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the hypergeometric function</p>
<div class="math">
<p><img src="_images/math/96cab06f43d8e9f14c2392f385c9683b904b7ec2.png" alt="{}_2F_0(a,b,x)"/></p>
</div><p>The series representation is a divergent hypergeometric series.
However, for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/> we have</p>
<div class="math">
<p><img src="_images/math/b1b24163f205b6511e53c5d9fc3e5a00ea5d4d4b.png" alt="{}_2F_0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)"/></p>
</div></dd></dl>

</div>
<div class="section" id="laguerre-functions">
<span id="id4"></span><h2>Laguerre Functions<a class="headerlink" href="#laguerre-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-81">The generalized Laguerre polynomials, sometimes referred to as
associated Laguerre polynomials, are defined in terms of confluent
hypergeometric functions as</p>
<div class="math">
<p><img src="_images/math/3578ed5b79db8ab004a27b4960681c7ebf34b01a.png" alt="L^a_n(x) = {(a+1)_n \over n!} {}_1F_1(-n,a+1,x)"/></p>
</div><p>where <img class="math" src="_images/math/d5aa6f8eeef6bb28e6f4cbfbffa239186c425a36.png" alt="(a)_n"/> is the <a class="reference internal" href="#pochhammer-symbol"><span class="std std-ref">Pochhammer symbol</span></a> (rising factorial).
They are related to the plain
Laguerre polynomials <img class="math" src="_images/math/b09509ef7385b92be6a1e27dd09f62cc313c7a4a.png" alt="L_n(x)"/> by <img class="math" src="_images/math/8508e8140519cb1766af960fb58b749e28af072c.png" alt="L^0_n(x) = L_n(x)"/> and
<img class="math" src="_images/math/571f30607886f3010dc8e8b69e9802be2dc04501.png" alt="L^k_n(x) = (-1)^k (d^k/dx^k) L_{(n+k)}(x)"/>
For more information see Abramowitz &amp; Stegun, Chapter 22.</p>
<p>The functions described in this section are
declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_laguerre.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_3">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_3</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_3" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_2_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_3_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_3_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_3_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the generalized Laguerre polynomials
<img class="math" src="_images/math/719132ee85f4e749a2d4a1f53c0adf0e2351b560.png" alt="L^a_1(x)"/>, <img class="math" src="_images/math/e995fe2d6cbe9a5db28758258410afc58c1a3429.png" alt="L^a_2(x)"/>, <img class="math" src="_images/math/41d0e92022e8a74a45bcf025efb0f76fd06eb73c.png" alt="L^a_3(x)"/> using explicit
representations.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_n">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_n</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_n" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_laguerre_n_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_laguerre_n_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_laguerre_n_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines evaluate the generalized Laguerre polynomials
<img class="math" src="_images/math/156060cedd2348f1283349e054877625f49b565a.png" alt="L^a_n(x)"/> for <img class="math" src="_images/math/489ef719a7e78f7f876f49a4e9f53f88d1116901.png" alt="a &gt; -1"/>,
<img class="math" src="_images/math/7e3a223e0034ddc1ec94b09a7e2e36ce1ad2bb40.png" alt="n \ge 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="lambert-w-functions">
<h2>Lambert W Functions<a class="headerlink" href="#lambert-w-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-82">Lambert’s W functions, <img class="math" src="_images/math/6cccfb1989312a513285581db40681737bfd49eb.png" alt="W(x)"/>, are defined to be solutions
of the equation <img class="math" src="_images/math/562df79175d2c754490e1ad5ded35d6273a576b3.png" alt="W(x) \exp(W(x)) = x"/>. This function has
multiple branches for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/>; however, it has only
two real-valued branches. We define <img class="math" src="_images/math/fdf6e671b1121ac2e3f4cfea87780a59083f3154.png" alt="W_0(x)"/> to be the
principal branch, where <img class="math" src="_images/math/a634f222c6f886ad477f6de7d3a29c08437955d5.png" alt="W &gt; -1"/> for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/>, and
<img class="math" src="_images/math/9a9b11eff47c14a4ea82340d7f3664ec84ebd0b7.png" alt="W_{-1}(x)"/>
to be the other real branch, where
<img class="math" src="_images/math/170549212b7a16a1d96b6729bb6780a4202775aa.png" alt="W &lt; -1"/> for <img class="math" src="_images/math/d3f85f15daab5226a74cd1a9a3f9419ec82ee181.png" alt="x &lt; 0"/>.  The Lambert functions are
declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_lambert.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lambert_W0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lambert_W0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lambert_W0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lambert_W0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lambert_W0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lambert_W0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These compute the principal branch of the Lambert W function, <img class="math" src="_images/math/fdf6e671b1121ac2e3f4cfea87780a59083f3154.png" alt="W_0(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lambert_Wm1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lambert_Wm1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lambert_Wm1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lambert_Wm1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lambert_Wm1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lambert_Wm1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These compute the secondary real-valued branch of the Lambert W function,
<img class="math" src="_images/math/9a9b11eff47c14a4ea82340d7f3664ec84ebd0b7.png" alt="W_{-1}(x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="legendre-functions-and-spherical-harmonics">
<h2>Legendre Functions and Spherical Harmonics<a class="headerlink" href="#legendre-functions-and-spherical-harmonics" title="Permalink to this heading">¶</a></h2>
<p id="index-83">The Legendre Functions and Legendre Polynomials are described in
Abramowitz &amp; Stegun, Chapter 8.  These functions are declared in
the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_legendre.h</span></code>.</p>
<div class="section" id="legendre-polynomials">
<h3>Legendre Polynomials<a class="headerlink" href="#legendre-polynomials" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_P1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_P1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_P1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_P2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_P2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_P2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_P3">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_P3</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_P3" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_P1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_P1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_P1_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_P2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_P2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_P2_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_P3_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_P3_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_P3_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions evaluate the Legendre polynomials
<img class="math" src="_images/math/bbc20289cd7e1c1f9a03b493f131519840f111a0.png" alt="P_l(x)"/> using explicit representations for <img class="math" src="_images/math/ec9142123d0a568c571a2fe0993cc983a40c685a.png" alt="l = 1, 2, 3"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Pl">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Pl</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Pl" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Pl_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Pl_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Pl_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions evaluate the Legendre polynomial <img class="math" src="_images/math/bbc20289cd7e1c1f9a03b493f131519840f111a0.png" alt="P_l(x)"/>
for a specific value of <a class="reference internal" href="#c.gsl_sf_legendre_Pl_e" title="l"><code class="xref c c-data docutils literal notranslate"><span class="pre">l</span></code></a>, <a class="reference internal" href="#c.gsl_sf_legendre_Pl_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> subject to <img class="math" src="_images/math/d665919149f3c05ff360d7690a24c065d9b79390.png" alt="l \ge 0"/> and
<img class="math" src="_images/math/da7541681ca7b82d3e573aaea6ff9bf6ef2970fe.png" alt="|x| \le 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Pl_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Pl_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Pl_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Pl_deriv_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Pl_deriv_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Pl_deriv_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions compute arrays of Legendre polynomials
<img class="math" src="_images/math/bbc20289cd7e1c1f9a03b493f131519840f111a0.png" alt="P_l(x)"/> and derivatives <img class="math" src="_images/math/01b9be8df783b0997c198a3fc48c9d63a8d5d859.png" alt="dP_l(x)/dx"/>
for <img class="math" src="_images/math/cdce5ef5edad40c80b52e018ae51c079522b4f9b.png" alt="l = 0, \dots, lmax"/> and <img class="math" src="_images/math/da7541681ca7b82d3e573aaea6ff9bf6ef2970fe.png" alt="|x| \le 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Q0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Q0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Q0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Q0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Q0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Q0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Legendre function <img class="math" src="_images/math/f3bf0a08de2d9c320f80c1acc2e75d12c26992e4.png" alt="Q_0(x)"/> for
<img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/> and <img class="math" src="_images/math/41c56410d06dc851577df9115614cd4176959a41.png" alt="x \ne 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Q1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Q1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Q1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Q1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Q1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Q1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Legendre function <img class="math" src="_images/math/6616f3475e1a5a3f82ae932d6ef7b49a19c20224.png" alt="Q_1(x)"/> for
<img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/> and <img class="math" src="_images/math/41c56410d06dc851577df9115614cd4176959a41.png" alt="x \ne 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Ql">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Ql</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Ql" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Ql_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Ql_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Ql_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Legendre function <img class="math" src="_images/math/286b9cf1e1588c43bbcc4d441df24f8cb7f0b86d.png" alt="Q_l(x)"/> for
<img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/>, <img class="math" src="_images/math/41c56410d06dc851577df9115614cd4176959a41.png" alt="x \ne 1"/> and <img class="math" src="_images/math/d665919149f3c05ff360d7690a24c065d9b79390.png" alt="l \ge 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="associated-legendre-polynomials-and-spherical-harmonics">
<h3>Associated Legendre Polynomials and Spherical Harmonics<a class="headerlink" href="#associated-legendre-polynomials-and-spherical-harmonics" title="Permalink to this heading">¶</a></h3>
<p>The following functions compute the associated Legendre polynomials
<img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> which are solutions of the differential equation</p>
<div class="math">
<p><img src="_images/math/443134ae5cf0f8a04ba94e3d5efdd5d422ec163a.png" alt="(1 - x^2) {d^2 \over dx^2} P_l^m(x) - 2x {d \over dx} P_l^m(x) +
\left( l(l+1) - {m^2 \over 1 - x^2} \right) P_l^m(x) = 0"/></p>
</div><p>where the degree <img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> and order <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/> satisfy <img class="math" src="_images/math/e6d5148a3872316e6d95ebcafdc937160682b46d.png" alt="0 \le l"/> and
<img class="math" src="_images/math/819c280a581e1410a0ffc803d3e3fb80cdc31c1f.png" alt="0 \le m \le l"/>.
The functions <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> grow combinatorially with
<img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> and can overflow for <img class="math" src="_images/math/b9448489ac1e80bf324309f27be91130ed3f4b05.png" alt="l"/> larger than about 150.
Alternatively, one may calculate normalized associated Legendre
polynomials. There are a number of different normalization conventions,
and these
functions can be stably computed up to degree and order 2700. The
following normalizations are provided:</p>
<ul>
<li><p>Schmidt semi-normalization</p>
<p>Schmidt semi-normalized associated Legendre polynomials are often
used in the magnetics community and are defined as</p>
<div class="math">
<p><img src="_images/math/22b49d33f782efaa4c8e5ca1750e382a51458997.png" alt="S_l^0(x) &amp;= P_l^0(x) \\
S_l^m(x) &amp;= (-1)^m \sqrt{2 {(l-m)! \over (l+m)!}} P_l^m(x), m &gt; 0"/></p>
</div><p>The factor of <img class="math" src="_images/math/c4ccc4504e128c748bce45ab6f8b8517c295030b.png" alt="(-1)^m"/> is called the Condon-Shortley phase
factor and can be excluded if desired by setting the parameter
<code class="code docutils literal notranslate"><span class="pre">csphase</span> <span class="pre">=</span> <span class="pre">1</span></code> in the functions below.</p>
</li>
<li><p>Spherical Harmonic Normalization</p>
<p>The associated Legendre polynomials suitable for calculating spherical
harmonics are defined as</p>
<div class="math">
<p><img src="_images/math/621af1b33c3426db14f6fd0a3a8980bf2c1feb29.png" alt="Y_l^m(x) = (-1)^m \sqrt{{2l + 1 \over 4 \pi} {(l-m)! \over (l+m)!}} P_l^m(x)"/></p>
</div><p>where again the phase factor <img class="math" src="_images/math/c4ccc4504e128c748bce45ab6f8b8517c295030b.png" alt="(-1)^m"/> can be included or excluded
if desired.</p>
</li>
<li><p>Full Normalization</p>
<p>The fully normalized associated Legendre polynomials are defined as</p>
<div class="math">
<p><img src="_images/math/3f41accb0424ff1873a26ffb24abee31f261f75b.png" alt="N_l^m(x) = (-1)^m \sqrt{(l + {1 \over 2}) {(l-m)! \over (l+m)!}} P_l^m(x)"/></p>
</div><p>and have the property</p>
<div class="math">
<p><img src="_images/math/76865d99c034e440f3f5570aaa102c7fa4090e93.png" alt="\int_{-1}^1 N_l^m(x)^2 dx = 1"/></p>
</div></li>
</ul>
<p>The normalized associated Legendre routines below use a recurrence
relation which is stable up to a degree and order of about 2700.
Beyond this, the computed functions could suffer from underflow
leading to incorrect results. Routines are provided to compute
first and second derivatives
<img class="math" src="_images/math/b92afcc16c69a4b91426e016a13a7c19b3c7bfca.png" alt="dP_l^m(x)/dx"/> and <img class="math" src="_images/math/673db8342cfdae81b50c0bf24dd03eef60d722c7.png" alt="d^2 P_l^m(x)/dx^2"/> as well as their alternate
versions <img class="math" src="_images/math/c8598eaeaa7eca2d200d095430b6e09a64ba3ae5.png" alt="d P_l^m(\cos{\theta})/d\theta"/> and
<img class="math" src="_images/math/18bed22ee3cd7d7bc14e12b92de77fda2dec3118.png" alt="d^2 P_l^m(\cos{\theta})/d\theta^2"/>. While there is a simple
scaling relationship between the two forms, the derivatives
involving <img class="math" src="_images/math/e1dd0b1a971b9a3480d5602ddf0cc4e0316cb036.png" alt="\theta"/> are heavily used in spherical harmonic
expansions and so these routines are also provided.</p>
<p>In the functions below, a parameter of type <a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_sf_legendre_t</span></code></a>
specifies the type of normalization to use. The possible values are</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></span><a class="headerlink" href="#c.gsl_sf_legendre_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">GSL_SF_LEGENDRE_NONE</span></code></p></td>
<td><p>The unnormalized associated Legendre polynomials <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">GSL_SF_LEGENDRE_SCHMIDT</span></code></p></td>
<td><p>The Schmidt semi-normalized associated Legendre polynomials <img class="math" src="_images/math/2c94055be0249f0d75b3eb2c920d5546cf7dfd11.png" alt="S_l^m(x)"/></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">GSL_SF_LEGENDRE_SPHARM</span></code></p></td>
<td><p>The spherical harmonic associated Legendre polynomials <img class="math" src="_images/math/78ca519c3731a55361bdb6241028d35a3f393dba.png" alt="Y_l^m(x)"/></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">GSL_SF_LEGENDRE_FULL</span></code></p></td>
<td><p>The fully normalized associated Legendre polynomials <img class="math" src="_images/math/00c87d40d4aabaf007ad5d9979171a6e298a0937.png" alt="N_l^m(x)"/></p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_array_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_array_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">csphase</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_array_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions calculate all normalized associated Legendre
polynomials for <img class="math" src="_images/math/fb812e44354cfa530f53b0dabb6f702e377617f8.png" alt="0 \le l \le lmax"/> and
<img class="math" src="_images/math/819c280a581e1410a0ffc803d3e3fb80cdc31c1f.png" alt="0 \le m \le l"/> for <img class="math" src="_images/math/da7541681ca7b82d3e573aaea6ff9bf6ef2970fe.png" alt="|x| \le 1"/>.
The <a class="reference internal" href="#c.gsl_sf_legendre_array_e" title="norm"><code class="xref c c-data docutils literal notranslate"><span class="pre">norm</span></code></a> parameter specifies which normalization is used.
The normalized <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> values are stored in <a class="reference internal" href="#c.gsl_sf_legendre_array_e" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>, whose
minimum size can be obtained from calling <a class="reference internal" href="#c.gsl_sf_legendre_array_n" title="gsl_sf_legendre_array_n"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_legendre_array_n()</span></code></a>.
The array index of <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> is obtained from calling
<code class="code docutils literal notranslate"><span class="pre">gsl_sf_legendre_array_index(l,</span> <span class="pre">m)</span></code>. To include or exclude
the Condon-Shortley phase factor of <img class="math" src="_images/math/c4ccc4504e128c748bce45ab6f8b8517c295030b.png" alt="(-1)^m"/>, set the parameter
<a class="reference internal" href="#c.gsl_sf_legendre_array_e" title="csphase"><code class="xref c c-data docutils literal notranslate"><span class="pre">csphase</span></code></a> to either <img class="math" src="_images/math/c7bd6c49eb5a777cc2ce2788ac4455cc30ffecb2.png" alt="-1"/> or <img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> respectively in the
<code class="code docutils literal notranslate"><span class="pre">_e</span></code> function. This factor is excluded by default.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv_array_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv_array_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">csphase</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv_array_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions calculate all normalized associated Legendre
functions and their first derivatives up to degree <a class="reference internal" href="#c.gsl_sf_legendre_deriv_array_e" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a> for
<img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>.
The parameter <a class="reference internal" href="#c.gsl_sf_legendre_deriv_array_e" title="norm"><code class="xref c c-data docutils literal notranslate"><span class="pre">norm</span></code></a> specifies the normalization used. The
normalized <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> values and their derivatives
<img class="math" src="_images/math/b92afcc16c69a4b91426e016a13a7c19b3c7bfca.png" alt="dP_l^m(x)/dx"/> are stored in <a class="reference internal" href="#c.gsl_sf_legendre_deriv_array_e" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a> and
<a class="reference internal" href="#c.gsl_sf_legendre_deriv_array_e" title="result_deriv_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv_array</span></code></a> respectively.
To include or exclude
the Condon-Shortley phase factor of <img class="math" src="_images/math/c4ccc4504e128c748bce45ab6f8b8517c295030b.png" alt="(-1)^m"/>, set the parameter
<a class="reference internal" href="#c.gsl_sf_legendre_deriv_array_e" title="csphase"><code class="xref c c-data docutils literal notranslate"><span class="pre">csphase</span></code></a> to either <img class="math" src="_images/math/c7bd6c49eb5a777cc2ce2788ac4455cc30ffecb2.png" alt="-1"/> or <img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> respectively in the
<code class="code docutils literal notranslate"><span class="pre">_e</span></code> function. This factor is excluded by default.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv_alt_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv_alt_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv_alt_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv_alt_array_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv_alt_array_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">csphase</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv_alt_array_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions calculate all normalized associated Legendre
functions and their (alternate) first derivatives up to degree <a class="reference internal" href="#c.gsl_sf_legendre_deriv_alt_array_e" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a> for
<img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>.
The normalized <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> values and their derivatives
<img class="math" src="_images/math/9cb50ffac7f42c875198ca33e6a8340089e62125.png" alt="dP_l^m(\cos{\theta})/d\theta"/> are stored in <a class="reference internal" href="#c.gsl_sf_legendre_deriv_alt_array_e" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a> and
<a class="reference internal" href="#c.gsl_sf_legendre_deriv_alt_array_e" title="result_deriv_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv_array</span></code></a> respectively.
To include or exclude
the Condon-Shortley phase factor of <img class="math" src="_images/math/c4ccc4504e128c748bce45ab6f8b8517c295030b.png" alt="(-1)^m"/>, set the parameter
<a class="reference internal" href="#c.gsl_sf_legendre_deriv_alt_array_e" title="csphase"><code class="xref c c-data docutils literal notranslate"><span class="pre">csphase</span></code></a> to either <img class="math" src="_images/math/c7bd6c49eb5a777cc2ce2788ac4455cc30ffecb2.png" alt="-1"/> or <img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> respectively in the
<code class="code docutils literal notranslate"><span class="pre">_e</span></code> function. This factor is excluded by default.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv2_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv2_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv2_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv2_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv2_array_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv2_array_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">csphase</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv2_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv2_array_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions calculate all normalized associated Legendre
functions and their first and second derivatives up to degree <a class="reference internal" href="#c.gsl_sf_legendre_deriv2_array_e" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a> for
<img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>.
The parameter <a class="reference internal" href="#c.gsl_sf_legendre_deriv2_array_e" title="norm"><code class="xref c c-data docutils literal notranslate"><span class="pre">norm</span></code></a> specifies the normalization used. The
normalized <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/>, their first derivatives
<img class="math" src="_images/math/b92afcc16c69a4b91426e016a13a7c19b3c7bfca.png" alt="dP_l^m(x)/dx"/>, and their second derivatives
<img class="math" src="_images/math/673db8342cfdae81b50c0bf24dd03eef60d722c7.png" alt="d^2 P_l^m(x)/dx^2"/> are stored in <a class="reference internal" href="#c.gsl_sf_legendre_deriv2_array_e" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>,
<a class="reference internal" href="#c.gsl_sf_legendre_deriv2_array_e" title="result_deriv_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv_array</span></code></a>, and <a class="reference internal" href="#c.gsl_sf_legendre_deriv2_array_e" title="result_deriv2_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv2_array</span></code></a> respectively.
To include or exclude
the Condon-Shortley phase factor of <img class="math" src="_images/math/c4ccc4504e128c748bce45ab6f8b8517c295030b.png" alt="(-1)^m"/>, set the parameter
<a class="reference internal" href="#c.gsl_sf_legendre_deriv2_array_e" title="csphase"><code class="xref c c-data docutils literal notranslate"><span class="pre">csphase</span></code></a> to either <img class="math" src="_images/math/c7bd6c49eb5a777cc2ce2788ac4455cc30ffecb2.png" alt="-1"/> or <img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> respectively in the
<code class="code docutils literal notranslate"><span class="pre">_e</span></code> function. This factor is excluded by default.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv2_alt_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv2_alt_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv2_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv2_alt_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_deriv2_alt_array_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_deriv2_alt_array_e</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_sf_legendre_t" title="gsl_sf_legendre_t"><span class="n"><span class="pre">gsl_sf_legendre_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">csphase</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv2_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_deriv2_alt_array_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions calculate all normalized associated Legendre
functions and their (alternate) first and second derivatives up to degree
<a class="reference internal" href="#c.gsl_sf_legendre_deriv2_alt_array_e" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a> for
<img class="math" src="_images/math/d1a18b6e1485943f8b15efcc2a532934f66c8965.png" alt="|x| &lt; 1"/>.
The parameter <a class="reference internal" href="#c.gsl_sf_legendre_deriv2_alt_array_e" title="norm"><code class="xref c c-data docutils literal notranslate"><span class="pre">norm</span></code></a> specifies the normalization used. The
normalized <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/>, their first derivatives
<img class="math" src="_images/math/9cb50ffac7f42c875198ca33e6a8340089e62125.png" alt="dP_l^m(\cos{\theta})/d\theta"/>, and their second derivatives
<img class="math" src="_images/math/18bed22ee3cd7d7bc14e12b92de77fda2dec3118.png" alt="d^2 P_l^m(\cos{\theta})/d\theta^2"/> are stored in <a class="reference internal" href="#c.gsl_sf_legendre_deriv2_alt_array_e" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>,
<a class="reference internal" href="#c.gsl_sf_legendre_deriv2_alt_array_e" title="result_deriv_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv_array</span></code></a>, and <a class="reference internal" href="#c.gsl_sf_legendre_deriv2_alt_array_e" title="result_deriv2_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv2_array</span></code></a> respectively.
To include or exclude
the Condon-Shortley phase factor of <img class="math" src="_images/math/c4ccc4504e128c748bce45ab6f8b8517c295030b.png" alt="(-1)^m"/>, set the parameter
<a class="reference internal" href="#c.gsl_sf_legendre_deriv2_alt_array_e" title="csphase"><code class="xref c c-data docutils literal notranslate"><span class="pre">csphase</span></code></a> to either <img class="math" src="_images/math/c7bd6c49eb5a777cc2ce2788ac4455cc30ffecb2.png" alt="-1"/> or <img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> respectively in the
<code class="code docutils literal notranslate"><span class="pre">_e</span></code> function. This factor is excluded by default.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_nlm">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_nlm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_nlm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the total number of associated Legendre
functions <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> for a given <a class="reference internal" href="#c.gsl_sf_legendre_nlm" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a>. The number is
<code class="code docutils literal notranslate"><span class="pre">(lmax+1)</span> <span class="pre">*</span> <span class="pre">(lmax+2)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_array_n">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_array_n</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_array_n" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the minimum array size for maximum degree <a class="reference internal" href="#c.gsl_sf_legendre_array_n" title="lmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">lmax</span></code></a>
needed for the array versions of the associated Legendre functions.
Size is calculated as the total number of <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> functions
(see <a class="reference internal" href="#c.gsl_sf_legendre_nlm" title="gsl_sf_legendre_nlm"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_legendre_nlm()</span></code></a>),
plus extra space for precomputing multiplicative factors used in the
recurrence relations.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_array_index">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_array_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_array_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the index into <code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code>,
<code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv_array</span></code>, or <code class="xref c c-data docutils literal notranslate"><span class="pre">result_deriv2_array</span></code> corresponding
to <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/>, <img class="math" src="_images/math/054d8128531b9f154a29a9fde5c25863da177ea8.png" alt="P_l^{'m}(x)"/>, or <img class="math" src="_images/math/561fdcee70fbc5b5d1b2adca6442d48dd67a6767.png" alt="P_l^{''m}(x)"/>. The
index is given by <img class="math" src="_images/math/9cdeaccf4a92544880fc5496f967e5755e380739.png" alt="l(l+1)/2 + m"/>.</p>
<p>An inline version of this function is used if <code class="xref c c-macro docutils literal notranslate"><span class="pre">HAVE_INLINE</span></code> is
defined.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Plm">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Plm</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Plm" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Plm_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Plm_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Plm_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the associated Legendre polynomial
<img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/> for <img class="math" src="_images/math/7aae81a518b58b792bd118b07f33dba073ba2c03.png" alt="m \ge 0"/>,
<img class="math" src="_images/math/6f044757c2777dfe30d0908b1bb3faf67dc6fea1.png" alt="l \ge m"/>, and <img class="math" src="_images/math/da7541681ca7b82d3e573aaea6ff9bf6ef2970fe.png" alt="|x| \le 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_sphPlm">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_sphPlm</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_sphPlm" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_sphPlm_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_sphPlm_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_sphPlm_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the normalized associated Legendre polynomial
<img class="math" src="_images/math/c933690e3e84fa0d1d8c021ddad4d4a95b2e0350.png" alt="\sqrt{(2l+1)/(4\pi)} \sqrt{(l-m)!/(l+m)!} P_l^m(x)"/> suitable
for use in spherical harmonics.  The parameters must satisfy <img class="math" src="_images/math/7aae81a518b58b792bd118b07f33dba073ba2c03.png" alt="m \ge 0"/>,
<img class="math" src="_images/math/6f044757c2777dfe30d0908b1bb3faf67dc6fea1.png" alt="l \ge m"/>, and <img class="math" src="_images/math/da7541681ca7b82d3e573aaea6ff9bf6ef2970fe.png" alt="|x| \le 1"/>.
These routines avoid the overflows
that occur for the standard normalization of <img class="math" src="_images/math/4330831be5972970d23cac200df00a997cde31f4.png" alt="P_l^m(x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Plm_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Plm_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Plm_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_Plm_deriv_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_Plm_deriv_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_Plm_deriv_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions are now deprecated and will be removed in a future
release; see <a class="reference internal" href="#c.gsl_sf_legendre_array" title="gsl_sf_legendre_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_legendre_array()</span></code></a> and
<a class="reference internal" href="#c.gsl_sf_legendre_deriv_array" title="gsl_sf_legendre_deriv_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_legendre_deriv_array()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_sphPlm_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_sphPlm_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_sphPlm_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_sphPlm_deriv_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_sphPlm_deriv_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_deriv_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_sphPlm_deriv_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions are now deprecated and will be removed in a future
release; see <a class="reference internal" href="#c.gsl_sf_legendre_array" title="gsl_sf_legendre_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_legendre_array()</span></code></a> and
<a class="reference internal" href="#c.gsl_sf_legendre_deriv_array" title="gsl_sf_legendre_deriv_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_sf_legendre_deriv_array()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_array_size">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_array_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_array_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function is now deprecated and will be removed in a future
release.</p>
</dd></dl>

</div>
<div class="section" id="conical-functions">
<h3>Conical Functions<a class="headerlink" href="#conical-functions" title="Permalink to this heading">¶</a></h3>
<p>The Conical Functions <img class="math" src="_images/math/52c39cb59ffe763faab3bb6dd7d0044014eff60d.png" alt="P^\mu_{-(1/2)+i\lambda}(x)"/>
and <img class="math" src="_images/math/3af1cc221c28ae215e5a1d1b6e65144771d00469.png" alt="Q^\mu_{-(1/2)+i\lambda}"/>
are described in Abramowitz &amp; Stegun, Section 8.12.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_half">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_half</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_half" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_half_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_half_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_half_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the irregular Spherical Conical Function
<img class="math" src="_images/math/57940b32d211418edcd9e57ce6eb23937851f3a0.png" alt="P^{1/2}_{-1/2 + i \lambda}(x)"/> for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_mhalf">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_mhalf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_mhalf" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_mhalf_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_mhalf_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_mhalf_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the regular Spherical Conical Function
<img class="math" src="_images/math/e0998c72f2a96a9c83602114e1489b2dcd19c25c.png" alt="P^{-1/2}_{-1/2 + i \lambda}(x)"/> for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the conical function
<img class="math" src="_images/math/3e0c25a33e089cb5d32c1cf6f833258b4f409524.png" alt="P^0_{-1/2 + i \lambda}(x)"/> for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the conical function
<img class="math" src="_images/math/0e5cda16af4e36c30e9db4517a0a9e80fea85747.png" alt="P^1_{-1/2 + i \lambda}(x)"/> for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_sph_reg">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_sph_reg</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_sph_reg" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_sph_reg_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_sph_reg_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_sph_reg_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Regular Spherical Conical Function
<img class="math" src="_images/math/f41f5afe34fb0a610cfe34947ea43a13333b2711.png" alt="P^{-1/2-l}_{-1/2 + i \lambda}(x)"/>
for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/> and <img class="math" src="_images/math/453efad23909ad748e95acc9f4b3666abb90f761.png" alt="l \ge -1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_cyl_reg">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_cyl_reg</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_cyl_reg" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_conicalP_cyl_reg_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_conicalP_cyl_reg_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_conicalP_cyl_reg_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Regular Cylindrical Conical Function
<img class="math" src="_images/math/f694abe11a72ffc6d442e520dff85ebe45b7b5fb.png" alt="P^{-m}_{-1/2 + i \lambda}(x)"/>
for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/> and <img class="math" src="_images/math/59b6e261dd4d61eb8af30dcefb2d5c96920b8000.png" alt="m \ge -1"/>.</p>
</dd></dl>

</div>
<div class="section" id="radial-functions-for-hyperbolic-space">
<h3>Radial Functions for Hyperbolic Space<a class="headerlink" href="#radial-functions-for-hyperbolic-space" title="Permalink to this heading">¶</a></h3>
<p>The following spherical functions are specializations of Legendre
functions which give the regular eigenfunctions of the Laplacian on a
3-dimensional hyperbolic space <img class="math" src="_images/math/dbbbcf9483053f7126771b8b6a892b0932047c14.png" alt="H^3"/>.  Of particular interest is
the flat limit, <img class="math" src="_images/math/91a74e405419c868e4950f34a4e9815313bd4fce.png" alt="\lambda \to \infty"/>, <img class="math" src="_images/math/5f9024414e9b22677b79d02b1451151eefedf782.png" alt="\eta \to 0"/>,
<img class="math" src="_images/math/05f42f970ede7904043f081eb23dbe97cb4887ae.png" alt="\lambda\eta"/> fixed.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_H3d_0">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_H3d_0</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_H3d_0" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_H3d_0_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_H3d_0_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_H3d_0_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space,</p>
<div class="math">
<p><img src="_images/math/aa7e49bada7da28f572331441ee134fb68f24526.png" alt="L^{H3d}_0(\lambda,\eta) := {\sin(\lambda\eta) \over \lambda\sinh(\eta)}"/></p>
</div><p>for <img class="math" src="_images/math/736d8ac6b1cb1a4e87927c36a2184078a8bc30ad.png" alt="\eta \ge 0"/>.
In the flat limit this takes the form
<img class="math" src="_images/math/3e6557a82b09accabcf7d0db5faa69f29b7eda50.png" alt="L^{H3d}_0(\lambda,\eta) = j_0(\lambda\eta)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_H3d_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_H3d_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_H3d_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_H3d_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_H3d_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_H3d_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the first radial eigenfunction of the Laplacian on
the 3-dimensional hyperbolic space,</p>
<div class="math">
<p><img src="_images/math/9ebecbb3cf3631aa7af201bed16a0499a57527ab.png" alt="L^{H3d}_1(\lambda,\eta) := {1\over\sqrt{\lambda^2 + 1}} {\left(\sin(\lambda \eta)\over \lambda \sinh(\eta)\right)} \left(\coth(\eta) - \lambda \cot(\lambda\eta)\right)"/></p>
</div><p>for <img class="math" src="_images/math/736d8ac6b1cb1a4e87927c36a2184078a8bc30ad.png" alt="\eta \ge 0"/>
In the flat limit this takes the form
<img class="math" src="_images/math/5cc7e49fe961ae0f927fb940377d1eb8f3854c1d.png" alt="L^{H3d}_1(\lambda,\eta) = j_1(\lambda\eta)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_H3d">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_H3d</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_H3d" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_legendre_H3d_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_H3d_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">l</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_H3d_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the <a class="reference internal" href="#c.gsl_sf_legendre_H3d_e" title="l"><code class="xref c c-data docutils literal notranslate"><span class="pre">l</span></code></a>-th radial eigenfunction of the
Laplacian on the 3-dimensional hyperbolic space <img class="math" src="_images/math/736d8ac6b1cb1a4e87927c36a2184078a8bc30ad.png" alt="\eta \ge 0"/> and
<img class="math" src="_images/math/d665919149f3c05ff360d7690a24c065d9b79390.png" alt="l \ge 0"/>.
In the flat limit this takes the form
<img class="math" src="_images/math/65a89f2d298f2bef629170e1f4f76e2d2311e09d.png" alt="L^{H3d}_l(\lambda,\eta) = j_l(\lambda\eta)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_legendre_H3d_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_legendre_H3d_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_legendre_H3d_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes an array of radial eigenfunctions
<img class="math" src="_images/math/10dff5d387c767df60b39f5bd75363822b3de5a6.png" alt="L^{H3d}_l( \lambda, \eta)"/>
for <img class="math" src="_images/math/fb812e44354cfa530f53b0dabb6f702e377617f8.png" alt="0 \le l \le lmax"/>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="logarithm-and-related-functions">
<h2>Logarithm and Related Functions<a class="headerlink" href="#logarithm-and-related-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-84">Information on the properties of the Logarithm function can be found in
Abramowitz &amp; Stegun, Chapter 4.  The functions described in this section
are declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_log.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_log">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_log_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of <a class="reference internal" href="#c.gsl_sf_log_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <img class="math" src="_images/math/a3b5fb81c7e88dba5c146ec8857bfaa3688016dd.png" alt="\log(x)"/>, for
<img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_log_abs">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_abs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_abs" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_log_abs_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_abs_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_abs_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the logarithm of the magnitude of <a class="reference internal" href="#c.gsl_sf_log_abs_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>,
<img class="math" src="_images/math/584459aa72bc68a2aa0a974ad4dff7b2f707eff4.png" alt="\log(|x|)"/>, for <img class="math" src="_images/math/08b22f2091e56984b838bc753903690f5725a98c.png" alt="x \ne 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_complex_log_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_complex_log_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zr</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zi</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lnr</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">theta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_complex_log_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the complex logarithm of <img class="math" src="_images/math/8f79842f7b30ac690d371512a3dbc30e347d1faa.png" alt="z = z_r + i z_i"/>.
The results are returned as <a class="reference internal" href="#c.gsl_sf_complex_log_e" title="lnr"><code class="xref c c-data docutils literal notranslate"><span class="pre">lnr</span></code></a>, <a class="reference internal" href="#c.gsl_sf_complex_log_e" title="theta"><code class="xref c c-data docutils literal notranslate"><span class="pre">theta</span></code></a> such that
<img class="math" src="_images/math/0d73d81fad5b7a0fa5173ea8fcbd47b07ca5205b.png" alt="\exp(lnr + i \theta) = z_r + i z_i"/>, where <img class="math" src="_images/math/e1dd0b1a971b9a3480d5602ddf0cc4e0316cb036.png" alt="\theta"/> lies in
the range <img class="math" src="_images/math/58bf004f12f914a4398f6b9638ee5cc7cf724392.png" alt="[-\pi,\pi]"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_log_1plusx">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_1plusx</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_1plusx" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_log_1plusx_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_1plusx_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_1plusx_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute <img class="math" src="_images/math/d9a5af68134dd95b9f802034c1467ade9ed75771.png" alt="\log(1 + x)"/> for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/> using an
algorithm that is accurate for small <a class="reference internal" href="#c.gsl_sf_log_1plusx_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_log_1plusx_mx">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_1plusx_mx</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_1plusx_mx" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_log_1plusx_mx_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_log_1plusx_mx_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_log_1plusx_mx_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute <img class="math" src="_images/math/c4c655b4d7c27bfef5a4115d171f4922d0f50780.png" alt="\log(1 + x) - x"/> for <img class="math" src="_images/math/5f1192873d385e759b35f4bb7a0bc9252555b162.png" alt="x &gt; -1"/> using an
algorithm that is accurate for small <a class="reference internal" href="#c.gsl_sf_log_1plusx_mx_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="mathieu-functions">
<h2>Mathieu Functions<a class="headerlink" href="#mathieu-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-85">The routines described in this section compute the angular and radial
Mathieu functions, and their characteristic values.  Mathieu
functions are the solutions of the following two differential
equations:</p>
<div class="math">
<p><img src="_images/math/1873b68404c29334abd6359ac6a06f0179f571b6.png" alt="{{d^2 y}\over{d v^2}}&amp; + (a - 2q\cos 2v)y  = 0 \\
{{d^2 f}\over{d u^2}}&amp; - (a - 2q\cosh 2u)f  = 0"/></p>
</div><p>The angular Mathieu functions <img class="math" src="_images/math/7138d836e55095cf4f76a08bfb00c9e54ef977a6.png" alt="ce_r(x,q)"/>, <img class="math" src="_images/math/f77272ea0c8f977b5ab5b9e8e7d593b0fab2ab95.png" alt="se_r(x,q)"/> are
the even and odd periodic solutions of the first equation, which is known as Mathieu’s equation. These exist
only for the discrete sequence of  characteristic values <img class="math" src="_images/math/2d4a09a5c2bd37681d76541e1e77f6a63d08555d.png" alt="a = a_r(q)"/>
(even-periodic) and <img class="math" src="_images/math/0a53cce169e9ea960f588df78c2aeb383ed768b7.png" alt="a = b_r(q)"/> (odd-periodic).</p>
<p>The radial Mathieu functions <img class="math" src="_images/math/75c4aabe1716faea2724521eae3d02696015abdf.png" alt="Mc^{(j)}_{r}(z,q)"/> and
<img class="math" src="_images/math/d335cb244c23c6a49ad43d96cebcae49ba6b2f91.png" alt="Ms^{(j)}_{r}(z,q)"/>
are the solutions of the second equation,
which is referred to as Mathieu’s modified equation.  The
radial Mathieu functions of the first, second, third and fourth kind
are denoted by the parameter <img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>, which takes the value 1, 2, 3
or 4.</p>
<p>For more information on the Mathieu functions, see Abramowitz and
Stegun, Chapter 20.  These functions are defined in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_mathieu.h</span></code>.</p>
<div class="section" id="mathieu-function-workspace">
<h3>Mathieu Function Workspace<a class="headerlink" href="#mathieu-function-workspace" title="Permalink to this heading">¶</a></h3>
<p>The Mathieu functions can be computed for a single order or
for multiple orders, using array-based routines.  The array-based
routines require a preallocated workspace.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_workspace">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></span><a class="headerlink" href="#c.gsl_sf_mathieu_workspace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Workspace required for array-based routines</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_alloc">
<a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_alloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">qmax</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a workspace for the array versions of the
Mathieu routines.  The arguments n and <a class="reference internal" href="#c.gsl_sf_mathieu_alloc" title="qmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">qmax</span></code></a> specify the
maximum order and <img class="math" src="_images/math/b37ddf7d09edbcd8e9da5bb7965bdcc6ab32b507.png" alt="q"/>-value of Mathieu functions which can be
computed with this workspace.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function frees the workspace <a class="reference internal" href="#c.gsl_sf_mathieu_free" title="work"><code class="xref c c-data docutils literal notranslate"><span class="pre">work</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="mathieu-function-characteristic-values">
<h3>Mathieu Function Characteristic Values<a class="headerlink" href="#mathieu-function-characteristic-values" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-86"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_a">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_a</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_a" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_a_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_a_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_a_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_b">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_b</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_b" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_b_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_b_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_b_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the characteristic values <img class="math" src="_images/math/53bfcb211f43cd3fe44fdf193f18ed98cfe6f8d5.png" alt="a_n(q)"/>,
<img class="math" src="_images/math/54af63bb3e4c479243f6cc27daa73739a519bc39.png" alt="b_n(q)"/> of the Mathieu functions <img class="math" src="_images/math/edd89b65c93d7096bb3dda5686d014ed91266e41.png" alt="ce_n(q,x)"/> and
<img class="math" src="_images/math/e58c61213900ded4d5f1128d544a9380f44cc4ed.png" alt="se_n(q,x)"/>, respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_a_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_a_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order_min</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order_max</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_a_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_b_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_b_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order_min</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order_max</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_b_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute a series of Mathieu characteristic values
<img class="math" src="_images/math/53bfcb211f43cd3fe44fdf193f18ed98cfe6f8d5.png" alt="a_n(q)"/>, <img class="math" src="_images/math/54af63bb3e4c479243f6cc27daa73739a519bc39.png" alt="b_n(q)"/> for <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from <a class="reference internal" href="#c.gsl_sf_mathieu_b_array" title="order_min"><code class="xref c c-data docutils literal notranslate"><span class="pre">order_min</span></code></a> to
<a class="reference internal" href="#c.gsl_sf_mathieu_b_array" title="order_max"><code class="xref c c-data docutils literal notranslate"><span class="pre">order_max</span></code></a> inclusive, storing the results in the array <a class="reference internal" href="#c.gsl_sf_mathieu_b_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="angular-mathieu-functions">
<h3>Angular Mathieu Functions<a class="headerlink" href="#angular-mathieu-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-87"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_ce">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_ce</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_ce" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_ce_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_ce_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_ce_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_se">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_se</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_se" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_se_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_se_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_se_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the angular Mathieu functions <img class="math" src="_images/math/edd89b65c93d7096bb3dda5686d014ed91266e41.png" alt="ce_n(q,x)"/>
and <img class="math" src="_images/math/e58c61213900ded4d5f1128d544a9380f44cc4ed.png" alt="se_n(q,x)"/>, respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_ce_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_ce_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_ce_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_se_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_se_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_se_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute a series of the angular Mathieu functions
<img class="math" src="_images/math/edd89b65c93d7096bb3dda5686d014ed91266e41.png" alt="ce_n(q,x)"/> and <img class="math" src="_images/math/e58c61213900ded4d5f1128d544a9380f44cc4ed.png" alt="se_n(q,x)"/> of order <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> from
<a class="reference internal" href="#c.gsl_sf_mathieu_se_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to <a class="reference internal" href="#c.gsl_sf_mathieu_se_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> inclusive, storing the results in the array
<a class="reference internal" href="#c.gsl_sf_mathieu_se_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="radial-mathieu-functions">
<h3>Radial Mathieu Functions<a class="headerlink" href="#radial-mathieu-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-88"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_Mc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_Mc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_Mc" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_Mc_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_Mc_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_Mc_e" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_Ms">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_Ms</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_Ms" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_Ms_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_Ms_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_Ms_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the radial <a class="reference internal" href="#c.gsl_sf_mathieu_Ms_e" title="j"><code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code></a>-th kind Mathieu functions
<img class="math" src="_images/math/3b0eef5e76db2d458aa030f1319bf9632d545d87.png" alt="Mc_n^{(j)}(q,x)"/> and <img class="math" src="_images/math/b8586211893ccdd75757bba4f81ff1f59ac910fb.png" alt="Ms_n^{(j)}(q,x)"/> of order <a class="reference internal" href="#c.gsl_sf_mathieu_Ms_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
<p>The allowed values of <a class="reference internal" href="#c.gsl_sf_mathieu_Ms_e" title="j"><code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code></a> are 1 and 2.
The functions for <img class="math" src="_images/math/b39f4df9cdcb48a1914cf4c6fa7047265c752f94.png" alt="j = 3,4"/> can be computed as
<img class="math" src="_images/math/985ef5a22f8c712f801065b6844f83b99a8beda6.png" alt="M_n^{(3)} = M_n^{(1)} + iM_n^{(2)}"/> and
<img class="math" src="_images/math/75af8ae204f0ca58cda65767c7619c1d97a83f98.png" alt="M_n^{(4)} = M_n^{(1)} - iM_n^{(2)}"/>,
where
<img class="math" src="_images/math/b5c91d552f9b686231391c7da4e5fe134fa8047b.png" alt="M_n^{(j)} = Mc_n^{(j)}"/> or
<img class="math" src="_images/math/0463caa8d63da32d1ace56f6352bae4aa01bb09f.png" alt="Ms_n^{(j)}"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_Mc_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_Mc_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_Mc_array" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_mathieu_Ms_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_mathieu_Ms_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_mathieu_workspace" title="gsl_sf_mathieu_workspace"><span class="n"><span class="pre">gsl_sf_mathieu_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">result_array</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_mathieu_Ms_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute a series of the radial Mathieu functions of
kind <a class="reference internal" href="#c.gsl_sf_mathieu_Ms_array" title="j"><code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code></a>, with order from <a class="reference internal" href="#c.gsl_sf_mathieu_Ms_array" title="nmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmin</span></code></a> to <a class="reference internal" href="#c.gsl_sf_mathieu_Ms_array" title="nmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nmax</span></code></a> inclusive, storing the
results in the array <a class="reference internal" href="#c.gsl_sf_mathieu_Ms_array" title="result_array"><code class="xref c c-data docutils literal notranslate"><span class="pre">result_array</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="power-function">
<h2>Power Function<a class="headerlink" href="#power-function" title="Permalink to this heading">¶</a></h2>
<p id="index-89">The following functions are equivalent to the function <a class="reference internal" href="math.html#c.gsl_pow_int" title="gsl_pow_int"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_pow_int()</span></code></a>
with an error estimate.  These functions are
declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_pow_int.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_pow_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_pow_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_pow_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_pow_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_pow_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_pow_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the power <img class="math" src="_images/math/d1e97c35882ba9581683a3cbd111da2ad6c52975.png" alt="x^n"/> for integer <a class="reference internal" href="#c.gsl_sf_pow_int_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.  The
power is computed using the minimum number of multiplications. For
example, <img class="math" src="_images/math/2bc17fc9b20233667fb5f8ee27c0a42d8402351e.png" alt="x^8"/> is computed as <img class="math" src="_images/math/6eed6780480a443d2a672eda69ba2d2f016e3389.png" alt="((x^2)^2)^2"/>, requiring only 3
multiplications.  For reasons of efficiency, these functions do not
check for overflow or underflow conditions. The following is a simple example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;gsl/gsl_sf_pow_int.h&gt;</span>
<span class="o">/*</span> <span class="n">compute</span> <span class="mf">3.0</span><span class="o">**</span><span class="mi">12</span> <span class="o">*/</span>
<span class="n">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gsl_sf_pow_int</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="psi-digamma-function">
<h2>Psi (Digamma) Function<a class="headerlink" href="#psi-digamma-function" title="Permalink to this heading">¶</a></h2>
<p id="index-90">The polygamma functions of order <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> are defined by</p>
<div class="math">
<p><img src="_images/math/92800c0aa6e38701c4f3cdefe5dc93f0b0cdfa3b.png" alt="\psi^{(n)}(x) = \left(d \over dx\right)^n \psi(x) = \left(d \over dx\right)^{n+1} \log(\Gamma(x))"/></p>
</div><p>where <img class="math" src="_images/math/12f69793912751146266e7420c0a34f2e697aab7.png" alt="\psi(x) = \Gamma'(x)/\Gamma(x)"/> is known as the digamma function.
These functions are declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_psi.h</span></code>.</p>
<div class="section" id="digamma-function">
<h3>Digamma Function<a class="headerlink" href="#digamma-function" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_psi_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_psi_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the digamma function <img class="math" src="_images/math/8c74e064a7ed6409e44a578804f6174dc2852d9f.png" alt="\psi(n)"/> for positive
integer <a class="reference internal" href="#c.gsl_sf_psi_int_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.  The digamma function is also called the Psi function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_psi">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_psi_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the digamma function <img class="math" src="_images/math/e16e19f19e9546e8079d8884e45ad6f384b95e2a.png" alt="\psi(x)"/> for general
<a class="reference internal" href="#c.gsl_sf_psi_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <img class="math" src="_images/math/08b22f2091e56984b838bc753903690f5725a98c.png" alt="x \ne 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_psi_1piy">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_1piy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_1piy" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_psi_1piy_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_1piy_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_1piy_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the real part of the digamma function on the line
<img class="math" src="_images/math/96c6e12f4f4f5e4ebedf2b4ee5a0bced1173ea9d.png" alt="1 + i y"/>, <img class="math" src="_images/math/7a7e5152e896af59593dc34b7658699ceddd826f.png" alt="\Re[\psi(1 + i y)]"/>.</p>
</dd></dl>

</div>
<div class="section" id="trigamma-function">
<h3>Trigamma Function<a class="headerlink" href="#trigamma-function" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_psi_1_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_1_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_1_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_psi_1_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_1_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_1_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Trigamma function <img class="math" src="_images/math/5d5878b6ed2f67a4bb8ecf90738ba2e6e3531ca1.png" alt="\psi'(n)"/> for
positive integer <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_psi_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_psi_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Trigamma function <img class="math" src="_images/math/63795840f5ad5139099d3327dc21bd6ad80218bf.png" alt="\psi'(x)"/> for
general <a class="reference internal" href="#c.gsl_sf_psi_1_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="polygamma-function">
<h3>Polygamma Function<a class="headerlink" href="#polygamma-function" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_psi_n">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_n</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_n" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_psi_n_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_psi_n_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_psi_n_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the polygamma function <img class="math" src="_images/math/3774167aa9fa90f67e99e535b2ccfba1b6a9d0e5.png" alt="\psi^{(n)}(x)"/> for
<img class="math" src="_images/math/7e3a223e0034ddc1ec94b09a7e2e36ce1ad2bb40.png" alt="n \ge 0"/>, <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="synchrotron-functions">
<h2>Synchrotron Functions<a class="headerlink" href="#synchrotron-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-91">The functions described in this section are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_sf_synchrotron.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_synchrotron_1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_synchrotron_1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_synchrotron_1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_synchrotron_1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_synchrotron_1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_synchrotron_1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the first synchrotron function
<img class="math" src="_images/math/c1bb193787cf1632ff8d08060adc48971d0e5a6a.png" alt="x \int_x^\infty dt K_{5/3}(t)"/>
for <img class="math" src="_images/math/fb962f1d729e73f74976a1aaa75281e5c1589064.png" alt="x \ge 0"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_synchrotron_2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_synchrotron_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_synchrotron_2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_synchrotron_2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_synchrotron_2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_synchrotron_2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the second synchrotron function
<img class="math" src="_images/math/2680f016f0f5ce9a231fd53fed7faec560786687.png" alt="x K_{2/3}(x)"/> for <img class="math" src="_images/math/fb962f1d729e73f74976a1aaa75281e5c1589064.png" alt="x \ge 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="transport-functions">
<h2>Transport Functions<a class="headerlink" href="#transport-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-92">The transport functions <img class="math" src="_images/math/e3f588f5d1d0926ac3a9a4780135f789bf8b1787.png" alt="J(n,x)"/> are defined by the integral
representations</p>
<div class="math">
<p><img src="_images/math/732b93244929d9b741f6f75c190f005618894b1e.png" alt="J(n,x) = \int_0^x t^n e^t /(e^t - 1)^2 dt"/></p>
</div><p>They are declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_transport.h</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_transport_2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_transport_2_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_2_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_2_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the transport function <img class="math" src="_images/math/afb62ab51b0109607ce574206723b5d371b48f22.png" alt="J(2,x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_transport_3">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_3</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_3" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_transport_3_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_3_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_3_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the transport function <img class="math" src="_images/math/8a2a7e41c31d4c03750cf982a5ca2cec9830c97b.png" alt="J(3,x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_transport_4">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_4</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_4" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_transport_4_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_4_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_4_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the transport function <img class="math" src="_images/math/c6d5ff461b70af7eb3eb835a72fae6d0f7f942dc.png" alt="J(4,x)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_transport_5">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_5</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_5" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_transport_5_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_transport_5_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_transport_5_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the transport function <img class="math" src="_images/math/1ac9c675b66e899594fd41b16f7d4b8f4f30820d.png" alt="J(5,x)"/>.</p>
</dd></dl>

</div>
<div class="section" id="trigonometric-functions">
<h2>Trigonometric Functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-93">The library includes its own trigonometric functions in order to provide
consistency across platforms and reliable error estimates.  These
functions are declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_trig.h</span></code>.</p>
<div class="section" id="circular-trigonometric-functions">
<h3>Circular Trigonometric Functions<a class="headerlink" href="#circular-trigonometric-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-94"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_sin">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_sin</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_sin" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_sin_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_sin_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_sin_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the sine function <img class="math" src="_images/math/12043d2248c70949457b6474af615f6daebd11d9.png" alt="\sin(x)"/>.</p>
</dd></dl>

<span class="target" id="index-95"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_cos">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_cos</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_cos" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_cos_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_cos_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_cos_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the cosine function <img class="math" src="_images/math/0e1ce893088fa794b35dc1ee7c7041bd0022a9f3.png" alt="\cos(x)"/>.</p>
</dd></dl>

<span class="target" id="index-96"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hypot">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hypot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hypot" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hypot_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hypot_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hypot_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the hypotenuse function <img class="math" src="_images/math/1be7b6a9cf87e66dd1379af2e7e458e2fb863015.png" alt="\sqrt{x^2 + y^2}"/>
avoiding overflow and underflow.</p>
</dd></dl>

<span class="target" id="index-97"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_sinc">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_sinc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_sinc" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_sinc_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_sinc_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_sinc_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute <img class="math" src="_images/math/692ac7dbecade0c1d6a08cf65143ff679d6ff354.png" alt="\sinc(x) = \sin(\pi x) / (\pi x)"/> for any
value of <a class="reference internal" href="#c.gsl_sf_sinc_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="trigonometric-functions-for-complex-arguments">
<h3>Trigonometric Functions for Complex Arguments<a class="headerlink" href="#trigonometric-functions-for-complex-arguments" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-98"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_complex_sin_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_complex_sin_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zr</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zi</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">szr</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">szi</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_complex_sin_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the complex sine, <img class="math" src="_images/math/46d5ae19a9cd02b211ac9121ba9c31326a8ec322.png" alt="\sin(z_r + i z_i)"/> storing
the real and imaginary parts in <a class="reference internal" href="#c.gsl_sf_complex_sin_e" title="szr"><code class="xref c c-data docutils literal notranslate"><span class="pre">szr</span></code></a>, <a class="reference internal" href="#c.gsl_sf_complex_sin_e" title="szi"><code class="xref c c-data docutils literal notranslate"><span class="pre">szi</span></code></a>.</p>
</dd></dl>

<span class="target" id="index-99"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_complex_cos_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_complex_cos_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zr</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zi</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">czr</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">czi</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_complex_cos_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the complex cosine, <img class="math" src="_images/math/49d0f5904e673f13fcae788135b54be6c48c9700.png" alt="\cos(z_r + i z_i)"/> storing
the real and imaginary parts in <a class="reference internal" href="#c.gsl_sf_complex_cos_e" title="czr"><code class="xref c c-data docutils literal notranslate"><span class="pre">czr</span></code></a>, <a class="reference internal" href="#c.gsl_sf_complex_cos_e" title="czi"><code class="xref c c-data docutils literal notranslate"><span class="pre">czi</span></code></a>.</p>
</dd></dl>

<span class="target" id="index-100"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_complex_logsin_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_complex_logsin_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zr</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">zi</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lszr</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lszi</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_complex_logsin_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the logarithm of the complex sine,
<img class="math" src="_images/math/aa7dfa65aeb214f61853202c33ff7bff57caacc4.png" alt="\log(\sin(z_r + i z_i))"/> storing the real and imaginary parts in
<a class="reference internal" href="#c.gsl_sf_complex_logsin_e" title="lszr"><code class="xref c c-data docutils literal notranslate"><span class="pre">lszr</span></code></a>, <a class="reference internal" href="#c.gsl_sf_complex_logsin_e" title="lszi"><code class="xref c c-data docutils literal notranslate"><span class="pre">lszi</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="hyperbolic-trigonometric-functions">
<h3>Hyperbolic Trigonometric Functions<a class="headerlink" href="#hyperbolic-trigonometric-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-101"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lnsinh">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnsinh</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnsinh" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lnsinh_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lnsinh_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lnsinh_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute <img class="math" src="_images/math/5dc5d23e87d48b6ae225ce023bb252c95921392f.png" alt="\log(\sinh(x))"/> for <img class="math" src="_images/math/466ff8a42ff4ddd04ca09617a529d03dae832eee.png" alt="x &gt; 0"/>.</p>
</dd></dl>

<span class="target" id="index-102"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_lncosh">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lncosh</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lncosh" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_lncosh_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_lncosh_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_lncosh_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute <img class="math" src="_images/math/04abe999cfeee1bb9be7d01ad66cb2f5701e8b71.png" alt="\log(\cosh(x))"/> for any <a class="reference internal" href="#c.gsl_sf_lncosh_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="conversion-functions">
<h3>Conversion Functions<a class="headerlink" href="#conversion-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-103"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_polar_to_rect">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_polar_to_rect</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">theta</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_polar_to_rect" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function converts the polar coordinates (<a class="reference internal" href="#c.gsl_sf_polar_to_rect" title="r"><code class="xref c c-data docutils literal notranslate"><span class="pre">r</span></code></a>, <a class="reference internal" href="#c.gsl_sf_polar_to_rect" title="theta"><code class="xref c c-data docutils literal notranslate"><span class="pre">theta</span></code></a>) to
rectilinear coordinates (<a class="reference internal" href="#c.gsl_sf_polar_to_rect" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <a class="reference internal" href="#c.gsl_sf_polar_to_rect" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>), <img class="math" src="_images/math/a8f49e71b9c327dc0624ddb4ebf0197b995a5102.png" alt="x = r\cos(\theta)"/>,
<img class="math" src="_images/math/7fcf1a2e7af4ce7735324432d33f4c0b668b9c62.png" alt="y = r\sin(\theta)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_rect_to_polar">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_rect_to_polar</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">theta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_rect_to_polar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function converts the rectilinear coordinates (<a class="reference internal" href="#c.gsl_sf_rect_to_polar" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <a class="reference internal" href="#c.gsl_sf_rect_to_polar" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>) to
polar coordinates (<a class="reference internal" href="#c.gsl_sf_rect_to_polar" title="r"><code class="xref c c-data docutils literal notranslate"><span class="pre">r</span></code></a>, <a class="reference internal" href="#c.gsl_sf_rect_to_polar" title="theta"><code class="xref c c-data docutils literal notranslate"><span class="pre">theta</span></code></a>), such that <img class="math" src="_images/math/a8f49e71b9c327dc0624ddb4ebf0197b995a5102.png" alt="x = r\cos(\theta)"/>,
<img class="math" src="_images/math/7fcf1a2e7af4ce7735324432d33f4c0b668b9c62.png" alt="y = r\sin(\theta)"/>.  The argument <a class="reference internal" href="#c.gsl_sf_rect_to_polar" title="theta"><code class="xref c c-data docutils literal notranslate"><span class="pre">theta</span></code></a>
lies in the range <img class="math" src="_images/math/f1d88aa0da78220e264d3d348b86b6c424d4c06c.png" alt="[-\pi, \pi]"/>.</p>
</dd></dl>

</div>
<div class="section" id="restriction-functions">
<h3>Restriction Functions<a class="headerlink" href="#restriction-functions" title="Permalink to this heading">¶</a></h3>
<span class="target" id="index-104"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_angle_restrict_symm">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_angle_restrict_symm</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">theta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_angle_restrict_symm" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_angle_restrict_symm_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_angle_restrict_symm_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">theta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_angle_restrict_symm_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines force the angle <a class="reference internal" href="#c.gsl_sf_angle_restrict_symm_e" title="theta"><code class="xref c c-data docutils literal notranslate"><span class="pre">theta</span></code></a> to lie in the range
<img class="math" src="_images/math/f5aebcae7457b93a1bdbbaea798fa93f72a31d0d.png" alt="(-\pi,\pi]"/>.</p>
<p>Note that the mathematical value of <img class="math" src="_images/math/38aa55829038d8edbd874969ca2af5ca133e5842.png" alt="\pi"/> is slightly greater
than <code class="xref c c-macro docutils literal notranslate"><span class="pre">M_PI</span></code>, so the machine numbers <code class="xref c c-macro docutils literal notranslate"><span class="pre">M_PI</span></code> and <code class="code docutils literal notranslate"><span class="pre">-M_PI</span></code>
are included in the range.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_angle_restrict_pos">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_angle_restrict_pos</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">theta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_angle_restrict_pos" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_angle_restrict_pos_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_angle_restrict_pos_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">theta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_angle_restrict_pos_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines force the angle <a class="reference internal" href="#c.gsl_sf_angle_restrict_pos_e" title="theta"><code class="xref c c-data docutils literal notranslate"><span class="pre">theta</span></code></a> to lie in the range <img class="math" src="_images/math/6fa25fa1a8c61eca27c71c15f09ead634d845fe8.png" alt="[0, 2\pi)"/>.</p>
<p>Note that the mathematical value of <img class="math" src="_images/math/dfee3e2a92a47b726eb60c6c56ce6d790b4c6336.png" alt="2\pi"/> is slightly greater
than <code class="code docutils literal notranslate"><span class="pre">2*M_PI</span></code>, so the machine number <code class="code docutils literal notranslate"><span class="pre">2*M_PI</span></code> is included in
the range.</p>
</dd></dl>

</div>
<div class="section" id="trigonometric-functions-with-error-estimates">
<h3>Trigonometric Functions With Error Estimates<a class="headerlink" href="#trigonometric-functions-with-error-estimates" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_sin_err_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_sin_err_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dx</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_sin_err_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the sine of an angle <a class="reference internal" href="#c.gsl_sf_sin_err_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> with an associated
absolute error <a class="reference internal" href="#c.gsl_sf_sin_err_e" title="dx"><code class="xref c c-data docutils literal notranslate"><span class="pre">dx</span></code></a>,
<img class="math" src="_images/math/cb4f5c3bde9fcbaefdf1d9323fabffd9f597d535.png" alt="\sin(x \pm dx)"/>.  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_cos_err_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_cos_err_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">dx</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_cos_err_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This routine computes the cosine of an angle <a class="reference internal" href="#c.gsl_sf_cos_err_e" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a> with an associated
absolute error <a class="reference internal" href="#c.gsl_sf_cos_err_e" title="dx"><code class="xref c c-data docutils literal notranslate"><span class="pre">dx</span></code></a>,
<img class="math" src="_images/math/771064915c08f14af473480cb52e1c8cc06a577a.png" alt="\cos(x \pm dx)"/>.  Note that this function is provided in the error-handling form only since
its purpose is to compute the propagated error.</p>
</dd></dl>

</div>
</div>
<div class="section" id="zeta-functions">
<h2>Zeta Functions<a class="headerlink" href="#zeta-functions" title="Permalink to this heading">¶</a></h2>
<p id="index-105">The Riemann zeta function is defined in Abramowitz &amp; Stegun, Section
23.2.  The functions described in this section are declared in the
header file <code class="file docutils literal notranslate"><span class="pre">gsl_sf_zeta.h</span></code>.</p>
<div class="section" id="riemann-zeta-function">
<h3>Riemann Zeta Function<a class="headerlink" href="#riemann-zeta-function" title="Permalink to this heading">¶</a></h3>
<p id="index-106">The Riemann zeta function is defined by the infinite sum</p>
<div class="math">
<p><img src="_images/math/51affb892deebd66a202cd73a05bca67073448db.png" alt="\zeta(s) = \sum_{k=1}^\infty k^{-s}"/></p>
</div><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_zeta_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zeta_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zeta_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_zeta_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zeta_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zeta_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Riemann zeta function <img class="math" src="_images/math/2254fdba04ac3b41e6ac82080d8239900c297d4f.png" alt="\zeta(n)"/>
for integer <a class="reference internal" href="#c.gsl_sf_zeta_int_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>,
<img class="math" src="_images/math/330546a9d74026514a2b58bc1e1124380cd08d17.png" alt="n \ne 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_zeta">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zeta</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zeta" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_zeta_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zeta_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zeta_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Riemann zeta function <img class="math" src="_images/math/a47c8ade4d68d33dca03eddbc90c96f323637d15.png" alt="\zeta(s)"/>
for arbitrary <a class="reference internal" href="#c.gsl_sf_zeta_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>,
<img class="math" src="_images/math/1b3fb3889577d6bc2e20a234027b49d5428e8907.png" alt="s \ne 1"/>.</p>
</dd></dl>

</div>
<div class="section" id="riemann-zeta-function-minus-one">
<h3>Riemann Zeta Function Minus One<a class="headerlink" href="#riemann-zeta-function-minus-one" title="Permalink to this heading">¶</a></h3>
<p>For large positive argument, the Riemann zeta function approaches one.
In this region the fractional part is interesting, and therefore we
need a function to evaluate it explicitly.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_zetam1_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zetam1_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zetam1_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_zetam1_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zetam1_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zetam1_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute <img class="math" src="_images/math/ef4ceed2904d690c14d6272f11c913f819640eaf.png" alt="\zeta(n) - 1"/> for integer <a class="reference internal" href="#c.gsl_sf_zetam1_int_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>,
<img class="math" src="_images/math/330546a9d74026514a2b58bc1e1124380cd08d17.png" alt="n \ne 1"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_zetam1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zetam1</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zetam1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_zetam1_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_zetam1_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_zetam1_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute <img class="math" src="_images/math/4fdfb4f367d3ed520de4b884e257a839ce81a001.png" alt="\zeta(s) - 1"/> for arbitrary <a class="reference internal" href="#c.gsl_sf_zetam1_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>,
<img class="math" src="_images/math/1b3fb3889577d6bc2e20a234027b49d5428e8907.png" alt="s \ne 1"/>.</p>
</dd></dl>

</div>
<div class="section" id="hurwitz-zeta-function">
<h3>Hurwitz Zeta Function<a class="headerlink" href="#hurwitz-zeta-function" title="Permalink to this heading">¶</a></h3>
<p id="index-107">The Hurwitz zeta function is defined by</p>
<div class="math">
<p><img src="_images/math/4cdc75cc8dc27f2eb37df5f3475ea120ffd11edc.png" alt="\zeta(s,q) = \sum_0^\infty (k+q)^{-s}"/></p>
</div><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_hzeta">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hzeta</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hzeta" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_hzeta_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_hzeta_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_hzeta_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the Hurwitz zeta function <img class="math" src="_images/math/2199c4e2ef3f0dd7efc59b2a64614f99096731cd.png" alt="\zeta(s,q)"/> for
<img class="math" src="_images/math/cc892e1168accddd5ace13a483d3d7b139522dc4.png" alt="s &gt; 1"/>, <img class="math" src="_images/math/fe9ab16bd07e0dcc4c88cbde174745eb986f4cff.png" alt="q &gt; 0"/>.</p>
</dd></dl>

</div>
<div class="section" id="eta-function">
<h3>Eta Function<a class="headerlink" href="#eta-function" title="Permalink to this heading">¶</a></h3>
<p id="index-108">The eta function is defined by</p>
<div class="math">
<p><img src="_images/math/bfc0591dbe7df90d2fba2ee2889949ac1cea6a40.png" alt="\eta(s) = (1-2^{1-s}) \zeta(s)"/></p>
</div><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_eta_int">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_eta_int</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_eta_int" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_eta_int_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_eta_int_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_eta_int_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the eta function <img class="math" src="_images/math/ce30b15568995f7a69c25fedd8a8168a6bb69382.png" alt="\eta(n)"/> for integer <a class="reference internal" href="#c.gsl_sf_eta_int_e" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_sf_eta">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_eta</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_eta" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_sf_eta_e">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_sf_eta_e</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_sf_result" title="gsl_sf_result"><span class="n"><span class="pre">gsl_sf_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_sf_eta_e" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These routines compute the eta function <img class="math" src="_images/math/6be6770942694bceeeada59bd354d501190108c0.png" alt="\eta(s)"/> for arbitrary <a class="reference internal" href="#c.gsl_sf_eta_e" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<div class="section" id="example-1-bessel-function-j-0">
<h3>Example 1: Bessel function <img class="math" src="_images/math/9d3ed64c11cbeaa0f6694f61488f9b44cc3474dc.png" alt="J_0"/><a class="headerlink" href="#example-1-bessel-function-j-0" title="Permalink to this heading">¶</a></h3>
<p>The following example demonstrates the use of the error handling form of
the special functions, in this case to compute the Bessel function
<img class="math" src="_images/math/8fd9a57e0578ebf468ea04257292db459aa6289f.png" alt="J_0(5.0)"/>,</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_errno.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_sf_bessel.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="n">gsl_sf_result</span> <span class="n">result</span><span class="p">;</span>

  <span class="n">double</span> <span class="n">expected</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.17759677131433830434739701</span><span class="p">;</span>

  <span class="nb">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">gsl_sf_bessel_J0_e</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;status  = </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;J0(5.0) = </span><span class="si">%.18f</span><span class="se">\n</span><span class="s2">&quot;</span>
          <span class="s2">&quot;      +/- </span><span class="si">% .18f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">result</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">err</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;exact   = </span><span class="si">%.18f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here are the results of running the program,</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">status</span>  <span class="o">=</span> <span class="n">success</span>
<span class="n">J0</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.177596771314338264</span>
      <span class="o">+/-</span>  <span class="mf">0.000000000000000193</span>
<span class="n">exact</span>   <span class="o">=</span> <span class="o">-</span><span class="mf">0.177596771314338292</span>
</pre></div>
</div>
<p>The next program computes the same quantity using the natural form of
the function. In this case the error term <code class="xref c c-data docutils literal notranslate"><span class="pre">result.err</span></code> and return
status are not accessible.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_sf_bessel.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">expected</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.17759677131433830434739701</span><span class="p">;</span>

  <span class="n">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gsl_sf_bessel_J0</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;J0(5.0) = </span><span class="si">%.18f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;exact   = </span><span class="si">%.18f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The results of the function are the same,</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">J0</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.177596771314338264</span>
<span class="n">exact</span>   <span class="o">=</span> <span class="o">-</span><span class="mf">0.177596771314338292</span>
</pre></div>
</div>
</div>
<div class="section" id="example-2-associated-legendre-functions">
<h3>Example 2: Associated Legendre Functions<a class="headerlink" href="#example-2-associated-legendre-functions" title="Permalink to this heading">¶</a></h3>
<p>The following example program outputs the spherical harmonic
normalized ALF <img class="math" src="_images/math/b9f6ad35fea3e0dae605fae0eb397da2ae43fda9.png" alt="Y_2^1(\cos{\theta})"/> and its first and second
derivatives with respect to <img class="math" src="_images/math/e1dd0b1a971b9a3480d5602ddf0cc4e0316cb036.png" alt="\theta"/>. The analytic
expressions are,</p>
<div class="math">
<p><img src="_images/math/30224634841e50196acf93e40d6b7a785ea7c366.png" alt="Y_2^1(\cos{\theta}) &amp;= -\frac{1}{2} \sqrt{\frac{15}{2 \pi}} \sin{\theta} \cos{\theta} \\
\frac{d}{d\theta} Y_2^1(\cos{\theta}) &amp;= -\frac{1}{2} \sqrt{\frac{15}{2 \pi}} \left( \cos^2{\theta} - \sin^2{\theta} \right) \\
\frac{d^2}{d\theta^2} Y_2^1(\cos{\theta}) &amp;= 2 \sqrt{\frac{15}{2 \pi}} \sin{\theta} \cos{\theta}"/></p>
</div><div class="figure align-default" id="id5">
<span id="fig-specfun2"></span><img alt="_images/specfun2.png" src="_images/specfun2.png" />
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Spherical harmonic normalized ALF <img class="math" src="_images/math/21e8af75501212883892ec0e1f3edf33aa0dbbaa.png" alt="Y_2^1"/> and its first and
second derivatives with respect to <img class="math" src="_images/math/e1dd0b1a971b9a3480d5602ddf0cc4e0316cb036.png" alt="\theta"/>.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>The source code is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_math.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_sf_legendre.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_sf_alf.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">lmax</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">plm_size</span> <span class="o">=</span> <span class="n">gsl_sf_legendre_array_n</span><span class="p">(</span><span class="n">lmax</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">nlm</span> <span class="o">=</span> <span class="n">gsl_sf_legendre_nlm</span><span class="p">(</span><span class="n">lmax</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">idx21</span> <span class="o">=</span> <span class="n">gsl_sf_legendre_array_index</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">double</span> <span class="o">*</span> <span class="n">Plm</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">plm_size</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
  <span class="n">double</span> <span class="o">*</span> <span class="n">dPlm</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">nlm</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
  <span class="n">double</span> <span class="o">*</span> <span class="n">d2Plm</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">nlm</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
  <span class="n">double</span> <span class="n">x</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.99</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.99</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">gsl_sf_legendre_deriv2_alt_array</span><span class="p">(</span><span class="n">GSL_SF_LEGENDRE_SPHARM</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Plm</span><span class="p">,</span> <span class="n">dPlm</span><span class="p">,</span> <span class="n">d2Plm</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Plm</span><span class="p">[</span><span class="n">idx21</span><span class="p">],</span> <span class="n">dPlm</span><span class="p">[</span><span class="n">idx21</span><span class="p">],</span> <span class="n">d2Plm</span><span class="p">[</span><span class="n">idx21</span><span class="p">]);</span>
    <span class="p">}</span>

  <span class="n">free</span><span class="p">(</span><span class="n">Plm</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">dPlm</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">d2Plm</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="references-and-further-reading">
<h2>References and Further Reading<a class="headerlink" href="#references-and-further-reading" title="Permalink to this heading">¶</a></h2>
<p>The library follows the conventions of the following book where possible,</p>
<ul class="simple">
<li><p>Handbook of Mathematical Functions, edited by Abramowitz &amp; Stegun,
Dover,  ISBN 0486612724.</p></li>
</ul>
<p>The following papers contain information on the algorithms used
to compute the special functions,</p>
<ul class="simple" id="index-109">
<li><p>Allan J. MacLeod, MISCFUN: A software package to compute uncommon
special functions.  ACM Trans. Math. Soft., vol.: 22,
1996, 288–301</p></li>
<li><p>Bosch, W., On the computation of derivatives of Legendre functions,
Phys. Chem. Earth, 25 (9-11), pg. 655–659, 2000.</p></li>
<li><p>Bunck, B. F., A fast algorithm for evaluation of normalized Hermite
functions, BIT Numer. Math, 49: 281-295, 2009.</p></li>
<li><ol class="upperalpha simple" start="2">
<li><p>Hofmann-Wellenhof and H. Moritz, Physical Geodesy, Springer, 2006.</p></li>
</ol>
</li>
<li><p>G.N. Watson, A Treatise on the Theory of Bessel Functions,
2nd Edition (Cambridge University Press, 1944).</p></li>
<li><p>G. Nemeth, Mathematical Approximations of Special Functions,
Nova Science Publishers, ISBN 1-56072-052-2</p></li>
<li><p>B.C. Carlson, Special Functions of Applied Mathematics (1977)</p></li>
<li><p>N. M. Temme, Special Functions: An Introduction to the Classical
Functions of Mathematical Physics (1996), ISBN 978-0471113133.</p></li>
<li><p>W.J. Thompson, Atlas for Computing Mathematical Functions, John Wiley &amp; Sons,
New York (1997).</p></li>
<li><p>Y.Y. Luke, Algorithms for the Computation of Mathematical Functions, Academic
Press, New York (1977).</p></li>
<li><p>S. A. Holmes and W. E. Featherstone, A unified approach to the Clenshaw
summation and the recursive computation of very high degree and order
normalised associated Legendre functions, Journal of Geodesy, 76,
pg. 279-299, 2002.</p></li>
<li><p>D. E. Winch, D. J. Ivers, J. P. R. Turner and R. J. Stening, Geomagnetism
and Schmidt quasi-normalization, Geophys. J. Int., 160, 487-504, 2005.</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="vectors.html" class="btn btn-neutral float-right" title="Vectors and Matrices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="poly.html" class="btn btn-neutral float-left" title="Polynomials" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 1996-2024 The GSL Team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>