/*
    rng.rs
    Copyright (C) 2021 Pim van den Berg

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

use crate::bindings;
use crate::ffi::FFI;
use core::ffi::c_ulong;

pub mod algorithms;


ffi_wrapper!(Rng, *mut bindings::gsl_rng, gsl_rng_free);

impl Rng {
    /// This function returns a pointer to a newly-created instance
    /// of a random number generator of the given type.
    ///
    /// The default algorithm is `rust_gsl::rng::algorithm::mt19937()`.
    /// The `Rng` created with this function is seeded with the default seed of `0`.
    pub fn new() -> Option<Rng> {
        Self::new_with_type(algorithms::mt19937())
    }

    /// This function returns a pointer to a newly-created instance of a random number generator of type T. For example, the following code creates an instance of the Tausworthe generator,
    ///
    /// ```Rust
    /// let r = Rng::new(bindings::gsl_rng_taus);
    /// ```
    ///
    /// If there is insufficient memory to create the generator then the function returns a null pointer and the error handler is invoked with an error code of GSL_ENOMEM.
    ///
    /// The generator is automatically initialized with the default seed, gsl_rng_default_seed. This is zero by default but can be changed either directly or by using the environment variable
    /// GSL_RNG_SEED (see [`Random number environment variables`](https://www.gnu.org/software/gsl/manual/html_node/Random-number-environment-variables.html#Random-number-environment-variables)).
    #[doc(alias = "gsl_rng_alloc")]
    pub fn new_with_type(t: RngType) -> Option<Rng> {
        let tmp = unsafe { bindings::gsl_rng_alloc(t.unwrap_shared()) };

        if tmp.is_null() {
            None
        } else {
            Some(Rng::wrap(tmp))
        }
    }

    /// This function initializes (or ‘seeds’) the random number generator. If the generator is seeded with the same value of s on two different runs, the same stream of random numbers will be generated by successive calls to the routines below.
    /// If different values of s >= 1 are supplied, then the generated streams of random numbers should be completely different. If the seed s is zero then the standard seed from the original implementation is used instead.
    /// For example, the original Fortran source code for the ranlux generator used a seed of 314159265, and so choosing s equal to zero reproduces this when using gsl_rng_ranlux.
    ///
    /// When using multiple seeds with the same generator, choose seed values greater than zero to avoid collisions with the default setting.
    ///
    /// Note that the most generators only accept 32-bit seeds, with higher values being reduced modulo 2^32. For generators with smaller ranges the maximum seed value will typically be lower.
    #[doc(alias = "gsl_rng_set")]
    pub fn set(&mut self, seed: usize) {
        unsafe { bindings::gsl_rng_set(self.unwrap_unique(), seed as _) }
    }

    /// This function returns a random integer from the generator r. The minimum and maximum values depend on the algorithm used, but all integers in the range [min,max] are equally likely.
    /// The values of min and max can be determined using the auxiliary functions gsl_rng_max (r) and gsl_rng_min (r).
    #[doc(alias = "gsl_rng_get")]
    pub fn get(&mut self) -> usize {
        unsafe { bindings::gsl_rng_get(self.unwrap_shared()) as _ }
    }

    /// This function returns a double precision floating point number uniformly distributed in the range [0,1). The range includes 0.0 but excludes 1.0.
    /// The value is typically obtained by dividing the result of gsl_rng_get(r) by gsl_rng_max(r) + 1.0 in double precision.
    /// Some generators compute this ratio internally so that they can provide floating point numbers with more than 32 bits of randomness (the maximum number of bits that can be portably represented in a single unsigned long int).
    #[doc(alias = "gsl_rng_uniform")]
    pub fn uniform(&mut self) -> f64 {
        unsafe { bindings::gsl_rng_uniform(self.unwrap_unique()) }
    }

    /// This function returns a positive double precision floating point number uniformly distributed in the range (0,1), excluding both 0.0 and 1.0.
    /// The number is obtained by sampling the generator with the algorithm of gsl_rng_uniform until a non-zero value is obtained.
    /// You can use this function if you need to avoid a singularity at 0.0.
    #[doc(alias = "gsl_rng_uniform_pos")]
    pub fn uniform_pos(&mut self) -> f64 {
        unsafe { bindings::gsl_rng_uniform_pos(self.unwrap_unique()) }
    }

    /// This function returns a random integer from 0 to n-1 inclusive by scaling down and/or discarding samples from the generator r.
    /// All integers in the range [0,n-1] are produced with equal probability. For generators with a non-zero minimum value an offset is applied so that zero is returned with the correct probability.
    ///
    /// Note that this function is designed for sampling from ranges smaller than the range of the underlying generator. The parameter n must be less than or equal to the range of the generator r.
    /// If n is larger than the range of the generator then the function calls the error handler with an error code of GSL_EINVAL and returns zero.
    ///
    /// In particular, this function is not intended for generating the full range of unsigned integer values [0,2^32-1].
    /// Instead choose a generator with the maximal integer range and zero minimum value, such as gsl_rng_ranlxd1, gsl_rng_mt19937 or gsl_rng_taus, and sample it directly using gsl_rng_get. The range of each generator can be found using the auxiliary functions described in the next section.
    #[doc(alias = "gsl_rng_uniform_int")]
    pub fn uniform_int(&mut self, n: usize) -> usize {
        unsafe { bindings::gsl_rng_uniform_int(self.unwrap_unique(), n as c_ulong) as _ }
    }

    /// This function returns the largest value that the get function can return.
    #[doc(alias = "gsl_rng_max")]
    pub fn max(&self) -> usize {
        unsafe { bindings::gsl_rng_max(self.unwrap_shared()) as _ }
    }

    /// This function returns the smallest value that gsl_rng_get can return. Usually this value is zero.
    /// There are some generators with algorithms that cannot return zero, and for these generators the minimum value is 1.
    #[doc(alias = "gsl_rng_min")]
    pub fn min(&self) -> usize {
        unsafe { bindings::gsl_rng_min(self.unwrap_shared()) as _ }
    }

    /// This function returns a pointer to the state of generator r. You can use this information
    /// to access the state directly. For example, the following code will write the state of a
    /// generator to a stream,
    ///
    /// ```C
    /// void * state = gsl_rng_state (r);
    /// size_t n = gsl_rng_size (r);
    /// fwrite (state, n, 1, stream);
    /// ```
    #[doc(alias = "gsl_rng_state")]
    pub fn state<T>(&self) -> &T {
        unsafe { &(*(bindings::gsl_rng_state(self.unwrap_shared()) as *const T)) }
    }

    /// Equivalent to DefaultRngSeed
    pub fn default_seed() -> usize {
        unsafe { bindings::gsl_rng_default_seed as _ }
    }
}

ffi_wrapper!(RngType, *const bindings::gsl_rng_type);

impl RngType {
    /// wrapper for name element
    pub fn name(&self) -> String {
        let ptr = self.unwrap_shared();
        if ptr.is_null() {
            String::new()
        } else {
            unsafe {
                String::from_utf8_lossy(std::ffi::CStr::from_ptr((*ptr).name).to_bytes())
                    .to_string()
            }
        }
    }

    #[doc(alias = "gsl_rng_default")]
    pub fn default() -> Self {
        ffi_wrap!(gsl_rng_default)
    }

    /// wrapper for max element
    pub fn max(&self) -> usize {
        let ptr = self.unwrap_shared();
        if ptr.is_null() {
            0
        } else {
            unsafe { (*ptr).max as _ }
        }
    }

    /// wrapper for min element
    pub fn min(&self) -> usize {
        let ptr = self.unwrap_shared();
        if ptr.is_null() {
            0
        } else {
            unsafe { (*ptr).min as _ }
        }
    }

    /// wrapper for size element
    pub fn size(&self) -> usize {
        let ptr = self.unwrap_shared();
        if ptr.is_null() {
            0
        } else {
            unsafe { (*ptr).size as usize }
        }
    }

    /// This function returns a pointer to an array of all the available generator types, terminated by a null pointer.
    /// The function should be called once at the start of the program, if needed. The following code fragment shows how to iterate over the array of generator types to print the names of the available algorithms,
    ///
    /// ```Rust
    /// let t = RngType::types_setup ();
    ///
    /// println!("Available generators:");
    /// for tmp in t.iter() {
    ///     println!("{}", tmp.name);
    /// }
    /// ```
    #[doc(alias = "gsl_rng_types_setup")]
    pub fn types_setup() -> Vec<RngType> {
        let ptr = unsafe { bindings::gsl_rng_types_setup() };
        let mut ret = Vec::new();

        if !ptr.is_null() {
            unsafe {
                let mut it = 0;
                loop {
                    let tmp = ptr.offset(it);

                    if (*tmp).is_null() {
                        break;
                    }
                    ret.push(RngType::wrap(*tmp as *mut bindings::gsl_rng_type));
                    it += 1;
                }
            }
        }
        ret
    }

    // Note: we don't bind the `gsl_rng_env_setup()` function because
    // that function makes things unnecessarily complicated.
    // If we want some kind of reproducibility, we shoudn't be reading
    // our generators from an environmental variable.
}

#[cfg(test)]
mod test {
    use crate::rng::Rng;
    use crate::rng;
    use std::collections::HashMap;

    const N: usize = i32::pow(2, 20) as usize;
    const MAX_RANDOM: usize = i32::pow(2, 20) as usize;

    // Very crude check for statistical randomness...
    fn check_rng_frequencies_are_low<T>(iterator: T) -> () where T: Iterator<Item = i32> {
        let frequencies = iterator.fold(HashMap::new(), |mut freqs, value| {
            *freqs.entry(value).or_insert(0) += 1;
            freqs
        });

        let highest_absolute_frequency = frequencies
            .into_iter()
            .max_by_key(|&(_, count)| count)
            .map(|(_, count)| count)
            .unwrap();

        assert!(highest_absolute_frequency < 16)
    }

    #[test]
    fn test_create_default_rng() {
        let _r: Rng = Rng::new().unwrap();
    }
    
    #[test]
    fn test_create_rng_with_type() {
        let _r01: Rng = Rng::new_with_type(rng::algorithms::mt19937()).unwrap();
        let _r02: Rng = Rng::new_with_type(rng::algorithms::ranlxs0()).unwrap();
        let _r03: Rng = Rng::new_with_type(rng::algorithms::ranlxs1()).unwrap();
        let _r04: Rng = Rng::new_with_type(rng::algorithms::ranlxd1()).unwrap();
        let _r05: Rng = Rng::new_with_type(rng::algorithms::ranlxd2()).unwrap();
        let _r06: Rng = Rng::new_with_type(rng::algorithms::ranlux()).unwrap();
        let _r07: Rng = Rng::new_with_type(rng::algorithms::ranlux389()).unwrap();
        let _r08: Rng = Rng::new_with_type(rng::algorithms::cmrg()).unwrap();
        let _r09: Rng = Rng::new_with_type(rng::algorithms::mrg()).unwrap();
        let _r10: Rng = Rng::new_with_type(rng::algorithms::taus()).unwrap();
        let _r11: Rng = Rng::new_with_type(rng::algorithms::taus2()).unwrap();
        let _r12: Rng = Rng::new_with_type(rng::algorithms::gfsr4()).unwrap();
    }

    #[test]
    fn test_default_rng_uses_mt19937() {
        // The rng that wil generate our random seeds
        let mut r_for_seeds: Rng = Rng::new().unwrap();
        // The rngs we will actually compare
        let mut r_default: Rng = Rng::new().unwrap();
        let mut r_mt19937: Rng = Rng::new_with_type(rng::algorithms::mt19937()).unwrap();

        for _i in 0..20 {
            // Get a new seed for this random sequence
            let seed = r_for_seeds.uniform_int(MAX_RANDOM);

            for _j in 0..100 {
                // Reset the seed so that we don't only test the default seed
                r_default.set(seed);
                r_mt19937.set(seed);

                let value_default = r_default.uniform_int(MAX_RANDOM);
                let value_mt19937 = r_mt19937.uniform_int(MAX_RANDOM);
                
                // The output of the rngs should be identical
                assert_eq!(value_default, value_mt19937)
            }
        }
    }

    #[test]
    fn test_rng_values_depend_on_the_seed() {
        // The rng that wil generate our random seeds
        let mut r_for_seeds: Rng = Rng::new().unwrap();
        // The rngs we will actually compare
        let mut r1: Rng = Rng::new().unwrap();
        let mut r2: Rng = Rng::new().unwrap();

        for _i in 0..20_000 {
            // Get a new seed for this random sequence
            let seed1 = r_for_seeds.uniform_int(MAX_RANDOM);
            let seed2 = r_for_seeds.uniform_int(MAX_RANDOM);

            r1.set(seed1);
            r2.set(seed2);

            let v1 = r1.uniform_int(MAX_RANDOM);
            let v2 = r2.uniform_int(MAX_RANDOM);
            
            // The output of the rngs should be identical
            assert_ne!(v1, v2)
        }
    }

    #[test]
    fn test_rng_mt19937() {
        let mut r : Rng = Rng::new_with_type(rng::algorithms::mt19937()).unwrap();
        let frequencies = (1..N).map(|_i| r.uniform_int(MAX_RANDOM) as i32);
        check_rng_frequencies_are_low(frequencies)
    }

    #[test]
    fn test_rng_ranlxs0() {
        let mut r : Rng = Rng::new_with_type(rng::algorithms::ranlxs0()).unwrap();
        let frequencies = (1..N).map(|_i| r.uniform_int(MAX_RANDOM) as i32);
        check_rng_frequencies_are_low(frequencies)
    }

    #[test]
    fn test_rng_ranlxs1() {
        let mut r : Rng = Rng::new_with_type(rng::algorithms::ranlxs1()).unwrap();
        let frequencies = (1..N).map(|_i| r.uniform_int(MAX_RANDOM) as i32);
        check_rng_frequencies_are_low(frequencies)
    }
}