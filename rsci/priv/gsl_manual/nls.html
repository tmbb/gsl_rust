

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Nonlinear Least-Squares Fitting &mdash; GSL 2.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Basis Splines" href="bspline.html" />
    <link rel="prev" title="Linear Least-Squares Fitting" href="lls.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GSL
          

          
          </a>

          
            
            
              <div class="version">
                2.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Using the Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="err.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Mathematical Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="poly.html">Polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="specfunc.html">Special Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="vectors.html">Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiset.html">Multisets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="eigen.html">Eigensystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Fast Fourier Transforms (FFTs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Numerical Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="rng.html">Random Number Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="qrng.html">Quasi-Random Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="randist.html">Random Number Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="rstat.html">Running Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="movstat.html">Moving Window Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Digital Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="histogram.html">Histograms</a></li>
<li class="toctree-l1"><a class="reference internal" href="ntuple.html">N-tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="montecarlo.html">Monte Carlo Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="siman.html">Simulated Annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="ode-initval.html">Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="interp.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="diff.html">Numerical Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheb.html">Chebyshev Approximations</a></li>
<li class="toctree-l1"><a class="reference internal" href="sum.html">Series Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dwt.html">Wavelet Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dht.html">Discrete Hankel Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="roots.html">One Dimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="min.html">One Dimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiroots.html">Multidimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="multimin.html">Multidimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="lls.html">Linear Least-Squares Fitting</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Nonlinear Least-Squares Fitting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#solving-the-trust-region-subproblem-trs">Solving the Trust Region Subproblem (TRS)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#levenberg-marquardt">Levenberg-Marquardt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#levenberg-marquardt-with-geodesic-acceleration">Levenberg-Marquardt with Geodesic Acceleration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dogleg">Dogleg</a></li>
<li class="toctree-l3"><a class="reference internal" href="#double-dogleg">Double Dogleg</a></li>
<li class="toctree-l3"><a class="reference internal" href="#two-dimensional-subspace">Two Dimensional Subspace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#steihaug-toint-conjugate-gradient">Steihaug-Toint Conjugate Gradient</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#weighted-nonlinear-least-squares">Weighted Nonlinear Least-Squares</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tunable-parameters">Tunable Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-the-solver">Initializing the Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#providing-the-function-to-be-minimized">Providing the Function to be Minimized</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#testing-for-convergence">Testing for Convergence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#high-level-driver">High Level Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#covariance-matrix-of-best-fit-parameters">Covariance matrix of best fit parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exponential-fitting-example">Exponential Fitting Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#geodesic-acceleration-example-1">Geodesic Acceleration Example 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#geodesic-acceleration-example-2">Geodesic Acceleration Example 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comparing-trs-methods-example">Comparing TRS Methods Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#large-nonlinear-least-squares-example">Large Nonlinear Least Squares Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bspline.html">Basis Splines</a></li>
<li class="toctree-l1"><a class="reference internal" href="spmatrix.html">Sparse Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="spblas.html">Sparse BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="splinalg.html">Sparse Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="const.html">Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="ieee754.html">IEEE floating-point arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debugging Numerical Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributors to GSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoconf.html">Autoconf Macros</a></li>
<li class="toctree-l1"><a class="reference internal" href="cblas.html">GSL CBLAS Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpl.html">GNU General Public License</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdl.html">GNU Free Documentation License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GSL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Nonlinear Least-Squares Fitting</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/nls.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="bspline.html" class="btn btn-neutral float-right" title="Basis Splines" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="lls.html" class="btn btn-neutral float-left" title="Linear Least-Squares Fitting" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="nonlinear-least-squares-fitting">
<span id="index-0"></span><h1>Nonlinear Least-Squares Fitting<a class="headerlink" href="#nonlinear-least-squares-fitting" title="Permalink to this heading">¶</a></h1>
<p>This chapter describes functions for multidimensional nonlinear
least-squares fitting.  There are generally two classes of
algorithms for solving nonlinear least squares problems, which
fall under line search methods and trust region methods.
GSL currently implements only trust region methods and
provides the user with
full access to intermediate steps of the iteration. The user
also has the ability to tune a number of parameters which affect
low-level aspects of the algorithm which can help to accelerate
convergence for the specific problem at hand. GSL provides
two separate interfaces for nonlinear least squares fitting. The
first is designed for small to moderate sized problems, and the
second is designed for very large problems, which may or may not
have significant sparse structure.</p>
<p>The header file <code class="file docutils literal notranslate"><span class="pre">gsl_multifit_nlinear.h</span></code> contains prototypes for the
multidimensional nonlinear fitting functions and related declarations
relating to the small to moderate sized systems.</p>
<p>The header file <code class="file docutils literal notranslate"><span class="pre">gsl_multilarge_nlinear.h</span></code> contains prototypes for the
multidimensional nonlinear fitting functions and related declarations
relating to large systems.</p>
<div class="section" id="overview">
<span id="index-1"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>The problem of multidimensional nonlinear least-squares fitting requires
the minimization of the squared residuals of <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> functions,
<img class="math" src="_images/math/b7524c4d67379a7045021fd157d0fc7c890ce138.png" alt="f_i"/>, in <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> parameters, <img class="math" src="_images/math/3efd6fd1c2b0c335484bcd4bf7d5d98b99e619f4.png" alt="x_i"/>,</p>
<div class="math">
<p><img src="_images/math/111634228f3cf5a54553bcbdccc2cb29b058d5ba.png" alt="\Phi(x) &amp;= {1 \over 2} || f(x) ||^2 \\
        &amp;= {1 \over 2} \sum_{i=1}^{n} f_i (x_1, \dots, x_p)^2"/></p>
</div><p>In trust region methods, the objective (or cost) function <img class="math" src="_images/math/78a97ae9d36889f1ac61f883c2d4de8ff8ded1d7.png" alt="\Phi(x)"/> is approximated
by a model function <img class="math" src="_images/math/5673cd34d0856f0096f27268795cefb0dca8fe28.png" alt="m_k(\delta)"/> in the vicinity of some point <img class="math" src="_images/math/01401d24cd9c21eeb3e51c7dcfcb52d3c8b86b3b.png" alt="x_k"/>. The
model function is often simply a second order Taylor series expansion around the
point <img class="math" src="_images/math/01401d24cd9c21eeb3e51c7dcfcb52d3c8b86b3b.png" alt="x_k"/>, ie:</p>
<div class="math">
<p><img src="_images/math/7be45cd6a320dfb00e76dead27d22a40c5f7e4a7.png" alt="\Phi(x_k + \delta) \approx m_k(\delta) = \Phi(x_k) + g_k^T \delta + {1 \over 2} \delta^T B_k \delta"/></p>
</div><p>where <img class="math" src="_images/math/fa906754eb58a0a714ddb85fd08911d4cdd72565.png" alt="g_k = \nabla \Phi(x_k) = J^T f"/> is the gradient vector at the point <img class="math" src="_images/math/01401d24cd9c21eeb3e51c7dcfcb52d3c8b86b3b.png" alt="x_k"/>,
<img class="math" src="_images/math/48e8dce1a67a54a936777b2cd7c84a5c5e30d8a4.png" alt="B_k = \nabla^2 \Phi(x_k)"/> is the Hessian matrix at <img class="math" src="_images/math/01401d24cd9c21eeb3e51c7dcfcb52d3c8b86b3b.png" alt="x_k"/>, or some
approximation to it, and <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/> is the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> Jacobian matrix</p>
<div class="math">
<p><img src="_images/math/8fbcfe8c7bd26b0fbf85c4bc4aac2c5e69416102.png" alt="J_{ij} = \partial f_i / \partial x_j"/></p>
</div><p>In order to find the next step <img class="math" src="_images/math/e0991156a224047b35453a4d365526b09ffe5746.png" alt="\delta"/>, we minimize the model function
<img class="math" src="_images/math/5673cd34d0856f0096f27268795cefb0dca8fe28.png" alt="m_k(\delta)"/>, but search for solutions only within a region where
we trust that <img class="math" src="_images/math/5673cd34d0856f0096f27268795cefb0dca8fe28.png" alt="m_k(\delta)"/> is a good approximation to the objective
function <img class="math" src="_images/math/40a10393751755cc68710ec87e1d939a0e255538.png" alt="\Phi(x_k + \delta)"/>. In other words,
we seek a solution of the trust region subproblem (TRS)</p>
<div class="math">
<p><img src="_images/math/6b9a2495cc9d4d8e62550a49e579862211fbd8c7.png" alt="\min_{\delta \in R^p} m_k(\delta) = \Phi(x_k) + g_k^T \delta + {1 \over 2} \delta^T B_k \delta, \qquad\hbox{s.t.}\quad || D_k \delta || \le \Delta_k"/></p>
</div><p>where <img class="math" src="_images/math/f810cadfb9a540c371c085806a33225726536bbc.png" alt="\Delta_k &gt; 0"/> is the trust region radius and <img class="math" src="_images/math/bb76a70718dcc54807a0f90074963feb2e25a4c4.png" alt="D_k"/> is
a scaling matrix. If <img class="math" src="_images/math/e7997babf7961774d7362730788db5b1a5ec73a0.png" alt="D_k = I"/>, then the trust region is a ball
of radius <img class="math" src="_images/math/635b5e94773801684254d9193274bb41c91d0ab8.png" alt="\Delta_k"/> centered at <img class="math" src="_images/math/01401d24cd9c21eeb3e51c7dcfcb52d3c8b86b3b.png" alt="x_k"/>. In some applications,
the parameter vector <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> may have widely different scales. For
example, one parameter might be a temperature on the order of
<img class="math" src="_images/math/cd6d8b9f76b737c8db6959ee69d89c328ec4c34a.png" alt="10^3"/> K, while another might be a length on the order of
<img class="math" src="_images/math/89e101ca93aff6de51f3f50284bca187e04d974e.png" alt="10^{-6}"/> m. In such cases, a spherical trust region may not
be the best choice, since if <img class="math" src="_images/math/5d831871e4a68eb9c3f1f3637508ade0f4d648db.png" alt="\Phi"/> changes rapidly along
directions with one scale, and more slowly along directions with
a different scale, the model function <img class="math" src="_images/math/523d7a0895d14d2c48c8a0b79fe053d3df9ea47d.png" alt="m_k"/> may be a poor
approximation to <img class="math" src="_images/math/5d831871e4a68eb9c3f1f3637508ade0f4d648db.png" alt="\Phi"/> along the rapidly changing directions.
In such problems, it may be best to use an elliptical trust region,
by setting <img class="math" src="_images/math/bb76a70718dcc54807a0f90074963feb2e25a4c4.png" alt="D_k"/> to a diagonal matrix whose entries are designed
so that the scaled step <img class="math" src="_images/math/47b2ad9401a61935143c9fbb4440bc3159a2682e.png" alt="D_k \delta"/> has entries of approximately the same
order of magnitude.</p>
<p>The trust region subproblem above normally amounts to solving a
linear least squares system (or multiple systems) for the step
<img class="math" src="_images/math/e0991156a224047b35453a4d365526b09ffe5746.png" alt="\delta"/>. Once <img class="math" src="_images/math/e0991156a224047b35453a4d365526b09ffe5746.png" alt="\delta"/> is computed, it is checked whether
or not it reduces the objective function <img class="math" src="_images/math/78a97ae9d36889f1ac61f883c2d4de8ff8ded1d7.png" alt="\Phi(x)"/>. A useful
statistic for this is to look at the ratio</p>
<div class="math">
<p><img src="_images/math/bd1057913b21563aa3070417f4b6bc0940c724f7.png" alt="\rho_k = { \Phi(x_k) - \Phi(x_k + \delta_k) \over m_k(0) - m_k(\delta_k) }"/></p>
</div><p>where the numerator is the actual reduction of the objective function
due to the step <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/>, and the denominator is the predicted
reduction due to the model <img class="math" src="_images/math/523d7a0895d14d2c48c8a0b79fe053d3df9ea47d.png" alt="m_k"/>. If <img class="math" src="_images/math/c63a46f6f10096e38663d0d2692e0416286f2e1f.png" alt="\rho_k"/> is negative,
it means that the step <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/> increased the objective function
and so it is rejected. If <img class="math" src="_images/math/c63a46f6f10096e38663d0d2692e0416286f2e1f.png" alt="\rho_k"/> is positive,
then we have found a step which reduced the objective function and
it is accepted. Furthermore, if <img class="math" src="_images/math/c63a46f6f10096e38663d0d2692e0416286f2e1f.png" alt="\rho_k"/> is close to 1,
then this indicates that the model function is a good approximation
to the objective function in the trust region, and so on the next
iteration the trust region is enlarged in order to take more ambitious
steps. When a step is rejected, the trust region is made smaller and
the TRS is solved again. An outline for the general trust region method
used by GSL can now be given.</p>
<p><strong>Trust Region Algorithm</strong></p>
<ol class="arabic">
<li><p>Initialize: given <img class="math" src="_images/math/d45c09a2a331e0ce1ad0fb441b2bb6915516ec0a.png" alt="x_0"/>, construct <img class="math" src="_images/math/04230074b8eb4105c2616de66af6285dadef57d4.png" alt="m_0(\delta)"/>, <img class="math" src="_images/math/0557059ef6eeeb39d69f8a6aab60f5d89b7a3f0d.png" alt="D_0"/> and <img class="math" src="_images/math/2bd930792b315b8776f371161096db2baea1be4b.png" alt="\Delta_0 &gt; 0"/></p></li>
<li><p>For k = 0, 1, 2, …</p>
<ol class="loweralpha">
<li><p>If converged, then stop</p></li>
<li><p>Solve TRS for trial step <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/></p></li>
<li><p>Evaluate trial step by computing <img class="math" src="_images/math/c63a46f6f10096e38663d0d2692e0416286f2e1f.png" alt="\rho_k"/></p>
<dl class="simple">
<dt>1). if step is accepted, set <img class="math" src="_images/math/b8f65cdfe49bf4c55534a122e7134b5b54e3b210.png" alt="x_{k+1} = x_k + \delta_k"/> and increase radius,</dt><dd><p><img class="math" src="_images/math/15fd1d61735834e82316cef73d8034a1c736b09a.png" alt="\Delta_{k+1} = \alpha \Delta_k"/></p>
</dd>
<dt>2). if step is rejected, set <img class="math" src="_images/math/a144307e05c98e5805a018fb8d881461637cd559.png" alt="x_{k+1} = x_k"/> and decrease radius,</dt><dd><p><img class="math" src="_images/math/74adb014cb6ff8eefb2f926cbafee539b5562aa3.png" alt="\Delta_{k+1} = {\Delta_k \over \beta}"/>; goto 2(b)</p>
</dd>
</dl>
</li>
<li><p>Construct <img class="math" src="_images/math/fd7f0520e8f99dfbbc87fcce0fefd4ae23d6a2c4.png" alt="m_{k+1}(\delta)"/> and <img class="math" src="_images/math/6091c5826f900e54c38cb7d17fc285b21fa3580c.png" alt="D_{k+1}"/></p></li>
</ol>
</li>
</ol>
<p>GSL offers the user a number of different algorithms for solving the trust
region subproblem in 2(b), as well as different choices of scaling matrices
<img class="math" src="_images/math/bb76a70718dcc54807a0f90074963feb2e25a4c4.png" alt="D_k"/> and different methods of updating the trust region radius
<img class="math" src="_images/math/635b5e94773801684254d9193274bb41c91d0ab8.png" alt="\Delta_k"/>. Therefore, while reasonable default methods are provided,
the user has a lot of control to fine-tune the various steps of the
algorithm for their specific problem.</p>
</div>
<div class="section" id="solving-the-trust-region-subproblem-trs">
<h2>Solving the Trust Region Subproblem (TRS)<a class="headerlink" href="#solving-the-trust-region-subproblem-trs" title="Permalink to this heading">¶</a></h2>
<p>Below we describe the methods available for solving the trust region
subproblem. The methods available provide either exact or approximate
solutions to the trust region subproblem. In all algorithms below,
the Hessian matrix <img class="math" src="_images/math/be3772fac3e2cba15b5f0b14338fb3fc60f41fe7.png" alt="B_k"/> is approximated as <img class="math" src="_images/math/2603f097c1a61eff044ae4be7a3d1edf18e5bfe7.png" alt="B_k \approx J_k^T J_k"/>,
where <img class="math" src="_images/math/a2468efb4542d54007e96c47ff73b1541919a072.png" alt="J_k = J(x_k)"/>. In all methods, the solution of the TRS
involves solving a linear least squares system involving the Jacobian
matrix. For small to moderate sized problems (<code class="code docutils literal notranslate"><span class="pre">gsl_multifit_nlinear</span></code> interface),
this is accomplished by factoring the full Jacobian matrix, which is provided
by the user, with the Cholesky, QR, or SVD decompositions. For large systems
(<code class="code docutils literal notranslate"><span class="pre">gsl_multilarge_nlinear</span></code> interface), the user has two choices. One
is to solve the system iteratively, without needing to store the full
Jacobian matrix in memory. With this method, the user must provide a routine
to calculate the matrix-vector products <img class="math" src="_images/math/f57a4296462c42fefce883993b1021d34ad79dc9.png" alt="J u"/> or <img class="math" src="_images/math/32ff04d3dfc6082bf0464393e614784d955ffa2c.png" alt="J^T u"/> for a given vector <img class="math" src="_images/math/71fb5a1cc0758ba70654e6dc934c374032656d2f.png" alt="u"/>.
This iterative method is particularly useful for systems where the Jacobian has
sparse structure, since forming matrix-vector products can be done cheaply. The
second option for large systems involves forming the normal equations matrix
<img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/> and then factoring it using a Cholesky decomposition. The normal
equations matrix is <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>, typically much smaller than the full
<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> Jacobian, and can usually be stored in memory even if the full
Jacobian matrix cannot. This option is useful for large, dense systems, or if the
iterative method has difficulty converging.</p>
<div class="section" id="levenberg-marquardt">
<span id="index-2"></span><h3>Levenberg-Marquardt<a class="headerlink" href="#levenberg-marquardt" title="Permalink to this heading">¶</a></h3>
<p>There is a theorem which states that if <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/> is a solution
to the trust region subproblem given above, then there exists
<img class="math" src="_images/math/f83e002b1b9553d02e1d5c27b531e5e5f98e0f5e.png" alt="\mu_k \ge 0"/> such that</p>
<div class="math">
<p><img src="_images/math/733c5a7b7323a8ce185b9b33408ae393371c65f6.png" alt="\left( B_k + \mu_k D_k^T D_k \right) \delta_k = -g_k"/></p>
</div><p>with <img class="math" src="_images/math/f0e10d213475b51ca27f2f73782c51dc37faf604.png" alt="\mu_k (\Delta_k - ||D_k \delta_k||) = 0"/>. This
forms the basis of the Levenberg-Marquardt algorithm, which controls
the trust region size by adjusting the parameter <img class="math" src="_images/math/4961b8a0423cfd6a44d82272836839dff869c8c8.png" alt="\mu_k"/>
rather than the radius <img class="math" src="_images/math/635b5e94773801684254d9193274bb41c91d0ab8.png" alt="\Delta_k"/> directly. For each radius
<img class="math" src="_images/math/635b5e94773801684254d9193274bb41c91d0ab8.png" alt="\Delta_k"/>, there is a unique parameter <img class="math" src="_images/math/4961b8a0423cfd6a44d82272836839dff869c8c8.png" alt="\mu_k"/> which
solves the TRS, and they have an inverse relationship, so that large values of
<img class="math" src="_images/math/4961b8a0423cfd6a44d82272836839dff869c8c8.png" alt="\mu_k"/> correspond to smaller trust regions, while small
values of <img class="math" src="_images/math/4961b8a0423cfd6a44d82272836839dff869c8c8.png" alt="\mu_k"/> correspond to larger trust regions.</p>
<p>With the approximation <img class="math" src="_images/math/2603f097c1a61eff044ae4be7a3d1edf18e5bfe7.png" alt="B_k \approx J_k^T J_k"/>, on each iteration,
in order to calculate the step <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/>,
the following linear least squares problem is solved:</p>
<div class="math">
<p><img src="_images/math/3e54d994a48dc853136043faa932b9f59ef7092a.png" alt="\left[
  \begin{array}{c}
    J_k \\
    \sqrt{\mu_k} D_k
  \end{array}
\right]
\delta_k =
-
\left[
  \begin{array}{c}
    f_k \cr
    0
  \end{array}
\right]"/></p>
</div><p>If the step <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/> is accepted, then
<img class="math" src="_images/math/4961b8a0423cfd6a44d82272836839dff869c8c8.png" alt="\mu_k"/> is decreased on the next iteration in order
to take a larger step, otherwise it is increased to take
a smaller step. The Levenberg-Marquardt algorithm provides
an exact solution of the trust region subproblem, but
typically has a higher computational cost per iteration
than the approximate methods discussed below, since it
may need to solve the least squares system above several
times for different values of <img class="math" src="_images/math/4961b8a0423cfd6a44d82272836839dff869c8c8.png" alt="\mu_k"/>.</p>
</div>
<div class="section" id="levenberg-marquardt-with-geodesic-acceleration">
<span id="index-3"></span><h3>Levenberg-Marquardt with Geodesic Acceleration<a class="headerlink" href="#levenberg-marquardt-with-geodesic-acceleration" title="Permalink to this heading">¶</a></h3>
<p>This method applies a so-called geodesic acceleration correction to
the standard Levenberg-Marquardt step <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/> (Transtrum et al, 2011).
By interpreting <img class="math" src="_images/math/6688656ae662d9a67e162db53bdbfafb821a1e87.png" alt="\delta_k"/> as a first order step along a geodesic in the
model parameter space (ie: a velocity <img class="math" src="_images/math/a6e8b0faa065a1419d575e970064d8fdf796c3ef.png" alt="\delta_k = v_k"/>), the geodesic
acceleration <img class="math" src="_images/math/b5c5fadd11e0bdd3e79c943c4b2b72b444a0c3a9.png" alt="a_k"/> is a second order correction along the
geodesic which is determined by solving the linear least squares system</p>
<div class="math">
<p><img src="_images/math/6487ffad655f1dbfb0f9e92628d1a174b0294ef1.png" alt="\left[
  \begin{array}{c}
    J_k \\
    \sqrt{\mu_k} D_k
  \end{array}
\right]
a_k =
-
\left[
  \begin{array}{c}
    f_{vv}(x_k) \\
    0
  \end{array}
\right]"/></p>
</div><p>where <img class="math" src="_images/math/cb2a18d5300bf4dc33c3fa500afd9951f45cc990.png" alt="f_{vv}"/> is the second directional derivative of
the residual vector in the velocity direction <img class="math" src="_images/math/5fdec03022aa06df18d924e8a33c9d7c6db2ebc8.png" alt="v"/>,
<img class="math" src="_images/math/b9782dc6f78bfb28fa3a32a3085b4c1f106de419.png" alt="f_{vv}(x) = D_v^2 f = \sum_{\alpha\beta} v_{\alpha} v_{\beta} \partial_{\alpha} \partial_{\beta} f(x)"/>,
where <img class="math" src="_images/math/0ab46f38795b87ecb430f3146823a15ef903e42d.png" alt="\alpha"/> and <img class="math" src="_images/math/e02f190f8fb57cf0cbdb88e60ad6999080cfed17.png" alt="\beta"/> are summed over the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>
parameters. The new total step is then <img class="math" src="_images/math/a1464b23ab2688139cdb8f80108d1d72d1a52a60.png" alt="\delta_k' = v_k + {1 \over 2}a_k"/>.
The second order correction <img class="math" src="_images/math/b5c5fadd11e0bdd3e79c943c4b2b72b444a0c3a9.png" alt="a_k"/> can be calculated with a modest additional
cost, and has been shown to dramatically reduce the number of iterations
(and expensive Jacobian evaluations) required to reach convergence on a variety
of different problems. In order to utilize the geodesic acceleration, the user must supply a
function which provides the second directional derivative vector
<img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/>, or alternatively the library can use a finite
difference method to estimate this vector with one additional function
evaluation of <img class="math" src="_images/math/b34d5a441bb929a3eef3e35354d5a83c4c9eeef3.png" alt="f(x + h v)"/> where <img class="math" src="_images/math/aca32b204f928ef3ee8c82cd7a605c4da0c65f18.png" alt="h"/> is a tunable step size
(see the <code class="code docutils literal notranslate"><span class="pre">h_fvv</span></code> parameter description).</p>
</div>
<div class="section" id="dogleg">
<span id="index-4"></span><h3>Dogleg<a class="headerlink" href="#dogleg" title="Permalink to this heading">¶</a></h3>
<p>This is Powell’s dogleg method, which finds an approximate
solution to the trust region subproblem, by restricting
its search to a piecewise linear “dogleg” path,
composed of the origin, the Cauchy point which represents
the model minimizer along the steepest descent direction,
and the Gauss-Newton point, which is the overall minimizer
of the unconstrained model. The Gauss-Newton step is calculated by
solving</p>
<div class="math">
<p><img src="_images/math/dbaca3fbf2e9973c682faeb50bf60c21687f676b.png" alt="J_k \delta_{gn} = -f_k"/></p>
</div><p>which is the main computational task for each iteration,
but only needs to be performed once per iteration. If
the Gauss-Newton point is inside the trust region, it is
selected as the step. If it is outside, the method then
calculates the Cauchy point, which is located along the
gradient direction. If the Cauchy point is also outside
the trust region, the method assumes that it is still far
from the minimum and so proceeds along the gradient
direction, truncating the step at the trust region
boundary. If the Cauchy point is inside the trust region,
with the Gauss-Newton point outside, the method
uses a dogleg step, which is a linear combination of the
gradient direction and the Gauss-Newton direction, stopping at the trust
region boundary.</p>
</div>
<div class="section" id="double-dogleg">
<span id="index-5"></span><h3>Double Dogleg<a class="headerlink" href="#double-dogleg" title="Permalink to this heading">¶</a></h3>
<p>This method is an improvement over the classical dogleg
algorithm, which attempts to include information about
the Gauss-Newton step while the iteration is still far from
the minimum. When the Cauchy point is inside the trust region
and the Gauss-Newton point is outside, the method computes
a scaled Gauss-Newton point and then takes a dogleg step
between the Cauchy point and the scaled Gauss-Newton point.
The scaling is calculated to ensure that the reduction
in the model <img class="math" src="_images/math/523d7a0895d14d2c48c8a0b79fe053d3df9ea47d.png" alt="m_k"/> is about the same as the reduction
provided by the Cauchy point.</p>
</div>
<div class="section" id="two-dimensional-subspace">
<h3>Two Dimensional Subspace<a class="headerlink" href="#two-dimensional-subspace" title="Permalink to this heading">¶</a></h3>
<p>The dogleg methods restrict the search for the TRS solution
to a 1D curve defined by the Cauchy and Gauss-Newton points.
An improvement to this is to search for a solution using
the full two dimensional subspace spanned by the Cauchy
and Gauss-Newton directions. The dogleg path is of course
inside this subspace, and so this method solves the TRS
at least as accurately as the dogleg methods. Since this
method searches a larger subspace for a solution, it can
converge more quickly than dogleg on some problems. Because
the subspace is only two dimensional, this method is
very efficient and the main computation per iteration is
to determine the Gauss-Newton point.</p>
</div>
<div class="section" id="steihaug-toint-conjugate-gradient">
<h3>Steihaug-Toint Conjugate Gradient<a class="headerlink" href="#steihaug-toint-conjugate-gradient" title="Permalink to this heading">¶</a></h3>
<p>One difficulty of the dogleg methods is calculating the
Gauss-Newton step when the Jacobian matrix is singular. The
Steihaug-Toint method also computes a generalized dogleg
step, but avoids solving for the Gauss-Newton step directly,
instead using an iterative conjugate gradient algorithm. This
method performs well at points where the Jacobian is singular,
and is also suitable for large-scale problems where factoring
the Jacobian matrix could be prohibitively expensive.</p>
</div>
</div>
<div class="section" id="weighted-nonlinear-least-squares">
<h2>Weighted Nonlinear Least-Squares<a class="headerlink" href="#weighted-nonlinear-least-squares" title="Permalink to this heading">¶</a></h2>
<p>Weighted nonlinear least-squares fitting minimizes the function</p>
<div class="math">
<p><img src="_images/math/d555e3f33fc8b1e99a64ba190abb5c5d370dee78.png" alt="\Phi(x) &amp;= {1 \over 2} || f ||_W^2 \\
        &amp;= {1 \over 2} \sum_{i=1}^{n} w_i f_i (x_1, \dots, x_p)^2"/></p>
</div><p>where <img class="math" src="_images/math/8bb90d710f2483236cf508b737cf308fd3311a5c.png" alt="W = \diag(w_1,w_2,...,w_n)"/> is the weighting matrix,
and <img class="math" src="_images/math/38e115599340900e797f168dc5aa536c68b8367d.png" alt="||f||_W^2 = f^T W f"/>.
The weights <img class="math" src="_images/math/ece130da0e1e9c9e66b0053903b5cffae6299256.png" alt="w_i"/> are commonly defined as <img class="math" src="_images/math/13838869480e9999005177447ac34ee219a43dba.png" alt="w_i = 1/\sigma_i^2"/>,
where <img class="math" src="_images/math/1afc114625647181415bffab4b941a8da2855b04.png" alt="\sigma_i"/> is the error in the <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th measurement.
A simple change of variables <img class="math" src="_images/math/d9a510ab5ff82f286357c7bdce9cf4559de0ee12.png" alt="\tilde{f} = W^{1 \over 2} f"/> yields
<img class="math" src="_images/math/a9f43156385e371df205d9af517c0e233c944dce.png" alt="\Phi(x) = {1 \over 2} ||\tilde{f}||^2"/>, which is in the
same form as the unweighted case. The user can either perform this
transform directly on their function residuals and Jacobian, or use
the <a class="reference internal" href="#c.gsl_multifit_nlinear_winit" title="gsl_multifit_nlinear_winit"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_nlinear_winit()</span></code></a> interface which automatically
performs the correct scaling. To manually perform this transformation,
the residuals and Jacobian should be modified according to</p>
<div class="math">
<p><img src="_images/math/48abfdf2f2c15e4cf05e7a1188395aeaf8225b69.png" alt="\tilde{f}_i &amp; = \sqrt{w_i} f_i = {f_i \over \sigma_i} \\
\tilde{J}_{ij} &amp; = \sqrt{w_i} { \partial f_i \over \partial x_j } = { 1 \over \sigma_i} { \partial f_i \over \partial x_j }"/></p>
</div><p>For large systems, the user must perform their own weighting.</p>
</div>
<div class="section" id="tunable-parameters">
<span id="sec-tunable-parameters"></span><h2>Tunable Parameters<a class="headerlink" href="#tunable-parameters" title="Permalink to this heading">¶</a></h2>
<p>The user can tune nearly all aspects of the iteration at allocation
time. For the <code class="code docutils literal notranslate"><span class="pre">gsl_multifit_nlinear</span></code> interface, the user may
modify the <a class="reference internal" href="#c.gsl_multifit_nlinear_parameters" title="gsl_multifit_nlinear_parameters"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_multifit_nlinear_parameters</span></code></a> structure, which is
defined as follows:</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_parameters">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_parameters</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">gsl_multifit_nlinear_trs</span> <span class="o">*</span><span class="n">trs</span><span class="p">;</span>        <span class="o">/*</span> <span class="n">trust</span> <span class="n">region</span> <span class="n">subproblem</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">gsl_multifit_nlinear_scale</span> <span class="o">*</span><span class="n">scale</span><span class="p">;</span>    <span class="o">/*</span> <span class="n">scaling</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">gsl_multifit_nlinear_solver</span> <span class="o">*</span><span class="n">solver</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">solver</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_fdtype</span> <span class="n">fdtype</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">finite</span> <span class="n">difference</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">factor_up</span><span class="p">;</span>                           <span class="o">/*</span> <span class="n">factor</span> <span class="k">for</span> <span class="n">increasing</span> <span class="n">trust</span> <span class="n">radius</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">factor_down</span><span class="p">;</span>                         <span class="o">/*</span> <span class="n">factor</span> <span class="k">for</span> <span class="n">decreasing</span> <span class="n">trust</span> <span class="n">radius</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">avmax</span><span class="p">;</span>                               <span class="o">/*</span> <span class="nb">max</span> <span class="n">allowed</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">h_df</span><span class="p">;</span>                                <span class="o">/*</span> <span class="n">step</span> <span class="n">size</span> <span class="k">for</span> <span class="n">finite</span> <span class="n">difference</span> <span class="n">Jacobian</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">h_fvv</span><span class="p">;</span>                               <span class="o">/*</span> <span class="n">step</span> <span class="n">size</span> <span class="k">for</span> <span class="n">finite</span> <span class="n">difference</span> <span class="n">fvv</span> <span class="o">*/</span>
<span class="p">}</span> <span class="n">gsl_multifit_nlinear_parameters</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<p>For the <code class="code docutils literal notranslate"><span class="pre">gsl_multilarge_nlinear</span></code> interface, the user may
modify the <a class="reference internal" href="#c.gsl_multilarge_nlinear_parameters" title="gsl_multilarge_nlinear_parameters"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_multilarge_nlinear_parameters</span></code></a> structure, which is
defined as follows:</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_parameters">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_parameters</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">gsl_multilarge_nlinear_trs</span> <span class="o">*</span><span class="n">trs</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">trust</span> <span class="n">region</span> <span class="n">subproblem</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">gsl_multilarge_nlinear_scale</span> <span class="o">*</span><span class="n">scale</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">scaling</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">gsl_multilarge_nlinear_solver</span> <span class="o">*</span><span class="n">solver</span><span class="p">;</span> <span class="o">/*</span> <span class="n">solver</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_nlinear_fdtype</span> <span class="n">fdtype</span><span class="p">;</span>        <span class="o">/*</span> <span class="n">finite</span> <span class="n">difference</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">factor_up</span><span class="p">;</span>                            <span class="o">/*</span> <span class="n">factor</span> <span class="k">for</span> <span class="n">increasing</span> <span class="n">trust</span> <span class="n">radius</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">factor_down</span><span class="p">;</span>                          <span class="o">/*</span> <span class="n">factor</span> <span class="k">for</span> <span class="n">decreasing</span> <span class="n">trust</span> <span class="n">radius</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">avmax</span><span class="p">;</span>                                <span class="o">/*</span> <span class="nb">max</span> <span class="n">allowed</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">h_df</span><span class="p">;</span>                                 <span class="o">/*</span> <span class="n">step</span> <span class="n">size</span> <span class="k">for</span> <span class="n">finite</span> <span class="n">difference</span> <span class="n">Jacobian</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">h_fvv</span><span class="p">;</span>                                <span class="o">/*</span> <span class="n">step</span> <span class="n">size</span> <span class="k">for</span> <span class="n">finite</span> <span class="n">difference</span> <span class="n">fvv</span> <span class="o">*/</span>
  <span class="n">size_t</span> <span class="n">max_iter</span><span class="p">;</span>                             <span class="o">/*</span> <span class="n">maximum</span> <span class="n">iterations</span> <span class="k">for</span> <span class="n">trs</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="n">tol</span><span class="p">;</span>                                  <span class="o">/*</span> <span class="n">tolerance</span> <span class="k">for</span> <span class="n">solving</span> <span class="n">trs</span> <span class="o">*/</span>
<span class="p">}</span> <span class="n">gsl_multilarge_nlinear_parameters</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<p>Each of these parameters is discussed in further detail below.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_trs">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trs</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_trs" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The parameter <code class="xref c c-data docutils literal notranslate"><span class="pre">trs</span></code> determines the method used to solve the trust region
subproblem, and may be selected from the following choices,</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_lm">
<a class="reference internal" href="#c.gsl_multifit_nlinear_trs" title="gsl_multifit_nlinear_trs"><span class="n"><span class="pre">gsl_multifit_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trs_lm</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_lm" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_lm">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_trs" title="gsl_multilarge_nlinear_trs"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs_lm</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_lm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This selects the Levenberg-Marquardt algorithm.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_lmaccel">
<a class="reference internal" href="#c.gsl_multifit_nlinear_trs" title="gsl_multifit_nlinear_trs"><span class="n"><span class="pre">gsl_multifit_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trs_lmaccel</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_lmaccel" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_lmaccel">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_trs" title="gsl_multilarge_nlinear_trs"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs_lmaccel</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_lmaccel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This selects the Levenberg-Marquardt algorithm with geodesic
acceleration.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_dogleg">
<a class="reference internal" href="#c.gsl_multifit_nlinear_trs" title="gsl_multifit_nlinear_trs"><span class="n"><span class="pre">gsl_multifit_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trs_dogleg</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_dogleg" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_dogleg">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_trs" title="gsl_multilarge_nlinear_trs"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs_dogleg</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_dogleg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This selects the dogleg algorithm.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_ddogleg">
<a class="reference internal" href="#c.gsl_multifit_nlinear_trs" title="gsl_multifit_nlinear_trs"><span class="n"><span class="pre">gsl_multifit_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trs_ddogleg</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_ddogleg" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_ddogleg">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_trs" title="gsl_multilarge_nlinear_trs"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs_ddogleg</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_ddogleg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This selects the double dogleg algorithm.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_subspace2D">
<a class="reference internal" href="#c.gsl_multifit_nlinear_trs" title="gsl_multifit_nlinear_trs"><span class="n"><span class="pre">gsl_multifit_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trs_subspace2D</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multifit_nlinear_trs_subspace2D" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_subspace2D">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_trs" title="gsl_multilarge_nlinear_trs"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs_subspace2D</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_subspace2D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This selects the 2D subspace algorithm.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_cgst">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_trs" title="gsl_multilarge_nlinear_trs"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs_cgst</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs.gsl_multilarge_nlinear_trs_cgst" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This selects the Steihaug-Toint conjugate gradient algorithm. This
method is available only for large systems.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_scale">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_scale</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_scale" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_scale">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_scale</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_scale" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The parameter <code class="xref c c-data docutils literal notranslate"><span class="pre">scale</span></code> determines the diagonal scaling matrix <img class="math" src="_images/math/63d10e84cf24903abdb7a8b5e36b743c831a7040.png" alt="D"/> and
may be selected from the following choices,</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_scale.gsl_multifit_nlinear_scale_more">
<a class="reference internal" href="#c.gsl_multifit_nlinear_scale" title="gsl_multifit_nlinear_scale"><span class="n"><span class="pre">gsl_multifit_nlinear_scale</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_scale_more</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_scale.gsl_multifit_nlinear_scale_more" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_scale.gsl_multilarge_nlinear_scale_more">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_scale" title="gsl_multilarge_nlinear_scale"><span class="n"><span class="pre">gsl_multilarge_nlinear_scale</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_scale_more</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_scale.gsl_multilarge_nlinear_scale_more" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This damping strategy was suggested by Moré, and
corresponds to <img class="math" src="_images/math/56ebe2bafafb641e8c2d701b9c4ea028ce059f13.png" alt="D^T D = \max(\diag(J^T J))"/>,
in other words the maximum elements of
<img class="math" src="_images/math/f8e4031075a6d9f5fb1ec9e5031b6217274cd713.png" alt="\diag(J^T J)"/> encountered thus far in the iteration.
This choice of <img class="math" src="_images/math/63d10e84cf24903abdb7a8b5e36b743c831a7040.png" alt="D"/> makes the problem scale-invariant,
so that if the model parameters <img class="math" src="_images/math/3efd6fd1c2b0c335484bcd4bf7d5d98b99e619f4.png" alt="x_i"/> are each scaled
by an arbitrary constant, <img class="math" src="_images/math/734e616f63d919f09d560d3ea0fd033891304323.png" alt="\tilde{x}_i = a_i x_i"/>, then
the sequence of iterates produced by the algorithm would
be unchanged. This method can work very well in cases
where the model parameters have widely different scales
(ie: if some parameters are measured in nanometers, while others
are measured in degrees Kelvin). This strategy has been proven
effective on a large class of problems and so it is the library
default, but it may not be the best choice for all problems.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_scale.gsl_multifit_nlinear_scale_levenberg">
<a class="reference internal" href="#c.gsl_multifit_nlinear_scale" title="gsl_multifit_nlinear_scale"><span class="n"><span class="pre">gsl_multifit_nlinear_scale</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_scale_levenberg</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_scale.gsl_multifit_nlinear_scale_levenberg" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_scale.gsl_multilarge_nlinear_scale_levenberg">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_scale" title="gsl_multilarge_nlinear_scale"><span class="n"><span class="pre">gsl_multilarge_nlinear_scale</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_scale_levenberg</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_scale.gsl_multilarge_nlinear_scale_levenberg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This damping strategy was originally suggested by Levenberg, and
corresponds to <img class="math" src="_images/math/f7e72e3520fd4815a71f65711e8c4c73ae915f08.png" alt="D^T D = I"/>. This method has also proven
effective on a large class of problems, but is not scale-invariant.
However, some authors (e.g. Transtrum and Sethna 2012) argue
that this choice is better for problems which are susceptible
to parameter evaporation (ie: parameters go to infinity)</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_scale.gsl_multifit_nlinear_scale_marquardt">
<a class="reference internal" href="#c.gsl_multifit_nlinear_scale" title="gsl_multifit_nlinear_scale"><span class="n"><span class="pre">gsl_multifit_nlinear_scale</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_scale_marquardt</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_scale.gsl_multifit_nlinear_scale_marquardt" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_scale.gsl_multilarge_nlinear_scale_marquardt">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_scale" title="gsl_multilarge_nlinear_scale"><span class="n"><span class="pre">gsl_multilarge_nlinear_scale</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_scale_marquardt</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_scale.gsl_multilarge_nlinear_scale_marquardt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This damping strategy was suggested by Marquardt, and
corresponds to <img class="math" src="_images/math/1663e2757793a8d0ab4257ed07d824c17b6cb365.png" alt="D^T D = \diag(J^T J)"/>. This
method is scale-invariant, but it is generally considered
inferior to both the Levenberg and Moré strategies, though
may work well on certain classes of problems.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_solver">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_solver</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_solver" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_solver">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_solver</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_solver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Solving the trust region subproblem on each iteration almost always
requires the solution of the following linear least squares system</p>
<div class="math">
<p><img src="_images/math/da00ff066889be51b5261367af0f59fb5255aa9f.png" alt="\left[
  \begin{array}{c}
    J \\
    \sqrt{\mu} D
  \end{array}
\right]
\delta =
-
\left[
  \begin{array}{c}
    f \\
    0
  \end{array}
\right]"/></p>
</div><p>The <code class="xref c c-data docutils literal notranslate"><span class="pre">solver</span></code> parameter determines how the system is
solved and can be selected from the following choices:</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_qr">
<a class="reference internal" href="#c.gsl_multifit_nlinear_solver" title="gsl_multifit_nlinear_solver"><span class="n"><span class="pre">gsl_multifit_nlinear_solver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_solver_qr</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_qr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This method solves the system using a rank revealing QR
decomposition of the Jacobian <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/>. This method will
produce reliable solutions in cases where the Jacobian
is rank deficient or near-singular but does require about
twice as many operations as the Cholesky method discussed
below.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_cholesky">
<a class="reference internal" href="#c.gsl_multifit_nlinear_solver" title="gsl_multifit_nlinear_solver"><span class="n"><span class="pre">gsl_multifit_nlinear_solver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_solver_cholesky</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_cholesky" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_solver.gsl_multilarge_nlinear_solver_cholesky">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_solver" title="gsl_multilarge_nlinear_solver"><span class="n"><span class="pre">gsl_multilarge_nlinear_solver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_solver_cholesky</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_solver.gsl_multilarge_nlinear_solver_cholesky" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This method solves the alternate normal equations problem</p>
<div class="math">
<p><img src="_images/math/7b0e82e9f0cfedfee9e1afaa7809486e1383845f.png" alt="\left( J^T J + \mu D^T D \right) \delta = -J^T f"/></p>
</div><p>by using a Cholesky decomposition of the matrix
<img class="math" src="_images/math/073538e99ebf82f46f206190536bdb2e7918db86.png" alt="J^T J + \mu D^T D"/>. This method is faster than the
QR approach, however it is susceptible to numerical instabilities
if the Jacobian matrix is rank deficient or near-singular. In
these cases, an attempt is made to reduce the condition number
of the matrix using Jacobi preconditioning, but for highly
ill-conditioned problems the QR approach is better. If it is
known that the Jacobian matrix is well conditioned, this method
is accurate and will perform faster than the QR approach.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_mcholesky">
<a class="reference internal" href="#c.gsl_multifit_nlinear_solver" title="gsl_multifit_nlinear_solver"><span class="n"><span class="pre">gsl_multifit_nlinear_solver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_solver_mcholesky</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_mcholesky" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_solver.gsl_multilarge_nlinear_solver_mcholesky">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_solver" title="gsl_multilarge_nlinear_solver"><span class="n"><span class="pre">gsl_multilarge_nlinear_solver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_solver_mcholesky</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_solver.gsl_multilarge_nlinear_solver_mcholesky" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This method solves the alternate normal equations problem</p>
<div class="math">
<p><img src="_images/math/7b0e82e9f0cfedfee9e1afaa7809486e1383845f.png" alt="\left( J^T J + \mu D^T D \right) \delta = -J^T f"/></p>
</div><p>by using a modified Cholesky decomposition of the matrix
<img class="math" src="_images/math/073538e99ebf82f46f206190536bdb2e7918db86.png" alt="J^T J + \mu D^T D"/>. This is more suitable for the dogleg
methods where the parameter <img class="math" src="_images/math/42b5f71282808ac7a6f8d463013af3deca344eb8.png" alt="\mu = 0"/>, and the matrix
<img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/> may be ill-conditioned or indefinite causing the standard Cholesky
decomposition to fail. This method is based on Level 2 BLAS
and is thus slower than the standard Cholesky decomposition, which
is based on Level 3 BLAS.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_svd">
<a class="reference internal" href="#c.gsl_multifit_nlinear_solver" title="gsl_multifit_nlinear_solver"><span class="n"><span class="pre">gsl_multifit_nlinear_solver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_solver_svd</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_solver.gsl_multifit_nlinear_solver_svd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This method solves the system using a singular value
decomposition of the Jacobian <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/>. This method will
produce the most reliable solutions for ill-conditioned Jacobians
but is also the slowest solver method.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_fdtype">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_fdtype</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_fdtype" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The parameter <code class="xref c c-data docutils literal notranslate"><span class="pre">fdtype</span></code> specifies whether to use forward or centered
differences when approximating the Jacobian. This is only
used when an analytic Jacobian is not provided to the solver.
This parameter may be set to one of the following choices.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_fdtype.GSL_MULTIFIT_NLINEAR_FWDIFF">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_MULTIFIT_NLINEAR_FWDIFF</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_fdtype.GSL_MULTIFIT_NLINEAR_FWDIFF" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies a forward finite difference to approximate
the Jacobian matrix. The Jacobian matrix will be calculated as</p>
<div class="math">
<p><img src="_images/math/1b077231cd16b31dfb0eecc7d2d8831f9abe180a.png" alt="J_{ij} = {1 \over \Delta_j} \left( f_i(x + \Delta_j e_j) - f_i(x) \right)"/></p>
</div><p>where <img class="math" src="_images/math/38e00ef7258cd52ac29a090604164a82d1021307.png" alt="\Delta_j = h |x_j|"/> and <img class="math" src="_images/math/b6a562c0f463b265fd1ba652c7a2cc9570cef96a.png" alt="e_j"/> is the standard
<img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>-th Cartesian unit basis vector so that
<img class="math" src="_images/math/366fced8c33639f997db06c7bf54f9292b98e976.png" alt="x + \Delta_j e_j"/> represents a small (forward) perturbation of
the <img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>-th parameter by an amount <img class="math" src="_images/math/cbcb2934ce57f3936ebfbb8799fec5460bdc8b02.png" alt="\Delta_j"/>. The perturbation
<img class="math" src="_images/math/cbcb2934ce57f3936ebfbb8799fec5460bdc8b02.png" alt="\Delta_j"/> is proportional to the current value <img class="math" src="_images/math/2e66a38bf7b39b87cc52ebcaa7517718b2c20cca.png" alt="|x_j|"/> which
helps to calculate an accurate Jacobian when the various parameters have
different scale sizes. The value of <img class="math" src="_images/math/aca32b204f928ef3ee8c82cd7a605c4da0c65f18.png" alt="h"/> is specified by the <code class="code docutils literal notranslate"><span class="pre">h_df</span></code>
parameter. The accuracy of this method is <img class="math" src="_images/math/da3bb5376c7c3da02410b7ff6478f4221f294aaf.png" alt="O(h)"/>, and evaluating this
matrix requires an additional <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> function evaluations.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_fdtype.GSL_MULTIFIT_NLINEAR_CTRDIFF">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_MULTIFIT_NLINEAR_CTRDIFF</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_fdtype.GSL_MULTIFIT_NLINEAR_CTRDIFF" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies a centered finite difference to approximate
the Jacobian matrix. The Jacobian matrix will be calculated as</p>
<div class="math">
<p><img src="_images/math/0a2be9c82076e70e874195551b60969c9c15ff71.png" alt="J_{ij} = {1 \over \Delta_j} \left( f_i(x + {1 \over 2} \Delta_j e_j) - f_i(x - {1 \over 2} \Delta_j e_j) \right)"/></p>
</div><p>See above for a description of <img class="math" src="_images/math/cbcb2934ce57f3936ebfbb8799fec5460bdc8b02.png" alt="\Delta_j"/>. The accuracy of this
method is <img class="math" src="_images/math/db58951194397a4c644b8e5824722d8c8b78b913.png" alt="O(h^2)"/>, but evaluating this
matrix requires an additional <img class="math" src="_images/math/ccc9ffb956e3a8e4c7abf30709cae9613ad6b47b.png" alt="2p"/> function evaluations.</p>
</dd></dl>

</dd></dl>

<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">factor_up</span></code></p>
<p>When a step is accepted, the trust region radius will be increased
by this factor. The default value is <img class="math" src="_images/math/eac96ffbc1b2aee2dbf6675ef30fdf2a74a3d82f.png" alt="3"/>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">factor_down</span></code></p>
<p>When a step is rejected, the trust region radius will be decreased
by this factor. The default value is <img class="math" src="_images/math/2a2702de739befc144e6b7371e7f63ac3aeb8bec.png" alt="2"/>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">avmax</span></code></p>
<p>When using geodesic acceleration to solve a nonlinear least squares problem,
an important parameter to monitor is the ratio of the acceleration term
to the velocity term,</p>
<div class="math">
<p><img src="_images/math/f7103932a07de26f57097f6735407001985bd92a.png" alt="{ ||a|| \over ||v|| }"/></p>
</div><p>If this ratio is small, it means the acceleration correction
is contributing very little to the step. This could be because
the problem is not “nonlinear” enough to benefit from
the acceleration. If the ratio is large (<img class="math" src="_images/math/e39b563b998b6ca94e90efb18a27acedda19354f.png" alt="&gt; 1"/>) it
means that the acceleration is larger than the velocity,
which shouldn’t happen since the step represents a truncated
series and so the second order term <img class="math" src="_images/math/ab8ec5d5a907c2d63aba6be0e2e1abbe131f208c.png" alt="a"/> should be smaller than
the first order term <img class="math" src="_images/math/5fdec03022aa06df18d924e8a33c9d7c6db2ebc8.png" alt="v"/> to guarantee convergence.
Therefore any steps with a ratio larger than the parameter
<code class="xref c c-data docutils literal notranslate"><span class="pre">avmax</span></code> are rejected. <code class="xref c c-data docutils literal notranslate"><span class="pre">avmax</span></code> is set to 0.75 by default.
For problems which experience difficulty converging, this threshold
could be lowered.</p>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">h_df</span></code></p>
<p>This parameter specifies the step size for approximating the
Jacobian matrix with finite differences. It is set to
<img class="math" src="_images/math/5acaeb2126a4ef12d6da94b2aab4b27d7b8edd67.png" alt="\sqrt{\epsilon}"/> by default, where <img class="math" src="_images/math/be3df5344ca00c17e18e2e38fde14b3415593780.png" alt="\epsilon"/>
is <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_DBL_EPSILON</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">h_fvv</span></code></p>
<p>When using geodesic acceleration, the user must either supply
a function to calculate <img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/> or the library
can estimate this second directional derivative using a finite
difference method. When using finite differences, the library
must calculate <img class="math" src="_images/math/b34d5a441bb929a3eef3e35354d5a83c4c9eeef3.png" alt="f(x + h v)"/> where <img class="math" src="_images/math/aca32b204f928ef3ee8c82cd7a605c4da0c65f18.png" alt="h"/> represents
a small step in the velocity direction. The parameter
<code class="xref c c-data docutils literal notranslate"><span class="pre">h_fvv</span></code> defines this step size and is set to 0.02 by
default.</p>
</div>
<div class="section" id="initializing-the-solver">
<h2>Initializing the Solver<a class="headerlink" href="#initializing-the-solver" title="Permalink to this heading">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_type">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_type</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This structure specifies the type of algorithm which will be used
to solve a nonlinear least squares problem. It may be selected from the
following choices,</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_type.gsl_multifit_nlinear_trust">
<a class="reference internal" href="#c.gsl_multifit_nlinear_type" title="gsl_multifit_nlinear_type"><span class="n"><span class="pre">gsl_multifit_nlinear_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trust</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_type.gsl_multifit_nlinear_trust" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies a trust region method. It is currently the only implemented
nonlinear least squares method.</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_alloc">
<span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multifit_nlinear_type" title="gsl_multifit_nlinear_type"><span class="n"><span class="pre">gsl_multifit_nlinear_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">T</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multifit_nlinear_parameters" title="gsl_multifit_nlinear_parameters"><span class="n"><span class="pre">gsl_multifit_nlinear_parameters</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_alloc">
<span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_type</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">T</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multilarge_nlinear_parameters" title="gsl_multilarge_nlinear_parameters"><span class="n"><span class="pre">gsl_multilarge_nlinear_parameters</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return a pointer to a newly allocated instance of a
derivative solver of type <a class="reference internal" href="#c.gsl_multilarge_nlinear_alloc" title="T"><code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code></a> for <a class="reference internal" href="#c.gsl_multilarge_nlinear_alloc" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> observations and <a class="reference internal" href="#c.gsl_multilarge_nlinear_alloc" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a>
parameters. The <a class="reference internal" href="#c.gsl_multilarge_nlinear_alloc" title="params"><code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code></a> input specifies a tunable set of
parameters which will affect important details in each iteration
of the trust region subproblem algorithm. It is recommended to start
with the suggested default parameters (see
<a class="reference internal" href="#c.gsl_multifit_nlinear_default_parameters" title="gsl_multifit_nlinear_default_parameters"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_nlinear_default_parameters()</span></code></a> and
<a class="reference internal" href="#c.gsl_multilarge_nlinear_default_parameters" title="gsl_multilarge_nlinear_default_parameters"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multilarge_nlinear_default_parameters()</span></code></a>) and then tune
the parameters once the code is working correctly. See
<a class="reference internal" href="#sec-tunable-parameters"><span class="std std-ref">Tunable Parameters</span></a>.
for descriptions of the various parameters.
For example, the following code creates an instance of a
Levenberg-Marquardt solver for 100 data points and 3 parameters,
using suggested defaults:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">gsl_multifit_nlinear_type</span> <span class="o">*</span> <span class="n">T</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trust</span><span class="p">;</span>
<span class="n">gsl_multifit_nlinear_parameters</span> <span class="n">params</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_default_parameters</span><span class="p">();</span>
<span class="n">gsl_multifit_nlinear_workspace</span> <span class="o">*</span> <span class="n">w</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>The number of observations <a class="reference internal" href="#c.gsl_multilarge_nlinear_alloc" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> must be greater than or equal to
parameters <a class="reference internal" href="#c.gsl_multilarge_nlinear_alloc" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a>.</p>
<p>If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <a class="reference internal" href="err.html#c.GSL_ENOMEM" title="GSL_ENOMEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_ENOMEM</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_default_parameters">
<a class="reference internal" href="#c.gsl_multifit_nlinear_parameters" title="gsl_multifit_nlinear_parameters"><span class="n"><span class="pre">gsl_multifit_nlinear_parameters</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_default_parameters</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_default_parameters" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_default_parameters">
<a class="reference internal" href="#c.gsl_multilarge_nlinear_parameters" title="gsl_multilarge_nlinear_parameters"><span class="n"><span class="pre">gsl_multilarge_nlinear_parameters</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_default_parameters</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_default_parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return a set of recommended default parameters
for use in solving nonlinear least squares problems. The user
can tune each parameter to improve the performance on their
particular problem, see <a class="reference internal" href="#sec-tunable-parameters"><span class="std std-ref">Tunable Parameters</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_multifit_nlinear_fdf" title="gsl_multifit_nlinear_fdf"><span class="n"><span class="pre">gsl_multifit_nlinear_fdf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fdf</span></span>, <span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_init" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_winit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_winit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wts</span></span>, <a class="reference internal" href="#c.gsl_multifit_nlinear_fdf" title="gsl_multifit_nlinear_fdf"><span class="n"><span class="pre">gsl_multifit_nlinear_fdf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fdf</span></span>, <span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_winit" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="#c.gsl_multilarge_nlinear_fdf" title="gsl_multilarge_nlinear_fdf"><span class="n"><span class="pre">gsl_multilarge_nlinear_fdf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fdf</span></span>, <span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions initialize, or reinitialize, an existing workspace <a class="reference internal" href="#c.gsl_multilarge_nlinear_init" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>
to use the system <a class="reference internal" href="#c.gsl_multilarge_nlinear_init" title="fdf"><code class="xref c c-data docutils literal notranslate"><span class="pre">fdf</span></code></a> and the initial guess
<a class="reference internal" href="#c.gsl_multilarge_nlinear_init" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>. See <a class="reference internal" href="#sec-providing-function-minimized"><span class="std std-ref">Providing the Function to be Minimized</span></a>
for a description of the <a class="reference internal" href="#c.gsl_multilarge_nlinear_init" title="fdf"><code class="xref c c-data docutils literal notranslate"><span class="pre">fdf</span></code></a> structure.</p>
<p>Optionally, a weight vector <code class="xref c c-data docutils literal notranslate"><span class="pre">wts</span></code> can be given to perform
a weighted nonlinear regression. Here, the weighting matrix is
<img class="math" src="_images/math/8bb90d710f2483236cf508b737cf308fd3311a5c.png" alt="W = \diag(w_1,w_2,...,w_n)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_free</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_free" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_free</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions free all the memory associated with the workspace <a class="reference internal" href="#c.gsl_multilarge_nlinear_free" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_name" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return a pointer to the name of the solver.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;w is a &#39;</span><span class="si">%s</span><span class="s2">&#39; solver</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_multifit_nlinear_name</span> <span class="p">(</span><span class="n">w</span><span class="p">));</span>
</pre></div>
</div>
<p>would print something like <code class="code docutils literal notranslate"><span class="pre">w</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">'trust-region'</span> <span class="pre">solver</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_trs_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_trs_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_trs_name" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_trs_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_trs_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_trs_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return a pointer to the name of the trust region subproblem
method.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;w is a &#39;</span><span class="si">%s</span><span class="s2">&#39; solver</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_multifit_nlinear_trs_name</span> <span class="p">(</span><span class="n">w</span><span class="p">));</span>
</pre></div>
</div>
<p>would print something like <code class="code docutils literal notranslate"><span class="pre">w</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">'levenberg-marquardt'</span> <span class="pre">solver</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="providing-the-function-to-be-minimized">
<span id="sec-providing-function-minimized"></span><h2>Providing the Function to be Minimized<a class="headerlink" href="#providing-the-function-to-be-minimized" title="Permalink to this heading">¶</a></h2>
<p>The user must provide <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> functions of <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> variables for the
minimization algorithm to operate on.  In order to allow for
arbitrary parameters the functions are defined by the following data
types:</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_fdf">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_fdf</span></span></span><a class="headerlink" href="#c.gsl_multifit_nlinear_fdf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This data type defines a general system of functions with arbitrary parameters,
the corresponding Jacobian matrix of derivatives, and optionally the
second directional derivative of the functions for geodesic acceleration.</p>
<p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*</span> <span class="pre">f)</span> <span class="pre">(const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">x,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params,</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">f)</span></code></p>
<blockquote>
<div><p>This function should store the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> components of the vector
<img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/> in <code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code> for argument <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and arbitrary parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code>,
returning an appropriate error code if the function cannot be computed.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*</span> <span class="pre">df)</span> <span class="pre">(const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">x,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params,</span> <span class="pre">gsl_matrix</span> <span class="pre">*</span> <span class="pre">J)</span></code></p>
<blockquote>
<div><p>This function should store the <code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code>-by-<code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code> matrix result</p>
<div class="math">
<p><img src="_images/math/4d677c4992086f268d885a4f2051947d780b397b.png" alt="J_{ij} = \partial f_i(x) / \partial x_j"/></p>
</div><p>in <code class="xref c c-data docutils literal notranslate"><span class="pre">J</span></code> for argument <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code>
and arbitrary parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code>, returning an appropriate error code if the
matrix cannot be computed. If an analytic Jacobian is unavailable, or too expensive
to compute, this function pointer may be set to <code class="code docutils literal notranslate"><span class="pre">NULL</span></code>, in which
case the Jacobian will be internally computed using finite difference approximations
of the function <code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*</span> <span class="pre">fvv)</span> <span class="pre">(const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">x,</span> <span class="pre">const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">v,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params,</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">fvv)</span></code></p>
<blockquote>
<div><p>When geodesic acceleration is enabled, this function should store the
<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> components of the vector
<img class="math" src="_images/math/dea7d2992fc14c027a89832a58ab8e96f2bf3117.png" alt="f_{vv}(x) = \sum_{\alpha\beta} v_{\alpha} v_{\beta} {\partial \over \partial x_{\alpha}} {\partial \over \partial x_{\beta}} f(x)"/>,
representing second directional derivatives of the function to be minimized,
into the output <code class="xref c c-data docutils literal notranslate"><span class="pre">fvv</span></code>. The parameter vector is provided in <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and
the velocity vector is provided in <code class="xref c c-data docutils literal notranslate"><span class="pre">v</span></code>, both of which have <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>
components. The arbitrary parameters are given in <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code>. If
analytic expressions for <img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/> are unavailable or too difficult
to compute, this function pointer may be set to <code class="code docutils literal notranslate"><span class="pre">NULL</span></code>, in which case
<img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/> will be computed internally using a finite difference
approximation.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></p>
<blockquote>
<div><p>the number of functions, i.e. the number of components of the
vector <code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">p</span></code></p>
<blockquote>
<div><p>the number of independent variables, i.e. the number of components of
the vector <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">params</span></code></p>
<blockquote>
<div><p>a pointer to the arbitrary parameters of the function.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nevalf</span></code></p>
<blockquote>
<div><p>This does not need to be set by the user. It counts the number of
function evaluations and is initialized by the <code class="code docutils literal notranslate"><span class="pre">_init</span></code> function.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nevaldf</span></code></p>
<blockquote>
<div><p>This does not need to be set by the user. It counts the number of
Jacobian evaluations and is initialized by the <code class="code docutils literal notranslate"><span class="pre">_init</span></code> function.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nevalfvv</span></code></p>
<blockquote>
<div><p>This does not need to be set by the user. It counts the number of
<img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/> evaluations and is initialized by the <code class="code docutils literal notranslate"><span class="pre">_init</span></code> function.</p>
</div></blockquote>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_fdf">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_fdf</span></span></span><a class="headerlink" href="#c.gsl_multilarge_nlinear_fdf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This data type defines a general system of functions with arbitrary parameters,
a function to compute <img class="math" src="_images/math/f57a4296462c42fefce883993b1021d34ad79dc9.png" alt="J u"/> or <img class="math" src="_images/math/32ff04d3dfc6082bf0464393e614784d955ffa2c.png" alt="J^T u"/> for a given vector <img class="math" src="_images/math/71fb5a1cc0758ba70654e6dc934c374032656d2f.png" alt="u"/>,
the normal equations matrix <img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/>,
and optionally the second directional derivative of the functions for geodesic acceleration.</p>
<p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*</span> <span class="pre">f)</span> <span class="pre">(const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">x,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params,</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">f)</span></code></p>
<blockquote>
<div><p>This function should store the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> components of the vector
<img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/> in <code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code> for argument <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and arbitrary parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code>,
returning an appropriate error code if the function cannot be computed.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*</span> <span class="pre">df)</span> <span class="pre">(CBLAS_TRANSPOSE_t</span> <span class="pre">TransJ,</span> <span class="pre">const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">x,</span> <span class="pre">const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">u,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params,</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">v,</span> <span class="pre">gsl_matrix</span> <span class="pre">*</span> <span class="pre">JTJ)</span></code></p>
<blockquote>
<div><p>If <code class="xref c c-data docutils literal notranslate"><span class="pre">TransJ</span></code> is equal to <code class="code docutils literal notranslate"><span class="pre">CblasNoTrans</span></code>, then this function should
compute the matrix-vector product <img class="math" src="_images/math/f57a4296462c42fefce883993b1021d34ad79dc9.png" alt="J u"/> and store the result in <code class="xref c c-data docutils literal notranslate"><span class="pre">v</span></code>.
If <code class="xref c c-data docutils literal notranslate"><span class="pre">TransJ</span></code> is equal to <code class="code docutils literal notranslate"><span class="pre">CblasTrans</span></code>, then this function should
compute the matrix-vector product <img class="math" src="_images/math/32ff04d3dfc6082bf0464393e614784d955ffa2c.png" alt="J^T u"/> and store the result in <code class="xref c c-data docutils literal notranslate"><span class="pre">v</span></code>.
Additionally, the normal equations matrix <img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/> should be stored in the
lower half of <code class="xref c c-data docutils literal notranslate"><span class="pre">JTJ</span></code>. The input matrix <code class="xref c c-data docutils literal notranslate"><span class="pre">JTJ</span></code> could be set to <code class="code docutils literal notranslate"><span class="pre">NULL</span></code>,
for example by iterative methods which do not require this matrix, so the user
should check for this prior to constructing the matrix.
The input <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code> contains the arbitrary parameters.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*</span> <span class="pre">fvv)</span> <span class="pre">(const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">x,</span> <span class="pre">const</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">v,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params,</span> <span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">fvv)</span></code></p>
<blockquote>
<div><p>When geodesic acceleration is enabled, this function should store the
<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> components of the vector
<img class="math" src="_images/math/dea7d2992fc14c027a89832a58ab8e96f2bf3117.png" alt="f_{vv}(x) = \sum_{\alpha\beta} v_{\alpha} v_{\beta} {\partial \over \partial x_{\alpha}} {\partial \over \partial x_{\beta}} f(x)"/>,
representing second directional derivatives of the function to be minimized,
into the output <code class="xref c c-data docutils literal notranslate"><span class="pre">fvv</span></code>. The parameter vector is provided in <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and
the velocity vector is provided in <code class="xref c c-data docutils literal notranslate"><span class="pre">v</span></code>, both of which have <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>
components. The arbitrary parameters are given in <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code>. If
analytic expressions for <img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/> are unavailable or too difficult
to compute, this function pointer may be set to <code class="code docutils literal notranslate"><span class="pre">NULL</span></code>, in which case
<img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/> will be computed internally using a finite difference
approximation.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></p>
<blockquote>
<div><p>the number of functions, i.e. the number of components of the
vector <code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">p</span></code></p>
<blockquote>
<div><p>the number of independent variables, i.e. the number of components of
the vector <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">params</span></code></p>
<blockquote>
<div><p>a pointer to the arbitrary parameters of the function.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nevalf</span></code></p>
<blockquote>
<div><p>This does not need to be set by the user. It counts the number of
function evaluations and is initialized by the <code class="code docutils literal notranslate"><span class="pre">_init</span></code> function.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nevaldfu</span></code></p>
<blockquote>
<div><p>This does not need to be set by the user. It counts the number of
Jacobian matrix-vector evaluations (<img class="math" src="_images/math/f57a4296462c42fefce883993b1021d34ad79dc9.png" alt="J u"/> or <img class="math" src="_images/math/32ff04d3dfc6082bf0464393e614784d955ffa2c.png" alt="J^T u"/>) and
is initialized by the <code class="code docutils literal notranslate"><span class="pre">_init</span></code> function.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nevaldf2</span></code></p>
<blockquote>
<div><p>This does not need to be set by the user. It counts the number of
<img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/> evaluations and is initialized by the <code class="code docutils literal notranslate"><span class="pre">_init</span></code> function.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nevalfvv</span></code></p>
<blockquote>
<div><p>This does not need to be set by the user. It counts the number of
<img class="math" src="_images/math/e20f84eae577d28149ec1573efe4d8852c522c77.png" alt="f_{vv}(x)"/> evaluations and is initialized by the <code class="code docutils literal notranslate"><span class="pre">_init</span></code> function.</p>
</div></blockquote>
</dd></dl>

<p>Note that when fitting a non-linear model against experimental data,
the data is passed to the functions above using the
<code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code> argument and the trial best-fit parameters through the
<code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> argument.</p>
</div>
<div class="section" id="iteration">
<h2>Iteration<a class="headerlink" href="#iteration" title="Permalink to this heading">¶</a></h2>
<p>The following functions drive the iteration of each algorithm.  Each
function performs one iteration of the trust region method and updates
the state of the solver.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_iterate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_iterate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_iterate" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_iterate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_iterate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_iterate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions perform a single iteration of the solver <a class="reference internal" href="#c.gsl_multilarge_nlinear_iterate" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>.  If
the iteration encounters an unexpected problem then an error code will
be returned.  The solver workspace maintains a current estimate of the
best-fit parameters at all times.</p>
</dd></dl>

<p>The solver workspace <code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code> contains the following entries, which can
be used to track the progress of the solution:</p>
<p><code class="code docutils literal notranslate"><span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">x</span></code></p>
<blockquote>
<div><p>The current position, length <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">f</span></code></p>
<blockquote>
<div><p>The function residual vector at the current position <img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/>, length
<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">gsl_matrix</span> <span class="pre">*</span> <span class="pre">J</span></code></p>
<blockquote>
<div><p>The Jacobian matrix at the current position <img class="math" src="_images/math/1654c1fca6c6dda9d183f01caf4821a3d2547b04.png" alt="J(x)"/>, size
<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> (only for <code class="code docutils literal notranslate"><span class="pre">gsl_multifit_nlinear</span></code> interface).</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">dx</span></code></p>
<blockquote>
<div><p>The difference between the current position and the previous position,
i.e. the last step <img class="math" src="_images/math/e0991156a224047b35453a4d365526b09ffe5746.png" alt="\delta"/>, taken as a vector, length <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>.</p>
</div></blockquote>
<p>These quantities can be accessed with the following functions,</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_position">
<a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_position</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_position" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_position">
<a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_position</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_position" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return the current position <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> (i.e. best-fit
parameters) of the solver <a class="reference internal" href="#c.gsl_multilarge_nlinear_position" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_residual">
<a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_residual</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_residual" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_residual">
<a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_residual</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_residual" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return the current residual vector <img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/> of the
solver <a class="reference internal" href="#c.gsl_multilarge_nlinear_residual" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>.  For weighted systems, the residual vector includes the
weighting factor <img class="math" src="_images/math/c974ade6affa87d8289573c833828355d1edf572.png" alt="\sqrt{W}"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_jac">
<a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_jac</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_jac" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a pointer to the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> Jacobian matrix for the
current iteration of the solver <a class="reference internal" href="#c.gsl_multifit_nlinear_jac" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>. This function is available only for the
<code class="code docutils literal notranslate"><span class="pre">gsl_multifit_nlinear</span></code> interface.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_niter">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_niter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_niter" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_niter">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_niter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_niter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return the number of iterations performed so far.
The iteration counter is updated on each call to the
<code class="code docutils literal notranslate"><span class="pre">_iterate</span></code> functions above, and reset to 0 in the
<code class="code docutils literal notranslate"><span class="pre">_init</span></code> functions.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_rcond">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_rcond</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rcond</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_rcond" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_rcond">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_rcond</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rcond</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_rcond" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function estimates the reciprocal condition number
of the Jacobian matrix at the current position <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> and
stores it in <a class="reference internal" href="#c.gsl_multilarge_nlinear_rcond" title="rcond"><code class="xref c c-data docutils literal notranslate"><span class="pre">rcond</span></code></a>. The computed value is only an estimate
to give the user a guideline as to the conditioning of their particular
problem. Its calculation is based on which factorization
method is used (Cholesky, QR, or SVD).</p>
<ul class="simple">
<li><p>For the Cholesky solver, the matrix <img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/> is factored at each
iteration. Therefore this function will estimate the 1-norm condition number
<img class="math" src="_images/math/6aead96f2706bfcbf5206850ae1922124d672521.png" alt="rcond^2 = 1/(||J^T J||_1 \cdot ||(J^T J)^{-1}||_1)"/></p></li>
<li><p>For the QR solver, <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/> is factored as <img class="math" src="_images/math/ad6792dfb3a79356fbeca0834e0160950601023c.png" alt="J = Q R"/> at each
iteration. For simplicity, this function calculates the 1-norm conditioning of
only the <img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> factor, <img class="math" src="_images/math/b7b1a582bc48673b0420870bec13cd4eb6667756.png" alt="rcond = 1 / (||R||_1 \cdot ||R^{-1}||_1)"/>.
This can be computed efficiently since <img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> is upper triangular.</p></li>
<li><p>For the SVD solver, in order to efficiently solve the trust region
subproblem, the matrix which is factored is <img class="math" src="_images/math/c2d73599d7eeb3a453b3ed17c667997506e52b13.png" alt="J D^{-1}"/>, instead of
<img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/> itself. The resulting singular values are used to provide
the 2-norm reciprocal condition number, as <img class="math" src="_images/math/4c7a9fff7b181b7ac366f40331c94d40493a2bb5.png" alt="rcond = \sigma_{min} / \sigma_{max}"/>.
Note that when using Moré scaling, <img class="math" src="_images/math/d31fa3d1ee995e079e8f78286803e10f62d56e23.png" alt="D \ne I"/> and the resulting
<a class="reference internal" href="#c.gsl_multilarge_nlinear_rcond" title="rcond"><code class="xref c c-data docutils literal notranslate"><span class="pre">rcond</span></code></a> estimate may be significantly different from the true
<a class="reference internal" href="#c.gsl_multilarge_nlinear_rcond" title="rcond"><code class="xref c c-data docutils literal notranslate"><span class="pre">rcond</span></code></a> of <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/> itself.</p></li>
</ul>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_avratio">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_avratio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_avratio" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_avratio">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_avratio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_avratio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the current ratio <img class="math" src="_images/math/cb81dd26a405c69cde716c83e7ad318b440cb47e.png" alt="|a| / |v|"/> of the acceleration correction term to
the velocity step term. The acceleration term is computed only by the
<code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_multifit_nlinear_trs_lmaccel</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_multilarge_nlinear_trs_lmaccel</span></code> methods, so
this ratio will be zero for other TRS methods.</p>
</dd></dl>

</div>
<div class="section" id="testing-for-convergence">
<span id="index-6"></span><h2>Testing for Convergence<a class="headerlink" href="#testing-for-convergence" title="Permalink to this heading">¶</a></h2>
<p>A minimization procedure should stop when one of the following conditions is
true:</p>
<ul class="simple">
<li><p>A minimum has been found to within the user-specified precision.</p></li>
<li><p>A user-specified maximum number of iterations has been reached.</p></li>
<li><p>An error has occurred.</p></li>
</ul>
<p>The handling of these conditions is under user control.  The functions
below allow the user to test the current estimate of the best-fit
parameters in several standard ways.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_test">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_test</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">xtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">gtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ftol</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_test" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_test">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_test</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">xtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">gtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ftol</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_test" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions test for convergence of the minimization method
using the following criteria:</p>
<ul>
<li><p>Testing for a small step size relative to the current parameter vector</p>
<div class="math">
<p><img src="_images/math/0d95181014c92a3f3a151bb040c0b854781a1445.png" alt="|\delta_i| \le xtol (|x_i| + xtol)"/></p>
</div><p>for each <img class="math" src="_images/math/f4786f2e924d0d79244eb15e311468e1d90752bb.png" alt="0 &lt;= i &lt; p"/>. Each element of the step vector <img class="math" src="_images/math/e0991156a224047b35453a4d365526b09ffe5746.png" alt="\delta"/>
is tested individually in case the different parameters have widely
different scales. Adding <a class="reference internal" href="#c.gsl_multilarge_nlinear_test" title="xtol"><code class="xref c c-data docutils literal notranslate"><span class="pre">xtol</span></code></a> to <img class="math" src="_images/math/8e68e298082d4e69f49f7c3cb167d85c614880dc.png" alt="|x_i|"/> helps the test avoid
breaking down in situations where the true solution value <img class="math" src="_images/math/056a8d87d19b5245e4b90891fe38f45f41715f43.png" alt="x_i = 0"/>.
If this test succeeds, <a class="reference internal" href="#c.gsl_multilarge_nlinear_test" title="info"><code class="xref c c-data docutils literal notranslate"><span class="pre">info</span></code></a> is set to 1 and the function
returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SUCCESS</span></code>.</p>
<p>A general guideline for selecting the step tolerance is to choose
<img class="math" src="_images/math/f6420e129e8e954a83bd3fd5e3bfe4dfce00b2a7.png" alt="xtol = 10^{-d}"/> where <img class="math" src="_images/math/92f093ef8e67b2293db7509b06c7817f327f445c.png" alt="d"/> is the number of accurate
decimal digits desired in the solution <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>. See Dennis and
Schnabel for more information.</p>
</li>
<li><p>Testing for a small gradient (<img class="math" src="_images/math/9702432f516191bd8e5a86c82d0918d9ca7c776c.png" alt="g = \nabla \Phi(x) = J^T f"/>)
indicating a local function minimum:</p>
<div class="math">
<p><img src="_images/math/6fb69272cfb4cca23acf490dfa5d01b825fcdeef.png" alt="\max_i |g_i \times \max(x_i, 1)| \le gtol \times \max(\Phi(x), 1)"/></p>
</div><p>This expression tests whether the ratio
<img class="math" src="_images/math/40dde08e35b5b2eb0498c9a23c3400806ae19a51.png" alt="(\nabla \Phi)_i x_i / \Phi"/> is small. Testing this scaled gradient
is a better than <img class="math" src="_images/math/ef81d8d651cb0f5b2f27d763ff0a1421d7b712a9.png" alt="\nabla \Phi"/> alone since it is a dimensionless
quantity and so independent of the scale of the problem. The
<code class="code docutils literal notranslate"><span class="pre">max</span></code> arguments help ensure the test doesn’t break down in
regions where <img class="math" src="_images/math/3efd6fd1c2b0c335484bcd4bf7d5d98b99e619f4.png" alt="x_i"/> or <img class="math" src="_images/math/78a97ae9d36889f1ac61f883c2d4de8ff8ded1d7.png" alt="\Phi(x)"/> are close to 0.
If this test succeeds, <a class="reference internal" href="#c.gsl_multilarge_nlinear_test" title="info"><code class="xref c c-data docutils literal notranslate"><span class="pre">info</span></code></a> is set to 2 and the function
returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SUCCESS</span></code>.</p>
<p>A general guideline for choosing the gradient tolerance is to set
<code class="code docutils literal notranslate"><span class="pre">gtol</span> <span class="pre">=</span> <span class="pre">GSL_DBL_EPSILON^(1/3)</span></code>. See Dennis and Schnabel for
more information.</p>
</li>
</ul>
<p>If none of the tests succeed, <a class="reference internal" href="#c.gsl_multilarge_nlinear_test" title="info"><code class="xref c c-data docutils literal notranslate"><span class="pre">info</span></code></a> is set to 0 and the
function returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_CONTINUE</span></code>, indicating further iterations
are required.</p>
</dd></dl>

</div>
<div class="section" id="high-level-driver">
<h2>High Level Driver<a class="headerlink" href="#high-level-driver" title="Permalink to this heading">¶</a></h2>
<p>These routines provide a high level wrapper that combines the iteration
and convergence testing for easy use.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">maxiter</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">xtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">gtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ftol</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="lls.html#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">callback_params</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span>, <span class="n"><span class="pre">gsl_multifit_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_driver" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">maxiter</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">xtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">gtol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ftol</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="lls.html#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">callback_params</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span>, <span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions iterate the nonlinear least squares solver <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a> for a
maximum of <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="maxiter"><code class="xref c c-data docutils literal notranslate"><span class="pre">maxiter</span></code></a> iterations. After each iteration, the system is
tested for convergence with the error tolerances <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="xtol"><code class="xref c c-data docutils literal notranslate"><span class="pre">xtol</span></code></a>, <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="gtol"><code class="xref c c-data docutils literal notranslate"><span class="pre">gtol</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="ftol"><code class="xref c c-data docutils literal notranslate"><span class="pre">ftol</span></code></a>.
Additionally, the user may supply a callback function <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="callback"><code class="xref c c-data docutils literal notranslate"><span class="pre">callback</span></code></a>
which is called after each iteration, so that the user may save or print
relevant quantities for each iteration. The parameter <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="callback_params"><code class="xref c c-data docutils literal notranslate"><span class="pre">callback_params</span></code></a>
is passed to the <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="callback"><code class="xref c c-data docutils literal notranslate"><span class="pre">callback</span></code></a> function. The parameters <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="callback"><code class="xref c c-data docutils literal notranslate"><span class="pre">callback</span></code></a>
and <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="callback_params"><code class="xref c c-data docutils literal notranslate"><span class="pre">callback_params</span></code></a> may be set to <code class="code docutils literal notranslate"><span class="pre">NULL</span></code> to disable this feature.
Upon successful convergence, the function returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SUCCESS</span></code>
and sets <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="info"><code class="xref c c-data docutils literal notranslate"><span class="pre">info</span></code></a> to the reason for convergence (see
<a class="reference internal" href="#c.gsl_multifit_nlinear_test" title="gsl_multifit_nlinear_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_nlinear_test()</span></code></a>). If the function has not
converged after <a class="reference internal" href="#c.gsl_multilarge_nlinear_driver" title="maxiter"><code class="xref c c-data docutils literal notranslate"><span class="pre">maxiter</span></code></a> iterations, <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EMAXITER</span></code> is
returned. In rare cases, during an iteration the algorithm may
be unable to find a new acceptable step <img class="math" src="_images/math/e0991156a224047b35453a4d365526b09ffe5746.png" alt="\delta"/> to take. In
this case, <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_ENOPROG</span></code> is returned indicating no further
progress can be made. If your problem is having difficulty converging,
see <a class="reference internal" href="#sec-nlinear-troubleshooting"><span class="std std-ref">Troubleshooting</span></a> for further guidance.</p>
</dd></dl>

</div>
<div class="section" id="covariance-matrix-of-best-fit-parameters">
<span id="index-7"></span><h2>Covariance matrix of best fit parameters<a class="headerlink" href="#covariance-matrix-of-best-fit-parameters" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_nlinear_covar">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_nlinear_covar</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">J</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">epsrel</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">covar</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_nlinear_covar" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_nlinear_covar">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_nlinear_covar</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">covar</span></span>, <span class="n"><span class="pre">gsl_multilarge_nlinear_workspace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_nlinear_covar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the covariance matrix of best-fit parameters
using the Jacobian matrix <code class="xref c c-data docutils literal notranslate"><span class="pre">J</span></code> and stores it in <a class="reference internal" href="#c.gsl_multilarge_nlinear_covar" title="covar"><code class="xref c c-data docutils literal notranslate"><span class="pre">covar</span></code></a>.
The parameter <code class="xref c c-data docutils literal notranslate"><span class="pre">epsrel</span></code> is used to remove linear-dependent columns
when <code class="xref c c-data docutils literal notranslate"><span class="pre">J</span></code> is rank deficient.</p>
<p>The covariance matrix is given by,</p>
<div class="math">
<p><img src="_images/math/2b13843baf4582c4f31539a36670df87ba08134b.png" alt="C = (J^T J)^{-1}"/></p>
</div><p>or in the weighted case,</p>
<div class="math">
<p><img src="_images/math/ac084b5b99b1d772fff5994babd8cafa07315078.png" alt="C = (J^T W J)^{-1}"/></p>
</div><p>and is computed using the factored form of the Jacobian (Cholesky, QR, or SVD).
Any columns of <img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> which satisfy</p>
<div class="math">
<p><img src="_images/math/d01e4fcecedeb55a790347a850f5a98c4614d74f.png" alt="|R_{kk}| \leq epsrel |R_{11}|"/></p>
</div><p>are considered linearly-dependent and are excluded from the covariance
matrix (the corresponding rows and columns of the covariance matrix are
set to zero).</p>
<p>If the minimisation uses the weighted least-squares function
<img class="math" src="_images/math/d90a46e18b7f1a24c3c4f25cd8a15139d1d919b1.png" alt="f_i = (Y(x, t_i) - y_i) / \sigma_i"/> then the covariance
matrix above gives the statistical error on the best-fit parameters
resulting from the Gaussian errors <img class="math" src="_images/math/1afc114625647181415bffab4b941a8da2855b04.png" alt="\sigma_i"/> on
the underlying data <img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/>.  This can be verified from the relation
<img class="math" src="_images/math/082eb0686b972896b29a17f06652ac32cc1f1d69.png" alt="\delta f = J \delta c"/> and the fact that the fluctuations in <img class="math" src="_images/math/297ac74049e250d35993e62353e189c7bfda5398.png" alt="f"/>
from the data <img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/> are normalised by <img class="math" src="_images/math/1afc114625647181415bffab4b941a8da2855b04.png" alt="\sigma_i"/> and
so satisfy</p>
<div class="math">
<p><img src="_images/math/b86b041f022960192347cffdca0a58053d14c615.png" alt="\langle \delta f \delta f^T \rangle = I"/></p>
</div><p>For an unweighted least-squares function <img class="math" src="_images/math/29223e92485c5b9547b60afd79e00649e1f2ffcc.png" alt="f_i = (Y(x, t_i) - y_i)"/>
the covariance matrix above should be multiplied by the variance
of the residuals about the best-fit <img class="math" src="_images/math/124d6bc38a2431daba120059fe97a8437b174b22.png" alt="\sigma^2 = \sum (y_i - Y(x,t_i))^2 / (n-p)"/>
to give the variance-covariance
matrix <img class="math" src="_images/math/d6d3480b2851c7075d684f5010cdfa3723749d6d.png" alt="\sigma^2 C"/>.  This estimates the statistical error on the
best-fit parameters from the scatter of the underlying data.</p>
<p>For more information about covariance matrices see
<a class="reference internal" href="lls.html#sec-lls-overview"><span class="std std-ref">Linear Least-Squares Overview</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="troubleshooting">
<span id="sec-nlinear-troubleshooting"></span><h2>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permalink to this heading">¶</a></h2>
<p>When developing a code to solve a nonlinear least squares problem,
here are a few considerations to keep in mind.</p>
<ol class="arabic simple">
<li><p>The most common difficulty is the accurate implementation of the Jacobian
matrix. If the analytic Jacobian is not properly provided to the
solver, this can hinder and many times prevent convergence of the method.
When developing a new nonlinear least squares code, it often helps
to compare the program output with the internally computed finite
difference Jacobian and the user supplied analytic Jacobian. If there
is a large difference in coefficients, it is likely the analytic
Jacobian is incorrectly implemented.</p></li>
<li><p>If your code is having difficulty converging, the next thing to
check is the starting point provided to the solver. The methods
of this chapter are local methods, meaning if you provide a starting
point far away from the true minimum, the method may converge to
a local minimum or not converge at all. Sometimes it is possible
to solve a linearized approximation to the nonlinear problem,
and use the linear solution as the starting point to the nonlinear
problem.</p></li>
<li><p>If the various parameters of the coefficient vector <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>
vary widely in magnitude, then the problem is said to be badly scaled.
The methods of this chapter do attempt to automatically rescale
the elements of <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> to have roughly the same order of magnitude,
but in extreme cases this could still cause problems for convergence.
In these cases it is recommended for the user to scale their
parameter vector <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> so that each parameter spans roughly the
same range, say <img class="math" src="_images/math/9d7700522727dac61e0f0c6d894326947027e00f.png" alt="[-1,1]"/>. The solution vector can be backscaled
to recover the original units of the problem.</p></li>
</ol>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<p>The following example programs demonstrate the nonlinear least
squares fitting capabilities.</p>
<div class="section" id="exponential-fitting-example">
<h3>Exponential Fitting Example<a class="headerlink" href="#exponential-fitting-example" title="Permalink to this heading">¶</a></h3>
<p>The following example program fits a weighted exponential model with
background to experimental data, <img class="math" src="_images/math/58b71684425982d4fc3ae877334cdccd604c1095.png" alt="Y = A \exp(-\lambda t) + b"/>. The
first part of the program sets up the functions <code class="xref c c-func docutils literal notranslate"><span class="pre">expb_f()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">expb_df()</span></code> to calculate the model and its Jacobian.  The appropriate
fitting function is given by,</p>
<div class="math">
<p><img src="_images/math/8159094284c1fb8427cedb5cbe7e599c90cd9647.png" alt="f_i = (A \exp(-\lambda t_i) + b) - y_i"/></p>
</div><p>where we have chosen <img class="math" src="_images/math/a50a516fab53a3cc7784425d2aee9e5b81bf4126.png" alt="t_i = i T / (N - 1)"/>, where <img class="math" src="_images/math/cb5c0921ee22e878437766648c5925b76e462235.png" alt="N"/> is the number
of data points fitted, so that <img class="math" src="_images/math/321a2a17eea364029addadcd13c41b1d9fb98a0f.png" alt="t_i \in [0, T]"/>. The Jacobian matrix <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/> is
the derivative of these functions with respect to the three parameters
(<img class="math" src="_images/math/fe895c925fafcf3161c4d10b14fb00b979c0015f.png" alt="A"/>, <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/>, <img class="math" src="_images/math/b9e7a11d6c55d13df40be0f0e33a142fd09d27af.png" alt="b"/>).  It is given by,</p>
<div class="math">
<p><img src="_images/math/31447f1c557c5b59c65df2f83e6c34600edee55a.png" alt="J_{ij} = {\partial f_i \over \partial x_j}"/></p>
</div><p>where <img class="math" src="_images/math/6c1b00de0931ca928d7e2a8b15320ed6efdfcdbc.png" alt="x_0 = A"/>, <img class="math" src="_images/math/fbe2cbfea8be4a9ba806fc4ecddf1a8a2e5bcd51.png" alt="x_1 = \lambda"/> and <img class="math" src="_images/math/6a00acdd3a9dca88b18d052346c684f475b6ec49.png" alt="x_2 = b"/>.
The <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th row of the Jacobian is therefore</p>
<div class="math">
<p><img src="_images/math/12ef9308ec8a657353d18edaa918cf1180f64c44.png" alt="J_{i\cdot} =
\left(
  \begin{array}{ccc}
    \exp(-\lambda t_i) &amp; -t_i A \exp(-\lambda t_i) &amp; 1
  \end{array}
\right)"/></p>
</div><p>The main part of the program sets up a Levenberg-Marquardt solver and
some simulated random data. The data uses the known parameters
(5.0,1.5,1.0) combined with Gaussian noise (standard deviation = 0.1)
with a maximum time <img class="math" src="_images/math/4e93804ada20bd79f88880061bab28ffb6630138.png" alt="T = 3"/> and <img class="math" src="_images/math/f01259482a433eabc00f2a3b9cfecced01431aa1.png" alt="N = 100"/> timesteps.
The initial guess for the parameters is
chosen as (1.0, 1.0, 0.0). The iteration terminates when the relative
change in x is smaller than <img class="math" src="_images/math/c3e8f2d7dff6187d2d687bcaffa316a72fae5e31.png" alt="10^{-8}"/>, or when the magnitude of
the gradient falls below <img class="math" src="_images/math/c3e8f2d7dff6187d2d687bcaffa316a72fae5e31.png" alt="10^{-8}"/>. Here are the results of running
the program:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span>  <span class="mi">0</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">1.0000</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.0000</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0000</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>      <span class="n">inf</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">88.4448</span>
<span class="nb">iter</span>  <span class="mi">1</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.5109</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">2.5258</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0704</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">26.2686</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">24.0646</span>
<span class="nb">iter</span>  <span class="mi">2</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.8565</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.7442</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.1669</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">23.7470</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">11.9797</span>
<span class="nb">iter</span>  <span class="mi">3</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.9356</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.5713</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0767</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">17.5849</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.7355</span>
<span class="nb">iter</span>  <span class="mi">4</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.8678</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4838</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0252</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">16.3428</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.5000</span>
<span class="nb">iter</span>  <span class="mi">5</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.8118</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4481</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0076</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.7925</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.4786</span>
<span class="nb">iter</span>  <span class="mi">6</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.7983</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4404</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0041</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.5840</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.4778</span>
<span class="nb">iter</span>  <span class="mi">7</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.7967</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4395</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0037</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.5396</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.4778</span>
<span class="nb">iter</span>  <span class="mi">8</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.7965</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4394</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0037</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.5344</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.4778</span>
<span class="nb">iter</span>  <span class="mi">9</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.7965</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4394</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0037</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.5339</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.4778</span>
<span class="nb">iter</span> <span class="mi">10</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.7965</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4394</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0037</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.5339</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.4778</span>
<span class="nb">iter</span> <span class="mi">11</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">4.7965</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.4394</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0037</span><span class="p">,</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.5339</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.4778</span>
<span class="n">summary</span> <span class="kn">from</span> <span class="nn">method</span> <span class="s1">&#39;trust-region/levenberg-marquardt&#39;</span>
<span class="n">number</span> <span class="n">of</span> <span class="n">iterations</span><span class="p">:</span> <span class="mi">11</span>
<span class="n">function</span> <span class="n">evaluations</span><span class="p">:</span> <span class="mi">16</span>
<span class="n">Jacobian</span> <span class="n">evaluations</span><span class="p">:</span> <span class="mi">12</span>
<span class="n">reason</span> <span class="k">for</span> <span class="n">stopping</span><span class="p">:</span> <span class="n">small</span> <span class="n">gradient</span>
<span class="n">initial</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">88.444756</span>
<span class="n">final</span>   <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">10.477801</span>
<span class="n">chisq</span><span class="o">/</span><span class="n">dof</span> <span class="o">=</span> <span class="mf">1.1318</span>
<span class="n">A</span>      <span class="o">=</span> <span class="mf">4.79653</span> <span class="o">+/-</span> <span class="mf">0.18704</span>
<span class="k">lambda</span> <span class="o">=</span> <span class="mf">1.43937</span> <span class="o">+/-</span> <span class="mf">0.07390</span>
<span class="n">b</span>      <span class="o">=</span> <span class="mf">1.00368</span> <span class="o">+/-</span> <span class="mf">0.03473</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">success</span>
</pre></div>
</div>
<p>The approximate values of the parameters are found correctly, and the
chi-squared value indicates a good fit (the chi-squared per degree of
freedom is approximately 1).  In this case the errors on the parameters
can be estimated from the square roots of the diagonal elements of the
covariance matrix. If the chi-squared value shows a poor fit (i.e.
<img class="math" src="_images/math/070c2b78a1b9a733f17f7faa21158607420c1c30.png" alt="\chi^2/(n-p) \gg 1"/>
then the error estimates obtained from the
covariance matrix will be too small.  In the example program the error estimates
are multiplied by <img class="math" src="_images/math/ba78757fa5f4a0230ccf498a82bde76c052cca60.png" alt="\sqrt{\chi^2/(n-p)}"/>
in this case, a common way of increasing the
errors for a poor fit.  Note that a poor fit will result from the use
of an inappropriate model, and the scaled error estimates may then
be outside the range of validity for Gaussian errors.</p>
<p>Additionally, we see that the condition number of <img class="math" src="_images/math/1654c1fca6c6dda9d183f01caf4821a3d2547b04.png" alt="J(x)"/> stays
reasonably small throughout the iteration. This indicates we could
safely switch to the Cholesky solver for speed improvement,
although this particular system is too small to really benefit.</p>
<p><a class="reference internal" href="#fig-fit-exp"><span class="std std-numref">Fig. 36</span></a> shows the fitted curve with the original data.</p>
<div class="figure align-default" id="id1">
<span id="fig-fit-exp"></span><a class="reference internal image-reference" href="_images/fit-exp.png"><img alt="_images/fit-exp.png" src="_images/fit-exp.png" style="width: 384.0px; height: 288.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 36 </span><span class="caption-text">Exponential fitted curve with data</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_rng.h&gt;
#include &lt;gsl/gsl_randist.h&gt;
#include &lt;gsl/gsl_matrix.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
#include &lt;gsl/gsl_blas.h&gt;
#include &lt;gsl/gsl_multifit_nlinear.h&gt;

#define N      100    /* number of data points to fit */
#define TMAX   (3.0)  /* time variable in [0,TMAX] */

struct data {
  size_t n;
  double * t;
  double * y;
};

int
expb_f (const gsl_vector * x, void *data,
        gsl_vector * f)
{
  size_t n = ((struct data *)data)-&gt;n;
  double *t = ((struct data *)data)-&gt;t;
  double *y = ((struct data *)data)-&gt;y;

  double A = gsl_vector_get (x, 0);
  double lambda = gsl_vector_get (x, 1);
  double b = gsl_vector_get (x, 2);

  size_t i;

  for (i = 0; i &lt; n; i++)
    {
      /* Model Yi = A * exp(-lambda * t_i) + b */
      double Yi = A * exp (-lambda * t[i]) + b;
      gsl_vector_set (f, i, Yi - y[i]);
    }

  return GSL_SUCCESS;
}

int
expb_df (const gsl_vector * x, void *data,
         gsl_matrix * J)
{
  size_t n = ((struct data *)data)-&gt;n;
  double *t = ((struct data *)data)-&gt;t;

  double A = gsl_vector_get (x, 0);
  double lambda = gsl_vector_get (x, 1);

  size_t i;

  for (i = 0; i &lt; n; i++)
    {
      /* Jacobian matrix J(i,j) = dfi / dxj, */
      /* where fi = (Yi - yi)/sigma[i],      */
      /*       Yi = A * exp(-lambda * t_i) + b  */
      /* and the xj are the parameters (A,lambda,b) */
      double e = exp(-lambda * t[i]);
      gsl_matrix_set (J, i, 0, e);
      gsl_matrix_set (J, i, 1, -t[i] * A * e);
      gsl_matrix_set (J, i, 2, 1.0);
    }

  return GSL_SUCCESS;
}

void
callback(const size_t iter, void *params,
         const gsl_multifit_nlinear_workspace *w)
{
  gsl_vector *f = gsl_multifit_nlinear_residual(w);
  gsl_vector *x = gsl_multifit_nlinear_position(w);
  double rcond;

  /* compute reciprocal condition number of J(x) */
  gsl_multifit_nlinear_rcond(&amp;rcond, w);

  fprintf(stderr, &quot;iter %2zu: A = %.4f, lambda = %.4f, b = %.4f, cond(J) = %8.4f, |f(x)| = %.4f\n&quot;,
          iter,
          gsl_vector_get(x, 0),
          gsl_vector_get(x, 1),
          gsl_vector_get(x, 2),
          1.0 / rcond,
          gsl_blas_dnrm2(f));
}

int
main (void)
{
  const gsl_multifit_nlinear_type *T = gsl_multifit_nlinear_trust;
  gsl_multifit_nlinear_workspace *w;
  gsl_multifit_nlinear_fdf fdf;
  gsl_multifit_nlinear_parameters fdf_params =
    gsl_multifit_nlinear_default_parameters();
  const size_t n = N;
  const size_t p = 3;

  gsl_vector *f;
  gsl_matrix *J;
  gsl_matrix *covar = gsl_matrix_alloc (p, p);
  double t[N], y[N], weights[N];
  struct data d = { n, t, y };
  double x_init[3] = { 1.0, 1.0, 0.0 }; /* starting values */
  gsl_vector_view x = gsl_vector_view_array (x_init, p);
  gsl_vector_view wts = gsl_vector_view_array(weights, n);
  gsl_rng * r;
  double chisq, chisq0;
  int status, info;
  size_t i;

  const double xtol = 1e-8;
  const double gtol = 1e-8;
  const double ftol = 0.0;

  gsl_rng_env_setup();
  r = gsl_rng_alloc(gsl_rng_default);

  /* define the function to be minimized */
  fdf.f = expb_f;
  fdf.df = expb_df;   /* set to NULL for finite-difference Jacobian */
  fdf.fvv = NULL;     /* not using geodesic acceleration */
  fdf.n = n;
  fdf.p = p;
  fdf.params = &amp;d;

  /* this is the data to be fitted */
  for (i = 0; i &lt; n; i++)
    {
      double ti = i * TMAX / (n - 1.0);
      double yi = 1.0 + 5 * exp (-1.5 * ti);
      double si = 0.1 * yi;
      double dy = gsl_ran_gaussian(r, si);

      t[i] = ti;
      y[i] = yi + dy;
      weights[i] = 1.0 / (si * si);
      printf (&quot;data: %g %g %g\n&quot;, ti, y[i], si);
    };

  /* allocate workspace with default parameters */
  w = gsl_multifit_nlinear_alloc (T, &amp;fdf_params, n, p);

  /* initialize solver with starting point and weights */
  gsl_multifit_nlinear_winit (&amp;x.vector, &amp;wts.vector, &amp;fdf, w);

  /* compute initial cost function */
  f = gsl_multifit_nlinear_residual(w);
  gsl_blas_ddot(f, f, &amp;chisq0);

  /* solve the system with a maximum of 100 iterations */
  status = gsl_multifit_nlinear_driver(100, xtol, gtol, ftol,
                                       callback, NULL, &amp;info, w);

  /* compute covariance of best fit parameters */
  J = gsl_multifit_nlinear_jac(w);
  gsl_multifit_nlinear_covar (J, 0.0, covar);

  /* compute final cost */
  gsl_blas_ddot(f, f, &amp;chisq);

#define FIT(i) gsl_vector_get(w-&gt;x, i)
#define ERR(i) sqrt(gsl_matrix_get(covar,i,i))

  fprintf(stderr, &quot;summary from method &#39;%s/%s&#39;\n&quot;,
          gsl_multifit_nlinear_name(w),
          gsl_multifit_nlinear_trs_name(w));
  fprintf(stderr, &quot;number of iterations: %zu\n&quot;,
          gsl_multifit_nlinear_niter(w));
  fprintf(stderr, &quot;function evaluations: %zu\n&quot;, fdf.nevalf);
  fprintf(stderr, &quot;Jacobian evaluations: %zu\n&quot;, fdf.nevaldf);
  fprintf(stderr, &quot;reason for stopping: %s\n&quot;,
          (info == 1) ? &quot;small step size&quot; : &quot;small gradient&quot;);
  fprintf(stderr, &quot;initial |f(x)| = %f\n&quot;, sqrt(chisq0));
  fprintf(stderr, &quot;final   |f(x)| = %f\n&quot;, sqrt(chisq));

  {
    double dof = n - p;
    double c = GSL_MAX_DBL(1, sqrt(chisq / dof));

    fprintf(stderr, &quot;chisq/dof = %g\n&quot;, chisq / dof);

    fprintf (stderr, &quot;A      = %.5f +/- %.5f\n&quot;, FIT(0), c*ERR(0));
    fprintf (stderr, &quot;lambda = %.5f +/- %.5f\n&quot;, FIT(1), c*ERR(1));
    fprintf (stderr, &quot;b      = %.5f +/- %.5f\n&quot;, FIT(2), c*ERR(2));
  }

  fprintf (stderr, &quot;status = %s\n&quot;, gsl_strerror (status));

  gsl_multifit_nlinear_free (w);
  gsl_matrix_free (covar);
  gsl_rng_free (r);

  return 0;
}
</pre></div>
</div>
</div>
<div class="section" id="geodesic-acceleration-example-1">
<h3>Geodesic Acceleration Example 1<a class="headerlink" href="#geodesic-acceleration-example-1" title="Permalink to this heading">¶</a></h3>
<p>The following example program minimizes a modified Rosenbrock function,
which is characterized by a narrow canyon with steep walls. The
starting point is selected high on the canyon wall, so the solver
must first find the canyon bottom and then navigate to the minimum.
The problem is solved both with and without using geodesic acceleration
for comparison. The cost function is given by</p>
<div class="math">
<p><img src="_images/math/f2f09e3b64f0fd06b179d804f2d76c4108d68a46.png" alt="\Phi(x) &amp;= {1 \over 2} (f_1^2 + f_2^2) \\
f_1 &amp;= 100 \left( x_2 - x_1^2 \right) \\
f_2 &amp;= 1 - x_1"/></p>
</div><p>The Jacobian matrix is</p>
<div class="math">
<p><img src="_images/math/48486fad2b76fb336cb78a6bec19742a33ae7f67.png" alt="J =
\left(
  \begin{array}{cc}
    {\partial f_1 \over \partial x_1} &amp; {\partial f_1 \over \partial x_2} \\
    {\partial f_2 \over \partial x_1} &amp; {\partial f_2 \over \partial x_2}
  \end{array}
\right) =
\left(
  \begin{array}{cc}
    -200 x_1 &amp; 100 \\
    -1 &amp; 0
  \end{array}
\right)"/></p>
</div><p>In order to use geodesic acceleration, the user must provide
the second directional derivative of each residual in the
velocity direction,
<img class="math" src="_images/math/311f547d5f8383410b911eb45363c5a565aa85f4.png" alt="D_v^2 f_i = \sum_{\alpha\beta} v_{\alpha} v_{\beta} \partial_{\alpha} \partial_{\beta} f_i"/>.
The velocity vector <img class="math" src="_images/math/5fdec03022aa06df18d924e8a33c9d7c6db2ebc8.png" alt="v"/> is provided by the solver. For this example,
these derivatives are</p>
<div class="math">
<p><img src="_images/math/135f86ece2b444d9867fbe29fc0b46afd536010a.png" alt="f_{vv} =
D_v^2
\left(
  \begin{array}{c}
    f_1 \\
    f_2
  \end{array}
\right) =
\left(
  \begin{array}{c}
    -200 v_1^2 \\
    0
  \end{array}
\right)"/></p>
</div><p>The solution of this minimization problem is</p>
<div class="math">
<p><img src="_images/math/5dd1539e5db21cd97b1f5a7323211416a366207c.png" alt="x^{*} &amp;=
\left(
  \begin{array}{c}
    1 \\
    1
  \end{array}
\right) \\
\Phi(x^{*}) &amp;= 0"/></p>
</div><p>The program output is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">===</span> <span class="n">Solving</span> <span class="n">system</span> <span class="n">without</span> <span class="n">acceleration</span> <span class="o">===</span>
<span class="n">NITER</span>         <span class="o">=</span> <span class="mi">53</span>
<span class="n">NFEV</span>          <span class="o">=</span> <span class="mi">56</span>
<span class="n">NJEV</span>          <span class="o">=</span> <span class="mi">54</span>
<span class="n">NAEV</span>          <span class="o">=</span> <span class="mi">0</span>
<span class="n">initial</span> <span class="n">cost</span>  <span class="o">=</span> <span class="mf">2.250225000000e+04</span>
<span class="n">final</span> <span class="n">cost</span>    <span class="o">=</span> <span class="mf">6.674986031430e-18</span>
<span class="n">final</span> <span class="n">x</span>       <span class="o">=</span> <span class="p">(</span><span class="mf">9.999999974165e-01</span><span class="p">,</span> <span class="mf">9.999999948328e-01</span><span class="p">)</span>
<span class="n">final</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span> <span class="mf">6.000096055094e+02</span>
<span class="o">===</span> <span class="n">Solving</span> <span class="n">system</span> <span class="k">with</span> <span class="n">acceleration</span> <span class="o">===</span>
<span class="n">NITER</span>         <span class="o">=</span> <span class="mi">15</span>
<span class="n">NFEV</span>          <span class="o">=</span> <span class="mi">17</span>
<span class="n">NJEV</span>          <span class="o">=</span> <span class="mi">16</span>
<span class="n">NAEV</span>          <span class="o">=</span> <span class="mi">16</span>
<span class="n">initial</span> <span class="n">cost</span>  <span class="o">=</span> <span class="mf">2.250225000000e+04</span>
<span class="n">final</span> <span class="n">cost</span>    <span class="o">=</span> <span class="mf">7.518932873279e-19</span>
<span class="n">final</span> <span class="n">x</span>       <span class="o">=</span> <span class="p">(</span><span class="mf">9.999999991329e-01</span><span class="p">,</span> <span class="mf">9.999999982657e-01</span><span class="p">)</span>
<span class="n">final</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span> <span class="mf">6.000097233278e+02</span>
</pre></div>
</div>
<div class="figure align-default" id="id2">
<span id="fig-nlfit2"></span><img alt="_images/nlfit2.png" src="_images/nlfit2.png" />
<p class="caption"><span class="caption-number">Fig. 37 </span><span class="caption-text">Paths taken by solver for Rosenbrock function</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>We can see that enabling geodesic acceleration requires less
than a third of the number of Jacobian evaluations in order to locate
the minimum. The path taken by both methods is shown in <a class="reference internal" href="#fig-nlfit2"><span class="std std-numref">Fig. 37</span></a>.
The contours show the cost function
<img class="math" src="_images/math/89d9ab27fd3a3a4e37db5f51d1fa8e77c326d1a8.png" alt="\Phi(x_1,x_2)"/>. We see that both methods quickly
find the canyon bottom, but the geodesic acceleration method
navigates along the bottom to the solution with significantly
fewer iterations.</p>
<p>The program is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_blas.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit_nlinear.h&gt;</span>

<span class="nb">int</span>
<span class="n">func_f</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="o">*</span><span class="n">x1</span><span class="p">));</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">func_df</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_matrix</span> <span class="o">*</span> <span class="n">J</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">200.0</span><span class="o">*</span><span class="n">x1</span><span class="p">);</span>
  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">);</span>
  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">func_fvv</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span>
          <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">fvv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">fvv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">200.0</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">fvv</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">callback</span><span class="p">(</span><span class="n">const</span> <span class="n">size_t</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
         <span class="n">const</span> <span class="n">gsl_multifit_nlinear_workspace</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_position</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">out</span> <span class="n">current</span> <span class="n">location</span> <span class="o">*/</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
         <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
         <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">solve_system</span><span class="p">(</span><span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x0</span><span class="p">,</span> <span class="n">gsl_multifit_nlinear_fdf</span> <span class="o">*</span><span class="n">fdf</span><span class="p">,</span>
             <span class="n">gsl_multifit_nlinear_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">gsl_multifit_nlinear_type</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trust</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">gtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">ftol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
  <span class="n">gsl_multifit_nlinear_workspace</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span>
    <span class="n">gsl_multifit_nlinear_alloc</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_residual</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_position</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="nb">int</span> <span class="n">info</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">chisq0</span><span class="p">,</span> <span class="n">chisq</span><span class="p">,</span> <span class="n">rcond</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">initialize</span> <span class="n">solver</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_init</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">fdf</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">initial</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq0</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">iterate</span> <span class="n">until</span> <span class="n">convergence</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_driver</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">xtol</span><span class="p">,</span> <span class="n">gtol</span><span class="p">,</span> <span class="n">ftol</span><span class="p">,</span>
                              <span class="n">callback</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">final</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_rcond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcond</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">summary</span> <span class="o">*/</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NITER         = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_multifit_nlinear_niter</span><span class="p">(</span><span class="n">work</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NFEV          = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevalf</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NJEV          = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevaldf</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NAEV          = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevalfvv</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;initial cost  = </span><span class="si">%.12e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq0</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;final cost    = </span><span class="si">%.12e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;final x       = (</span><span class="si">%.12e</span><span class="s2">, </span><span class="si">%.12e</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;final cond(J) = </span><span class="si">%.12e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">gsl_multifit_nlinear_free</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_multifit_nlinear_fdf</span> <span class="n">fdf</span><span class="p">;</span>
  <span class="n">gsl_multifit_nlinear_parameters</span> <span class="n">fdf_params</span> <span class="o">=</span>
    <span class="n">gsl_multifit_nlinear_default_parameters</span><span class="p">();</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="nb">map</span> <span class="n">of</span> <span class="n">Phi</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*/</span>
  <span class="p">{</span>
    <span class="n">double</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">chisq</span><span class="p">;</span>
    <span class="n">double</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="n">gsl_vector_ptr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">double</span> <span class="o">*</span><span class="n">f2</span> <span class="o">=</span> <span class="n">gsl_vector_ptr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">x1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">;</span> <span class="n">x1</span> <span class="o">&lt;</span> <span class="mf">1.3</span><span class="p">;</span> <span class="n">x1</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">;</span> <span class="n">x2</span> <span class="o">&lt;</span> <span class="mf">2.1</span><span class="p">;</span> <span class="n">x2</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
            <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
            <span class="n">func_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

            <span class="n">chisq</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">f2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">f2</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">chisq</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="o">/*</span> <span class="n">define</span> <span class="n">function</span> <span class="n">to</span> <span class="n">be</span> <span class="n">minimized</span> <span class="o">*/</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">func_f</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">func_df</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">fvv</span> <span class="o">=</span> <span class="n">func_fvv</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">starting</span> <span class="n">point</span> <span class="o">*/</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.75</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;=== Solving system without acceleration ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_lm</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;=== Solving system with acceleration ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_lmaccel</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="geodesic-acceleration-example-2">
<h3>Geodesic Acceleration Example 2<a class="headerlink" href="#geodesic-acceleration-example-2" title="Permalink to this heading">¶</a></h3>
<p>The following example fits a set of data to a Gaussian model
using the Levenberg-Marquardt method with geodesic acceleration.
The cost function is</p>
<div class="math">
<p><img src="_images/math/114a1be067e94a2d73db2f0b026bf9d417d1fbaa.png" alt="\Phi(x) &amp;= {1 \over 2} \sum_i f_i^2 \\
f_i &amp;= y_i - Y(a,b,c;t_i)"/></p>
</div><p>where <img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/> is the measured data point at time <img class="math" src="_images/math/0adefa77e09c6c526f71ab3063c42ab84b72082e.png" alt="t_i"/>, and
the model is specified by</p>
<div class="math">
<p><img src="_images/math/35ca8fbfbbcf8d1ea93a634ae2b37e4db564c0f6.png" alt="Y(a,b,c;t) = a \exp{
\left[
-{1 \over 2}
\left(
{ t - b \over c }
\right)^2
\right]
}"/></p>
</div><p>The parameters <img class="math" src="_images/math/33e5d7ec10e51539022a9a62c07def817868f84e.png" alt="a,b,c"/> represent the amplitude, mean, and width of the Gaussian
respectively. The program below generates the <img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/> data on <img class="math" src="_images/math/e7e8ac4ddd4ab0fc62c2a6435f8373f48c776858.png" alt="[0,1]"/> using
the values <img class="math" src="_images/math/d693ac2b8254dcd7ccfdb91b4c567edb8d836336.png" alt="a = 5"/>, <img class="math" src="_images/math/49a8a0b0cf29d9eae8ea6163f435c1075a75affa.png" alt="b = 0.4"/>, <img class="math" src="_images/math/ee878a0788ee351bd58c3a347a48dff6a84785e2.png" alt="c = 0.15"/> and adding random noise.
The <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th row of the Jacobian is</p>
<div class="math">
<p><img src="_images/math/537e63e8411926f7469e419406de55bbb5b3ef0b.png" alt="J_{i,:} =
\left(
  \begin{array}{ccc}
    {\partial f_i \over \partial a} &amp; {\partial f_i \over \partial b} &amp; {\partial f_i \over \partial c}
  \end{array}
\right) =
\left(
  \begin{array}{ccc}
    -e_i &amp; -{a \over c} z_i e_i &amp; -{a \over c} z_i^2 e_i
  \end{array}
\right)"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/31b44ba26ca20f7804315437c2ce145f386bfe75.png" alt="z_i &amp;= { t_i - b \over c} \\
e_i &amp;= \exp{\left( -{1 \over 2} z_i^2 \right)}"/></p>
</div><p>In order to use geodesic acceleration, we need the second directional derivative
of the residuals in the velocity direction,
<img class="math" src="_images/math/311f547d5f8383410b911eb45363c5a565aa85f4.png" alt="D_v^2 f_i = \sum_{\alpha\beta} v_{\alpha} v_{\beta} \partial_{\alpha} \partial_{\beta} f_i"/>,
where <img class="math" src="_images/math/5fdec03022aa06df18d924e8a33c9d7c6db2ebc8.png" alt="v"/> is provided by the solver. To compute this, it is helpful to make a table of
all second derivatives of the residuals <img class="math" src="_images/math/b7524c4d67379a7045021fd157d0fc7c890ce138.png" alt="f_i"/> with respect to each combination of model parameters.
This table is</p>
<div class="math">
<p><img src="_images/math/6b430fb08c4846ffd1bf12fcf830337eece3910f.png" alt="\begin{array}{cccc}
  &amp; {\partial \over \partial a} &amp; {\partial \over \partial b} &amp; {\partial \over \partial c} \cr
  {\partial \over \partial a} &amp; 0 &amp; -{z_i \over c} e_i &amp; -{z_i^2 \over c} e_i \cr
  {\partial \over \partial b} &amp; &amp; {a \over c^2} \left( 1 - z_i^2 \right) e_i &amp; {a \over c^2} z_i \left( 2 - z_i^2 \right) e_i \cr
  {\partial \over \partial c} &amp; &amp; &amp; {a \over c^2} z_i^2 \left( 3 - z_i^2 \right) e_i
\end{array}"/></p>
</div><p>The lower half of the table is omitted since it is symmetric. Then, the second directional derivative
of <img class="math" src="_images/math/b7524c4d67379a7045021fd157d0fc7c890ce138.png" alt="f_i"/> is</p>
<div class="math">
<p><img src="_images/math/0533446f4a2b7f9aee4bacc2b997cc345d400660.png" alt="D_v^2 f_i = v_a^2 \partial_a^2 f_i + 2 v_a v_b \partial_a \partial_b f_i + 2 v_a v_c \partial_a \partial_c f_i + v_b^2 \partial_b^2 f_i + 2 v_b v_c \partial_b \partial_c f_i + v_c^2 \partial_c^2 f_i"/></p>
</div><p>The factors of 2 come from the symmetry of the mixed second partial derivatives.
The iteration is started using the initial guess <img class="math" src="_images/math/3ee4bb6d6b72e44306821edf51acbb44bd3c043e.png" alt="a = 1, b = 0, c = 1"/>.
The program output is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span>  <span class="mi">0</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0000</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0000</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0000</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.0000</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>      <span class="n">inf</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">35.4785</span>
<span class="nb">iter</span>  <span class="mi">1</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.5708</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.5321</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.5219</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.3093</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">29.0443</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">31.1042</span>
<span class="nb">iter</span>  <span class="mi">2</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.7387</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.4040</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.4568</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.1199</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>   <span class="mf">3.5256</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">28.7217</span>
<span class="nb">iter</span>  <span class="mi">3</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">2.2340</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3829</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.3053</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.3308</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>   <span class="mf">4.5121</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">23.8074</span>
<span class="nb">iter</span>  <span class="mi">4</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">3.2275</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3952</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.2243</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.2784</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>   <span class="mf">8.6499</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">15.6003</span>
<span class="nb">iter</span>  <span class="mi">5</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">4.3347</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3974</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.1752</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.2029</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">15.1732</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">7.5908</span>
<span class="nb">iter</span>  <span class="mi">6</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">4.9352</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3992</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.1536</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.1001</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">26.6621</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">4.8402</span>
<span class="nb">iter</span>  <span class="mi">7</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">5.0716</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3994</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.1498</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.0166</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">34.6922</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">4.7103</span>
<span class="nb">iter</span>  <span class="mi">8</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">5.0828</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3994</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.1495</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.0012</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">36.5422</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">4.7095</span>
<span class="nb">iter</span>  <span class="mi">9</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">5.0831</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3994</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.1495</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.0000</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">36.6929</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">4.7095</span>
<span class="nb">iter</span> <span class="mi">10</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">5.0831</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3994</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.1495</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.0000</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">36.6975</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">4.7095</span>
<span class="nb">iter</span> <span class="mi">11</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">5.0831</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3994</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.1495</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="o">|/|</span><span class="n">v</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.0000</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">36.6976</span><span class="p">,</span> <span class="o">|</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">4.7095</span>
<span class="n">NITER</span>         <span class="o">=</span> <span class="mi">11</span>
<span class="n">NFEV</span>          <span class="o">=</span> <span class="mi">18</span>
<span class="n">NJEV</span>          <span class="o">=</span> <span class="mi">12</span>
<span class="n">NAEV</span>          <span class="o">=</span> <span class="mi">17</span>
<span class="n">initial</span> <span class="n">cost</span>  <span class="o">=</span> <span class="mf">1.258724737288e+03</span>
<span class="n">final</span> <span class="n">cost</span>    <span class="o">=</span> <span class="mf">2.217977560180e+01</span>
<span class="n">final</span> <span class="n">x</span>       <span class="o">=</span> <span class="p">(</span><span class="mf">5.083101559156e+00</span><span class="p">,</span> <span class="mf">3.994484109594e-01</span><span class="p">,</span> <span class="mf">1.494898e-01</span><span class="p">)</span>
<span class="n">final</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.669757713403e+01</span>
</pre></div>
</div>
<p>We see the method converges after 11 iterations. For comparison the standard
Levenberg-Marquardt method requires 26 iterations and so the Gaussian fitting
problem benefits substantially from the geodesic acceleration correction. The
column marked <code class="code docutils literal notranslate"><span class="pre">|a|/|v|</span></code> above shows the ratio of the acceleration term
to the velocity term as the iteration progresses. Larger values of this
ratio indicate that the geodesic acceleration correction term is contributing
substantial information to the solver relative to the standard LM velocity step.</p>
<p>The data and fitted model are shown in <a class="reference internal" href="#fig-nlfit2b"><span class="std std-numref">Fig. 38</span></a>.</p>
<div class="figure align-default" id="id3">
<span id="fig-nlfit2b"></span><img alt="_images/nlfit2b.png" src="_images/nlfit2b.png" />
<p class="caption"><span class="caption-number">Fig. 38 </span><span class="caption-text">Gaussian model fitted to data</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The program is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_blas.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit_nlinear.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_rng.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_randist.h&gt;</span>

<span class="n">struct</span> <span class="n">data</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
  <span class="n">double</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">/*</span> <span class="n">model</span> <span class="n">function</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">[</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span> <span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="p">)</span> <span class="o">*/</span>
<span class="n">double</span>
<span class="n">gaussian</span><span class="p">(</span><span class="n">const</span> <span class="n">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">const</span> <span class="n">double</span> <span class="n">b</span><span class="p">,</span> <span class="n">const</span> <span class="n">double</span> <span class="n">c</span><span class="p">,</span> <span class="n">const</span> <span class="n">double</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span><span class="p">));</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">func_f</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">data</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">ti</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">double</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>

      <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">func_df</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_matrix</span> <span class="o">*</span> <span class="n">J</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">data</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">ti</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">double</span> <span class="n">zi</span> <span class="o">=</span> <span class="p">(</span><span class="n">ti</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
      <span class="n">double</span> <span class="n">ei</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">zi</span><span class="p">);</span>

      <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">ei</span><span class="p">);</span>
      <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">ei</span> <span class="o">*</span> <span class="n">zi</span><span class="p">);</span>
      <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">ei</span> <span class="o">*</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">zi</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">func_fvv</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span>
          <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">fvv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">data</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">va</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">vb</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">vc</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">ti</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">double</span> <span class="n">zi</span> <span class="o">=</span> <span class="p">(</span><span class="n">ti</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
      <span class="n">double</span> <span class="n">ei</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">zi</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">Dab</span> <span class="o">=</span> <span class="o">-</span><span class="n">zi</span> <span class="o">*</span> <span class="n">ei</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
      <span class="n">double</span> <span class="n">Dac</span> <span class="o">=</span> <span class="o">-</span><span class="n">zi</span> <span class="o">*</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">ei</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
      <span class="n">double</span> <span class="n">Dbb</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">ei</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">zi</span><span class="o">*</span><span class="n">zi</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">Dbc</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">ei</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">zi</span><span class="o">*</span><span class="n">zi</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">Dcc</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">ei</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">-</span> <span class="n">zi</span><span class="o">*</span><span class="n">zi</span><span class="p">);</span>
      <span class="n">double</span> <span class="nb">sum</span><span class="p">;</span>

      <span class="nb">sum</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">va</span> <span class="o">*</span> <span class="n">vb</span> <span class="o">*</span> <span class="n">Dab</span> <span class="o">+</span>
            <span class="mf">2.0</span> <span class="o">*</span> <span class="n">va</span> <span class="o">*</span> <span class="n">vc</span> <span class="o">*</span> <span class="n">Dac</span> <span class="o">+</span>
                  <span class="n">vb</span> <span class="o">*</span> <span class="n">vb</span> <span class="o">*</span> <span class="n">Dbb</span> <span class="o">+</span>
            <span class="mf">2.0</span> <span class="o">*</span> <span class="n">vb</span> <span class="o">*</span> <span class="n">vc</span> <span class="o">*</span> <span class="n">Dbc</span> <span class="o">+</span>
                  <span class="n">vc</span> <span class="o">*</span> <span class="n">vc</span> <span class="o">*</span> <span class="n">Dcc</span><span class="p">;</span>

      <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">fvv</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">sum</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">callback</span><span class="p">(</span><span class="n">const</span> <span class="n">size_t</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
         <span class="n">const</span> <span class="n">gsl_multifit_nlinear_workspace</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_residual</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_position</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">avratio</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_avratio</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">rcond</span><span class="p">;</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span> <span class="o">/*</span> <span class="ow">not</span> <span class="n">used</span> <span class="o">*/</span>

  <span class="o">/*</span> <span class="n">compute</span> <span class="n">reciprocal</span> <span class="n">condition</span> <span class="n">number</span> <span class="n">of</span> <span class="n">J</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_rcond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcond</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;iter %2zu: a = </span><span class="si">%.4f</span><span class="s2">, b = </span><span class="si">%.4f</span><span class="s2">, c = </span><span class="si">%.4f</span><span class="s2">, |a|/|v| = </span><span class="si">%.4f</span><span class="s2"> cond(J) = </span><span class="si">%8.4f</span><span class="s2">, |f(x)| = </span><span class="si">%.4f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="nb">iter</span><span class="p">,</span>
          <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
          <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
          <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
          <span class="n">avratio</span><span class="p">,</span>
          <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">,</span>
          <span class="n">gsl_blas_dnrm2</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">solve_system</span><span class="p">(</span><span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">gsl_multifit_nlinear_fdf</span> <span class="o">*</span><span class="n">fdf</span><span class="p">,</span>
             <span class="n">gsl_multifit_nlinear_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">gsl_multifit_nlinear_type</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trust</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">gtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">ftol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
  <span class="n">gsl_multifit_nlinear_workspace</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span>
    <span class="n">gsl_multifit_nlinear_alloc</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_residual</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_position</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="nb">int</span> <span class="n">info</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">chisq0</span><span class="p">,</span> <span class="n">chisq</span><span class="p">,</span> <span class="n">rcond</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">initialize</span> <span class="n">solver</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_init</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fdf</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">initial</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq0</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">iterate</span> <span class="n">until</span> <span class="n">convergence</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_driver</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">xtol</span><span class="p">,</span> <span class="n">gtol</span><span class="p">,</span> <span class="n">ftol</span><span class="p">,</span>
                              <span class="n">callback</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">final</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_rcond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcond</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="n">gsl_vector_memcpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">summary</span> <span class="o">*/</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NITER         = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_multifit_nlinear_niter</span><span class="p">(</span><span class="n">work</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NFEV          = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevalf</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NJEV          = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevaldf</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;NAEV          = %zu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevalfvv</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;initial cost  = </span><span class="si">%.12e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq0</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;final cost    = </span><span class="si">%.12e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;final x       = (</span><span class="si">%.12e</span><span class="s2">, </span><span class="si">%.12e</span><span class="s2">, </span><span class="si">%12e</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;final cond(J) = </span><span class="si">%.12e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">);</span>

  <span class="n">gsl_multifit_nlinear_free</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">data</span> <span class="n">points</span> <span class="n">to</span> <span class="n">fit</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>    <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">model</span> <span class="n">parameters</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">amplitude</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">center</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">;</span> <span class="o">/*</span> <span class="n">width</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">gsl_rng_type</span> <span class="o">*</span> <span class="n">T</span> <span class="o">=</span> <span class="n">gsl_rng_default</span><span class="p">;</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_multifit_nlinear_fdf</span> <span class="n">fdf</span><span class="p">;</span>
  <span class="n">gsl_multifit_nlinear_parameters</span> <span class="n">fdf_params</span> <span class="o">=</span>
    <span class="n">gsl_multifit_nlinear_default_parameters</span><span class="p">();</span>
  <span class="n">struct</span> <span class="n">data</span> <span class="n">fit_data</span><span class="p">;</span>
  <span class="n">gsl_rng</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">gsl_rng_env_setup</span> <span class="p">();</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">gsl_rng_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">);</span>

  <span class="n">fit_data</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
  <span class="n">fit_data</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
  <span class="n">fit_data</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">generate</span> <span class="n">synthetic</span> <span class="n">data</span> <span class="k">with</span> <span class="n">noise</span> <span class="o">*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">double</span><span class="p">)</span><span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">double</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">double</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">gsl_ran_gaussian</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">y0</span><span class="p">);</span>

      <span class="n">fit_data</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
      <span class="n">fit_data</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="o">/*</span> <span class="n">define</span> <span class="n">function</span> <span class="n">to</span> <span class="n">be</span> <span class="n">minimized</span> <span class="o">*/</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">func_f</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">func_df</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">fvv</span> <span class="o">=</span> <span class="n">func_fvv</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fit_data</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">starting</span> <span class="n">point</span> <span class="o">*/</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_lmaccel</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">model</span> <span class="o">*/</span>
  <span class="p">{</span>
    <span class="n">double</span> <span class="n">A</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">double</span> <span class="n">B</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">double</span> <span class="n">C</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">double</span> <span class="n">ti</span> <span class="o">=</span> <span class="n">fit_data</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">double</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">fit_data</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">double</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">gsl_rng_free</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="comparing-trs-methods-example">
<h3>Comparing TRS Methods Example<a class="headerlink" href="#comparing-trs-methods-example" title="Permalink to this heading">¶</a></h3>
<p>The following program compares all available nonlinear least squares
trust-region subproblem (TRS) methods on the Branin function, a common
optimization test problem. The cost function is</p>
<div class="math">
<p><img src="_images/math/443b93c22b164575b07b49b62739754417e525e6.png" alt="\Phi(x) &amp;= {1 \over 2} (f_1^2 + f_2^2) \\
f_1 &amp;= x_2 + a_1 x_1^2 + a_2 x_1 + a_3 \\
f_2 &amp;= \sqrt{a_4} \sqrt{1 + (1 - a_5) \cos{x_1}}"/></p>
</div><p>with <img class="math" src="_images/math/1a8c7d31ebb49079b57bb9772ccfe500ca475fca.png" alt="a_1 = -{5.1 \over 4 \pi^2}, a_2 = {5 \over \pi}, a_3 = -6, a_4 = 10, a_5 = {1 \over 8\pi}"/>.
There are three minima of this function in the range
<img class="math" src="_images/math/78237ab11b0780ef40099205173c822e4d062f08.png" alt="(x_1,x_2) \in [-5,15] \times [-5,15]"/>. The program
below uses the starting point <img class="math" src="_images/math/4963cfb95674b79096c409438f7868562a434895.png" alt="(x_1,x_2) = (6,14.5)"/>
and calculates the solution with all available nonlinear
least squares TRS methods. The program output is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Method</span>                    <span class="n">NITER</span>  <span class="n">NFEV</span>  <span class="n">NJEV</span>  <span class="n">Initial</span> <span class="n">Cost</span>  <span class="n">Final</span> <span class="n">cost</span>   <span class="n">Final</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="n">Final</span> <span class="n">x</span>
<span class="n">levenberg</span><span class="o">-</span><span class="n">marquardt</span>       <span class="mi">20</span>     <span class="mi">27</span>    <span class="mi">21</span>    <span class="mf">1.9874e+02</span>    <span class="mf">3.9789e-01</span>   <span class="mf">6.1399e+07</span>    <span class="p">(</span><span class="o">-</span><span class="mf">3.14e+00</span><span class="p">,</span> <span class="mf">1.23e+01</span><span class="p">)</span>
<span class="n">levenberg</span><span class="o">-</span><span class="n">marquardt</span><span class="o">+</span><span class="n">accel</span> <span class="mi">27</span>     <span class="mi">36</span>    <span class="mi">28</span>    <span class="mf">1.9874e+02</span>    <span class="mf">3.9789e-01</span>   <span class="mf">1.4465e+07</span>    <span class="p">(</span><span class="mf">3.14e+00</span><span class="p">,</span> <span class="mf">2.27e+00</span><span class="p">)</span>
<span class="n">dogleg</span>                    <span class="mi">23</span>     <span class="mi">64</span>    <span class="mi">23</span>    <span class="mf">1.9874e+02</span>    <span class="mf">3.9789e-01</span>   <span class="mf">5.0692e+08</span>    <span class="p">(</span><span class="mf">3.14e+00</span><span class="p">,</span> <span class="mf">2.28e+00</span><span class="p">)</span>
<span class="n">double</span><span class="o">-</span><span class="n">dogleg</span>             <span class="mi">24</span>     <span class="mi">69</span>    <span class="mi">24</span>    <span class="mf">1.9874e+02</span>    <span class="mf">3.9789e-01</span>   <span class="mf">3.4879e+07</span>    <span class="p">(</span><span class="mf">3.14e+00</span><span class="p">,</span> <span class="mf">2.27e+00</span><span class="p">)</span>
<span class="mi">2</span><span class="n">D</span><span class="o">-</span><span class="n">subspace</span>               <span class="mi">23</span>     <span class="mi">54</span>    <span class="mi">24</span>    <span class="mf">1.9874e+02</span>    <span class="mf">3.9789e-01</span>   <span class="mf">2.5142e+07</span>    <span class="p">(</span><span class="mf">3.14e+00</span><span class="p">,</span> <span class="mf">2.27e+00</span><span class="p">)</span>
</pre></div>
</div>
<p>The first row of output above corresponds to standard Levenberg-Marquardt, while
the second row includes geodesic acceleration. We see that the standard LM method
converges to the minimum at <img class="math" src="_images/math/1a272b7f8688a844714a8090512098f9c75b7f01.png" alt="(-\pi,12.275)"/> and also uses the least number
of iterations and Jacobian evaluations. All other methods converge to the minimum
<img class="math" src="_images/math/97689a3073458044975fa2238c53447124358ac0.png" alt="(\pi,2.275)"/> and perform similarly in terms of number of Jacobian evaluations.
We see that <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/> is fairly ill-conditioned
at both minima, indicating that the QR (or SVD) solver is the best choice for this problem.
Since there are only two parameters in this optimization problem, we can easily
visualize the paths taken by each method, which are shown in <a class="reference internal" href="#fig-nlfit3"><span class="std std-numref">Fig. 39</span></a>.
The figure shows contours of the cost function <img class="math" src="_images/math/89d9ab27fd3a3a4e37db5f51d1fa8e77c326d1a8.png" alt="\Phi(x_1,x_2)"/> which exhibits
three global minima in the range <img class="math" src="_images/math/71a226b4498f2c8629075cf73bcca67c0f17f435.png" alt="[-5,15] \times [-5,15]"/>. The paths taken
by each solver are shown as colored lines.</p>
<div class="figure align-default" id="id4">
<span id="fig-nlfit3"></span><a class="reference internal image-reference" href="_images/nlfit3.png"><img alt="_images/nlfit3.png" src="_images/nlfit3.png" style="width: 480.0px; height: 360.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 39 </span><span class="caption-text">Paths taken for different TRS methods for the Branin function</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>The program is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_blas.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit_nlinear.h&gt;</span>

<span class="o">/*</span> <span class="n">parameters</span> <span class="n">to</span> <span class="n">model</span> <span class="o">*/</span>
<span class="n">struct</span> <span class="n">model_params</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">a1</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">a2</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">a3</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">a4</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">a5</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">/*</span> <span class="n">Branin</span> <span class="n">function</span> <span class="o">*/</span>
<span class="nb">int</span>
<span class="n">func_f</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a1</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a3</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a5</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">x1</span><span class="p">));</span>

  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f1</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f2</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">func_df</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_matrix</span> <span class="o">*</span> <span class="n">J</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a5</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">x1</span><span class="p">));</span>

  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a1</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a2</span><span class="p">);</span>
  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">/</span> <span class="n">f2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a5</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">x1</span><span class="p">));</span>
  <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">func_fvv</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span>
          <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">fvv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a5</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a4</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a5</span><span class="p">)</span> <span class="o">/</span> <span class="n">f2</span><span class="p">;</span>

  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">fvv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">a1</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">fvv</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="o">/</span><span class="n">f2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">callback</span><span class="p">(</span><span class="n">const</span> <span class="n">size_t</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
         <span class="n">const</span> <span class="n">gsl_multifit_nlinear_workspace</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_position</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">out</span> <span class="n">current</span> <span class="n">location</span> <span class="o">*/</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">solve_system</span><span class="p">(</span><span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x0</span><span class="p">,</span> <span class="n">gsl_multifit_nlinear_fdf</span> <span class="o">*</span><span class="n">fdf</span><span class="p">,</span>
             <span class="n">gsl_multifit_nlinear_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">gsl_multifit_nlinear_type</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trust</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">gtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">ftol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
  <span class="n">gsl_multifit_nlinear_workspace</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span>
    <span class="n">gsl_multifit_nlinear_alloc</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_residual</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_position</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="nb">int</span> <span class="n">info</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">chisq0</span><span class="p">,</span> <span class="n">chisq</span><span class="p">,</span> <span class="n">rcond</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;# </span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
         <span class="n">gsl_multifit_nlinear_name</span><span class="p">(</span><span class="n">work</span><span class="p">),</span>
         <span class="n">gsl_multifit_nlinear_trs_name</span><span class="p">(</span><span class="n">work</span><span class="p">));</span>

  <span class="o">/*</span> <span class="n">initialize</span> <span class="n">solver</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_init</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">fdf</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">initial</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq0</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">iterate</span> <span class="n">until</span> <span class="n">convergence</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_driver</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">xtol</span><span class="p">,</span> <span class="n">gtol</span><span class="p">,</span> <span class="n">ftol</span><span class="p">,</span>
                              <span class="n">callback</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">final</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*/</span>
  <span class="n">gsl_multifit_nlinear_rcond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcond</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">summary</span> <span class="o">*/</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%-25s</span><span class="s2"> %-6zu %-5zu %-5zu </span><span class="si">%-13.4e</span><span class="s2"> </span><span class="si">%-12.4e</span><span class="s2"> </span><span class="si">%-13.4e</span><span class="s2"> (</span><span class="si">%.2e</span><span class="s2">, </span><span class="si">%.2e</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">gsl_multifit_nlinear_trs_name</span><span class="p">(</span><span class="n">work</span><span class="p">),</span>
          <span class="n">gsl_multifit_nlinear_niter</span><span class="p">(</span><span class="n">work</span><span class="p">),</span>
          <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevalf</span><span class="p">,</span>
          <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevaldf</span><span class="p">,</span>
          <span class="n">chisq0</span><span class="p">,</span>
          <span class="n">chisq</span><span class="p">,</span>
          <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">,</span>
          <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
          <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">gsl_multifit_nlinear_free</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_multifit_nlinear_fdf</span> <span class="n">fdf</span><span class="p">;</span>
  <span class="n">gsl_multifit_nlinear_parameters</span> <span class="n">fdf_params</span> <span class="o">=</span>
    <span class="n">gsl_multifit_nlinear_default_parameters</span><span class="p">();</span>
  <span class="n">struct</span> <span class="n">model_params</span> <span class="n">params</span><span class="p">;</span>

  <span class="n">params</span><span class="o">.</span><span class="n">a1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">5.1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">);</span>
  <span class="n">params</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">/</span> <span class="n">M_PI</span><span class="p">;</span>
  <span class="n">params</span><span class="o">.</span><span class="n">a3</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span><span class="p">;</span>
  <span class="n">params</span><span class="o">.</span><span class="n">a4</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
  <span class="n">params</span><span class="o">.</span><span class="n">a5</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">8.0</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="nb">map</span> <span class="n">of</span> <span class="n">Phi</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*/</span>
  <span class="p">{</span>
    <span class="n">double</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">chisq</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">x1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">;</span> <span class="n">x1</span> <span class="o">&lt;</span> <span class="mf">15.0</span><span class="p">;</span> <span class="n">x1</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">;</span> <span class="n">x2</span> <span class="o">&lt;</span> <span class="mf">15.0</span><span class="p">;</span> <span class="n">x2</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
            <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>
            <span class="n">func_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

            <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq</span><span class="p">);</span>

            <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">chisq</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="o">/*</span> <span class="n">define</span> <span class="n">function</span> <span class="n">to</span> <span class="n">be</span> <span class="n">minimized</span> <span class="o">*/</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">func_f</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">func_df</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">fvv</span> <span class="o">=</span> <span class="n">func_fvv</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">starting</span> <span class="n">point</span> <span class="o">*/</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">14.5</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%-25s</span><span class="s2"> </span><span class="si">%-6s</span><span class="s2"> </span><span class="si">%-5s</span><span class="s2"> </span><span class="si">%-5s</span><span class="s2"> </span><span class="si">%-13s</span><span class="s2"> </span><span class="si">%-12s</span><span class="s2"> </span><span class="si">%-13s</span><span class="s2"> </span><span class="si">%-15s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="s2">&quot;Method&quot;</span><span class="p">,</span> <span class="s2">&quot;NITER&quot;</span><span class="p">,</span> <span class="s2">&quot;NFEV&quot;</span><span class="p">,</span> <span class="s2">&quot;NJEV&quot;</span><span class="p">,</span> <span class="s2">&quot;Initial Cost&quot;</span><span class="p">,</span>
          <span class="s2">&quot;Final cost&quot;</span><span class="p">,</span> <span class="s2">&quot;Final cond(J)&quot;</span><span class="p">,</span> <span class="s2">&quot;Final x&quot;</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_lm</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_lmaccel</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_dogleg</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_ddogleg</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multifit_nlinear_trs_subspace2D</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="large-nonlinear-least-squares-example">
<h3>Large Nonlinear Least Squares Example<a class="headerlink" href="#large-nonlinear-least-squares-example" title="Permalink to this heading">¶</a></h3>
<p>The following program illustrates the large nonlinear least
squares solvers on a system with significant sparse structure
in the Jacobian. The cost function is</p>
<div class="math">
<p><img src="_images/math/4ac12cff1027bfb4136abcebeaff9fcda7e65718.png" alt="\Phi(x) &amp;= {1 \over 2} \sum_{i=1}^{p+1} f_i^2 \\
f_i &amp;= \sqrt{\alpha} (x_i - 1), \quad 1 \le i \le p \\
f_{p+1} &amp;= ||x||^2 - {1 \over 4}"/></p>
</div><p>with <img class="math" src="_images/math/9baaa256a0e5d142f21daec48f74379d503ad9a5.png" alt="\alpha = 10^{-5}"/>. The residual <img class="math" src="_images/math/3c28b805ca974cff2cd980a4293e9383f417ccef.png" alt="f_{p+1}"/> imposes a constraint on the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>
parameters <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>, to ensure that <img class="math" src="_images/math/dd507cef3b8869198dcd0cd003537623715409c4.png" alt="||x||^2 \approx {1 \over 4}"/>.
The <img class="math" src="_images/math/4da0cf424014740ad63901206f8c9d573d09e99b.png" alt="(p+1)"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> Jacobian for this system is</p>
<div class="math">
<p><img src="_images/math/4dfa563d4d746a1e0b2ed61d62474133471b271b.png" alt="J(x) =
\left(
  \begin{array}{c}
    \sqrt{\alpha} I_p \\
    2 x^T
  \end{array}
\right)"/></p>
</div><p>and the normal equations matrix is</p>
<div class="math">
<p><img src="_images/math/2a7ff79b6d5bde6434e4f351866eeff6f9e85fc7.png" alt="J^T J = \alpha I_p + 4 x x^T"/></p>
</div><p>Finally, the second directional derivative of <img class="math" src="_images/math/297ac74049e250d35993e62353e189c7bfda5398.png" alt="f"/> for the
geodesic acceleration method is</p>
<div class="math">
<p><img src="_images/math/6e5d7310c31aa712e5bbd9efcfaa5b8a764147ca.png" alt="f_{vv} = D_v^2 f =
\left(
  \begin{array}{c}
    0 \\
    2 ||v||^2
  \end{array}
\right)"/></p>
</div><p>Since the upper <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> block of <img class="math" src="_images/math/aca80d18a77d5da4df841b8c57cc874974238dd5.png" alt="J"/> is diagonal,
this sparse structure should be exploited in the nonlinear solver.
For comparison, the following program solves the system for <img class="math" src="_images/math/8bf398fcc0b8397c3dd4744adcdf340e2b2c5441.png" alt="p = 2000"/>
using the dense direct Cholesky solver based on the normal equations matrix
<img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/>, as well as the iterative Steihaug-Toint solver, based on
sparse matrix-vector products <img class="math" src="_images/math/f57a4296462c42fefce883993b1021d34ad79dc9.png" alt="J u"/> and <img class="math" src="_images/math/32ff04d3dfc6082bf0464393e614784d955ffa2c.png" alt="J^T u"/>. The
program output is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Method</span>                    <span class="n">NITER</span> <span class="n">NFEV</span> <span class="n">NJUEV</span> <span class="n">NJTJEV</span> <span class="n">NAEV</span> <span class="n">Init</span> <span class="n">Cost</span>  <span class="n">Final</span> <span class="n">cost</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="n">Final</span> <span class="o">|</span><span class="n">x</span><span class="o">|^</span><span class="mi">2</span> <span class="n">Time</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">levenberg</span><span class="o">-</span><span class="n">marquardt</span>       <span class="mi">25</span>    <span class="mi">31</span>   <span class="mi">26</span>    <span class="mi">26</span>     <span class="mi">0</span>    <span class="mf">7.1218e+18</span> <span class="mf">1.9555e-02</span> <span class="mf">447.50</span>  <span class="mf">2.5044e-01</span>  <span class="mf">46.28</span>
<span class="n">levenberg</span><span class="o">-</span><span class="n">marquardt</span><span class="o">+</span><span class="n">accel</span> <span class="mi">22</span>    <span class="mi">23</span>   <span class="mi">45</span>    <span class="mi">23</span>     <span class="mi">22</span>   <span class="mf">7.1218e+18</span> <span class="mf">1.9555e-02</span> <span class="mf">447.64</span>  <span class="mf">2.5044e-01</span>  <span class="mf">33.92</span>
<span class="n">dogleg</span>                    <span class="mi">37</span>    <span class="mi">87</span>   <span class="mi">36</span>    <span class="mi">36</span>     <span class="mi">0</span>    <span class="mf">7.1218e+18</span> <span class="mf">1.9555e-02</span> <span class="mf">447.59</span>  <span class="mf">2.5044e-01</span>  <span class="mf">56.05</span>
<span class="n">double</span><span class="o">-</span><span class="n">dogleg</span>             <span class="mi">35</span>    <span class="mi">88</span>   <span class="mi">34</span>    <span class="mi">34</span>     <span class="mi">0</span>    <span class="mf">7.1218e+18</span> <span class="mf">1.9555e-02</span> <span class="mf">447.62</span>  <span class="mf">2.5044e-01</span>  <span class="mf">52.65</span>
<span class="mi">2</span><span class="n">D</span><span class="o">-</span><span class="n">subspace</span>               <span class="mi">37</span>    <span class="mi">88</span>   <span class="mi">36</span>    <span class="mi">36</span>     <span class="mi">0</span>    <span class="mf">7.1218e+18</span> <span class="mf">1.9555e-02</span> <span class="mf">447.71</span>  <span class="mf">2.5044e-01</span>  <span class="mf">59.75</span>
<span class="n">steihaug</span><span class="o">-</span><span class="n">toint</span>            <span class="mi">35</span>    <span class="mi">88</span>   <span class="mi">345</span>   <span class="mi">0</span>      <span class="mi">0</span>    <span class="mf">7.1218e+18</span> <span class="mf">1.9555e-02</span> <span class="n">inf</span>     <span class="mf">2.5044e-01</span>  <span class="mf">0.09</span>
</pre></div>
</div>
<p>The first five rows use methods based on factoring the dense <img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/> matrix
while the last row uses the iterative Steihaug-Toint method. While the number
of Jacobian matrix-vector products (NJUEV) is less for the dense methods, the added time
to construct and factor the <img class="math" src="_images/math/111350b6d27d4582f99dd23332895eec40712733.png" alt="J^T J"/> matrix (NJTJEV) results in a much larger runtime than the
iterative method (see last column).</p>
<p>The program is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;sys/time.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_blas.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multilarge_nlinear.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_spblas.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_spmatrix.h&gt;</span>

<span class="o">/*</span> <span class="n">parameters</span> <span class="k">for</span> <span class="n">functions</span> <span class="o">*/</span>
<span class="n">struct</span> <span class="n">model_params</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">alpha</span><span class="p">;</span>
  <span class="n">gsl_spmatrix</span> <span class="o">*</span><span class="n">J</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">/*</span> <span class="n">penalty</span> <span class="n">function</span> <span class="o">*/</span>
<span class="nb">int</span>
<span class="n">penalty_f</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">sqrt_alpha</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">double</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

      <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sqrt_alpha</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">));</span>

      <span class="nb">sum</span> <span class="o">+=</span> <span class="n">xi</span> <span class="o">*</span> <span class="n">xi</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">penalty_df</span> <span class="p">(</span><span class="n">CBLAS_TRANSPOSE_t</span> <span class="n">TransJ</span><span class="p">,</span> <span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span> <span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span>
            <span class="n">gsl_matrix</span> <span class="o">*</span> <span class="n">JTJ</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">model_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">j</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="ow">in</span> <span class="n">last</span> <span class="n">row</span> <span class="n">of</span> <span class="n">J</span> <span class="o">*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">xj</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
      <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">J</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">xj</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="o">/*</span> <span class="n">compute</span> <span class="n">v</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="n">u</span> <span class="o">*/</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">gsl_spblas_dgemv</span><span class="p">(</span><span class="n">TransJ</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">J</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">JTJ</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">gsl_vector_view</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">gsl_matrix_diagonal</span><span class="p">(</span><span class="n">JTJ</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">compute</span> <span class="n">J</span><span class="o">^</span><span class="n">T</span> <span class="n">J</span> <span class="o">=</span> <span class="p">[</span> <span class="n">alpha</span><span class="o">*</span><span class="n">I_p</span> <span class="o">+</span> <span class="mi">4</span> <span class="n">x</span> <span class="n">x</span><span class="o">^</span><span class="n">T</span> <span class="p">]</span> <span class="o">*/</span>
      <span class="n">gsl_matrix_set_zero</span><span class="p">(</span><span class="n">JTJ</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">store</span> <span class="mi">4</span> <span class="n">x</span> <span class="n">x</span><span class="o">^</span><span class="n">T</span> <span class="ow">in</span> <span class="n">lower</span> <span class="n">half</span> <span class="n">of</span> <span class="n">JTJ</span> <span class="o">*/</span>
      <span class="n">gsl_blas_dsyr</span><span class="p">(</span><span class="n">CblasLower</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">JTJ</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">add</span> <span class="n">alpha</span> <span class="n">to</span> <span class="n">diag</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span> <span class="o">*/</span>
      <span class="n">gsl_vector_add_constant</span><span class="p">(</span><span class="o">&amp;</span><span class="n">diag</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">penalty_fvv</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span>
             <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">fvv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">normv</span> <span class="o">=</span> <span class="n">gsl_blas_dnrm2</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

  <span class="n">gsl_vector_set_zero</span><span class="p">(</span><span class="n">fvv</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">fvv</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">normv</span> <span class="o">*</span> <span class="n">normv</span><span class="p">);</span>

  <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">params</span><span class="p">;</span> <span class="o">/*</span> <span class="n">avoid</span> <span class="n">unused</span> <span class="n">parameter</span> <span class="n">warning</span> <span class="o">*/</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">solve_system</span><span class="p">(</span><span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x0</span><span class="p">,</span> <span class="n">gsl_multilarge_nlinear_fdf</span> <span class="o">*</span><span class="n">fdf</span><span class="p">,</span>
             <span class="n">gsl_multilarge_nlinear_parameters</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">gsl_multilarge_nlinear_type</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_trust</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">gtol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">ftol</span> <span class="o">=</span> <span class="mf">1.0e-8</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
  <span class="n">gsl_multilarge_nlinear_workspace</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span>
    <span class="n">gsl_multilarge_nlinear_alloc</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_residual</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_position</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="nb">int</span> <span class="n">info</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">chisq0</span><span class="p">,</span> <span class="n">chisq</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span> <span class="n">xsq</span><span class="p">;</span>
  <span class="n">struct</span> <span class="n">timeval</span> <span class="n">tv0</span><span class="p">,</span> <span class="n">tv1</span><span class="p">;</span>

  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv0</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">initialize</span> <span class="n">solver</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_nlinear_init</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">fdf</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">initial</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq0</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">iterate</span> <span class="n">until</span> <span class="n">convergence</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_nlinear_driver</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">xtol</span><span class="p">,</span> <span class="n">gtol</span><span class="p">,</span> <span class="n">ftol</span><span class="p">,</span>
                                <span class="n">NULL</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv1</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">final</span> <span class="n">cost</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chisq</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">compute</span> <span class="n">final</span> <span class="o">||</span><span class="n">x</span><span class="o">||^</span><span class="mi">2</span> <span class="o">*/</span>
  <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xsq</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">store</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_nlinear_rcond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcond</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">summary</span> <span class="o">*/</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%-25s</span><span class="s2"> %-5zu %-4zu %-5zu %-6zu %-4zu </span><span class="si">%-10.4e</span><span class="s2"> </span><span class="si">%-10.4e</span><span class="s2"> </span><span class="si">%-7.2f</span><span class="s2"> </span><span class="si">%-11.4e</span><span class="s2"> </span><span class="si">%.2f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">gsl_multilarge_nlinear_trs_name</span><span class="p">(</span><span class="n">work</span><span class="p">),</span>
          <span class="n">gsl_multilarge_nlinear_niter</span><span class="p">(</span><span class="n">work</span><span class="p">),</span>
          <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevalf</span><span class="p">,</span>
          <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevaldfu</span><span class="p">,</span>
          <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevaldf2</span><span class="p">,</span>
          <span class="n">fdf</span><span class="o">-&gt;</span><span class="n">nevalfvv</span><span class="p">,</span>
          <span class="n">chisq0</span><span class="p">,</span>
          <span class="n">chisq</span><span class="p">,</span>
          <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">,</span>
          <span class="n">xsq</span><span class="p">,</span>
          <span class="p">(</span><span class="n">tv1</span><span class="o">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">tv0</span><span class="o">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0e-6</span> <span class="o">*</span> <span class="p">(</span><span class="n">tv1</span><span class="o">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">tv0</span><span class="o">.</span><span class="n">tv_usec</span><span class="p">));</span>

  <span class="n">gsl_multilarge_nlinear_free</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">allocate</span> <span class="n">sparse</span> <span class="n">Jacobian</span> <span class="n">matrix</span> <span class="k">with</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="n">non</span><span class="o">-</span><span class="n">zero</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">triplet</span> <span class="nb">format</span> <span class="o">*/</span>
  <span class="n">gsl_spmatrix</span> <span class="o">*</span><span class="n">J</span> <span class="o">=</span> <span class="n">gsl_spmatrix_alloc_nzmax</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">GSL_SPMATRIX_TRIPLET</span><span class="p">);</span>

  <span class="n">gsl_multilarge_nlinear_fdf</span> <span class="n">fdf</span><span class="p">;</span>
  <span class="n">gsl_multilarge_nlinear_parameters</span> <span class="n">fdf_params</span> <span class="o">=</span>
    <span class="n">gsl_multilarge_nlinear_default_parameters</span><span class="p">();</span>
  <span class="n">struct</span> <span class="n">model_params</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">params</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0e-5</span><span class="p">;</span>
  <span class="n">params</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">define</span> <span class="n">function</span> <span class="n">to</span> <span class="n">be</span> <span class="n">minimized</span> <span class="o">*/</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">penalty_f</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">penalty_df</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">fvv</span> <span class="o">=</span> <span class="n">penalty_fvv</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">fdf</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">/*</span> <span class="n">starting</span> <span class="n">point</span> <span class="o">*/</span>
      <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">store</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">I_p</span> <span class="ow">in</span> <span class="n">upper</span> <span class="n">p</span><span class="o">-</span><span class="n">by</span><span class="o">-</span><span class="n">p</span> <span class="n">block</span> <span class="n">of</span> <span class="n">J</span> <span class="o">*/</span>
      <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">alpha</span><span class="p">));</span>
    <span class="p">}</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%-25s</span><span class="s2"> </span><span class="si">%-4s</span><span class="s2"> </span><span class="si">%-4s</span><span class="s2"> </span><span class="si">%-5s</span><span class="s2"> </span><span class="si">%-6s</span><span class="s2"> </span><span class="si">%-4s</span><span class="s2"> </span><span class="si">%-10s</span><span class="s2"> </span><span class="si">%-10s</span><span class="s2"> </span><span class="si">%-7s</span><span class="s2"> </span><span class="si">%-11s</span><span class="s2"> </span><span class="si">%-10s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="s2">&quot;Method&quot;</span><span class="p">,</span> <span class="s2">&quot;NITER&quot;</span><span class="p">,</span> <span class="s2">&quot;NFEV&quot;</span><span class="p">,</span> <span class="s2">&quot;NJUEV&quot;</span><span class="p">,</span> <span class="s2">&quot;NJTJEV&quot;</span><span class="p">,</span> <span class="s2">&quot;NAEV&quot;</span><span class="p">,</span> <span class="s2">&quot;Init Cost&quot;</span><span class="p">,</span>
          <span class="s2">&quot;Final cost&quot;</span><span class="p">,</span> <span class="s2">&quot;cond(J)&quot;</span><span class="p">,</span> <span class="s2">&quot;Final |x|^2&quot;</span><span class="p">,</span> <span class="s2">&quot;Time (s)&quot;</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_scale_levenberg</span><span class="p">;</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_trs_lm</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_trs_lmaccel</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_trs_dogleg</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_trs_ddogleg</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_trs_subspace2D</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">fdf_params</span><span class="o">.</span><span class="n">trs</span> <span class="o">=</span> <span class="n">gsl_multilarge_nlinear_trs_cgst</span><span class="p">;</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdf_params</span><span class="p">);</span>

  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_free</span><span class="p">(</span><span class="n">J</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="references-and-further-reading">
<h2>References and Further Reading<a class="headerlink" href="#references-and-further-reading" title="Permalink to this heading">¶</a></h2>
<p>The following publications are relevant to the algorithms described
in this section,</p>
<ul class="simple">
<li><p>J.J. Moré, <em>The Levenberg-Marquardt Algorithm: Implementation and
Theory</em>, Lecture Notes in Mathematics, v630 (1978), ed G. Watson.</p></li>
<li><p>H. B. Nielsen, “Damping Parameter in Marquardt’s Method”,
IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-1999-05
(1999).</p></li>
<li><p>K. Madsen and H. B. Nielsen, “Introduction to Optimization and Data
Fitting”, IMM Department of Mathematical Modeling, DTU, 2010.</p></li>
<li><p>J. E. Dennis and R. B. Schnabel, Numerical Methods for Unconstrained
Optimization and Nonlinear Equations, SIAM, 1996.</p></li>
<li><p>M. K. Transtrum, B. B. Machta, and J. P. Sethna,
Geometry of nonlinear least squares with applications to sloppy models and optimization,
Phys. Rev. E 83, 036701, 2011.</p></li>
<li><p>M. K. Transtrum and J. P. Sethna, Improvements to the Levenberg-Marquardt
algorithm for nonlinear least-squares minimization, arXiv:1201.5885, 2012.</p></li>
<li><p>J.J. Moré, B.S. Garbow, K.E. Hillstrom, “Testing Unconstrained
Optimization Software”, ACM Transactions on Mathematical Software, Vol
7, No 1 (1981), p 17–41.</p></li>
<li><p>H. B. Nielsen, “UCTP Test Problems for Unconstrained Optimization”,
IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-2000-17
(2000).</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="bspline.html" class="btn btn-neutral float-right" title="Basis Splines" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="lls.html" class="btn btn-neutral float-left" title="Linear Least-Squares Fitting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 1996-2024 The GSL Team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>