

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>One Dimensional Root-Finding &mdash; GSL 2.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="One Dimensional Minimization" href="min.html" />
    <link rel="prev" title="Discrete Hankel Transforms" href="dht.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GSL
          

          
          </a>

          
            
            
              <div class="version">
                2.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Using the Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="err.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Mathematical Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="poly.html">Polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="specfunc.html">Special Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="vectors.html">Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiset.html">Multisets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="eigen.html">Eigensystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Fast Fourier Transforms (FFTs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Numerical Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="rng.html">Random Number Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="qrng.html">Quasi-Random Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="randist.html">Random Number Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="rstat.html">Running Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="movstat.html">Moving Window Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Digital Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="histogram.html">Histograms</a></li>
<li class="toctree-l1"><a class="reference internal" href="ntuple.html">N-tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="montecarlo.html">Monte Carlo Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="siman.html">Simulated Annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="ode-initval.html">Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="interp.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="diff.html">Numerical Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheb.html">Chebyshev Approximations</a></li>
<li class="toctree-l1"><a class="reference internal" href="sum.html">Series Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dwt.html">Wavelet Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dht.html">Discrete Hankel Transforms</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">One Dimensional Root-Finding</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#caveats">Caveats</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-the-solver">Initializing the Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#providing-the-function-to-solve">Providing the function to solve</a></li>
<li class="toctree-l2"><a class="reference internal" href="#search-bounds-and-guesses">Search Bounds and Guesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#search-stopping-parameters">Search Stopping Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#root-bracketing-algorithms">Root Bracketing Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#root-finding-algorithms-using-derivatives">Root Finding Algorithms using Derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="min.html">One Dimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiroots.html">Multidimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="multimin.html">Multidimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="lls.html">Linear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="nls.html">Nonlinear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="bspline.html">Basis Splines</a></li>
<li class="toctree-l1"><a class="reference internal" href="spmatrix.html">Sparse Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="spblas.html">Sparse BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="splinalg.html">Sparse Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="const.html">Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="ieee754.html">IEEE floating-point arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debugging Numerical Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributors to GSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoconf.html">Autoconf Macros</a></li>
<li class="toctree-l1"><a class="reference internal" href="cblas.html">GSL CBLAS Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpl.html">GNU General Public License</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdl.html">GNU Free Documentation License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GSL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>One Dimensional Root-Finding</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/roots.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="min.html" class="btn btn-neutral float-right" title="One Dimensional Minimization" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="dht.html" class="btn btn-neutral float-left" title="Discrete Hankel Transforms" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="one-dimensional-root-finding">
<span id="index-0"></span><h1>One Dimensional Root-Finding<a class="headerlink" href="#one-dimensional-root-finding" title="Permalink to this heading">¶</a></h1>
<p>This chapter describes routines for finding roots of arbitrary
one-dimensional functions.  The library provides low level components
for a variety of iterative solvers and convergence tests.  These can be
combined by the user to achieve the desired solution, with full access
to the intermediate steps of the iteration.  Each class of methods uses
the same framework, so that you can switch between solvers at runtime
without needing to recompile your program.  Each instance of a solver
keeps track of its own state, allowing the solvers to be used in
multi-threaded programs.</p>
<p>The header file <code class="file docutils literal notranslate"><span class="pre">gsl_roots.h</span></code> contains prototypes for the root
finding functions and related declarations.</p>
<div class="section" id="overview">
<span id="index-1"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>One-dimensional root finding algorithms can be divided into two classes,
<em>root bracketing</em> and <em>root polishing</em>.  Algorithms which proceed
by bracketing a root are guaranteed to converge.  Bracketing algorithms
begin with a bounded region known to contain a root.  The size of this
bounded region is reduced, iteratively, until it encloses the root to a
desired tolerance.  This provides a rigorous error estimate for the
location of the root.</p>
<p>The technique of <em>root polishing</em> attempts to improve an initial
guess to the root.  These algorithms converge only if started “close
enough” to a root, and sacrifice a rigorous error bound for speed.  By
approximating the behavior of a function in the vicinity of a root they
attempt to find a higher order improvement of an initial guess.  When the
behavior of the function is compatible with the algorithm and a good
initial guess is available a polishing algorithm can provide rapid
convergence.</p>
<p>In GSL both types of algorithm are available in similar frameworks.  The
user provides a high-level driver for the algorithms, and the library
provides the individual functions necessary for each of the steps.
There are three main phases of the iteration.  The steps are,</p>
<ul class="simple">
<li><p>initialize solver state, <code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code>, for algorithm <code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p>update <code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code> using the iteration <code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p>test <code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code> for convergence, and repeat iteration if necessary</p></li>
</ul>
<p>The state for bracketing solvers is held in a <a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_root_fsolver</span></code></a>
struct.  The updating procedure uses only function evaluations (not
derivatives).  The state for root polishing solvers is held in a
<a class="reference internal" href="#c.gsl_root_fdfsolver" title="gsl_root_fdfsolver"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_root_fdfsolver</span></code></a> struct.  The updates require both the function
and its derivative (hence the name <code class="code docutils literal notranslate"><span class="pre">fdf</span></code>) to be supplied by the
user.</p>
</div>
<div class="section" id="caveats">
<span id="index-2"></span><h2>Caveats<a class="headerlink" href="#caveats" title="Permalink to this heading">¶</a></h2>
<p>Note that root finding functions can only search for one root at a time.
When there are several roots in the search area, the first root to be
found will be returned; however it is difficult to predict which of the
roots this will be. <em>In most cases, no error will be reported if
you try to find a root in an area where there is more than one.</em></p>
<p>Care must be taken when a function may have a multiple root (such as
<img class="math" src="_images/math/a36f6852f4d972ac2d1814427cec1c8ed8c1ffb0.png" alt="f(x) = (x-x_0)^2"/> or
<img class="math" src="_images/math/5e4e34ecdf3d92875a97f5efbebd5d32bcee5f60.png" alt="f(x) = (x-x_0)^3"/>.
It is not possible to use root-bracketing algorithms on
even-multiplicity roots.  For these algorithms the initial interval must
contain a zero-crossing, where the function is negative at one end of
the interval and positive at the other end.  Roots with even-multiplicity
do not cross zero, but only touch it instantaneously.  Algorithms based
on root bracketing will still work for odd-multiplicity roots
(e.g. cubic, quintic, …).
Root polishing algorithms generally work with higher multiplicity roots,
but at a reduced rate of convergence.  In these cases the <em>Steffenson
algorithm</em> can be used to accelerate the convergence of multiple roots.</p>
<p>While it is not absolutely required that <img class="math" src="_images/math/297ac74049e250d35993e62353e189c7bfda5398.png" alt="f"/> have a root within the
search region, numerical root finding functions should not be used
haphazardly to check for the <em>existence</em> of roots.  There are better
ways to do this.  Because it is easy to create situations where numerical
root finders can fail, it is a bad idea to throw a root finder at a
function you do not know much about.  In general it is best to examine
the function visually by plotting before searching for a root.</p>
</div>
<div class="section" id="initializing-the-solver">
<h2>Initializing the Solver<a class="headerlink" href="#initializing-the-solver" title="Permalink to this heading">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_root_fsolver">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver</span></span></span><a class="headerlink" href="#c.gsl_root_fsolver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a workspace for finding roots using methods which do not require
derivatives.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver</span></span></span><a class="headerlink" href="#c.gsl_root_fdfsolver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is a workspace for finding roots using methods which require
derivatives.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_alloc">
<a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fsolver_type" title="gsl_root_fsolver_type"><span class="n"><span class="pre">gsl_root_fsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">T</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a pointer to a newly allocated instance of a
solver of type <a class="reference internal" href="#c.gsl_root_fsolver_alloc" title="T"><code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code></a>.  For example, the following code creates an
instance of a bisection solver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">gsl_root_fsolver_type</span> <span class="o">*</span> <span class="n">T</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_bisection</span><span class="p">;</span>
<span class="n">gsl_root_fsolver</span> <span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">);</span>
</pre></div>
</div>
<p>If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <a class="reference internal" href="err.html#c.GSL_ENOMEM" title="GSL_ENOMEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_ENOMEM</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_alloc">
<a class="reference internal" href="#c.gsl_root_fdfsolver" title="gsl_root_fdfsolver"><span class="n"><span class="pre">gsl_root_fdfsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fdfsolver_type" title="gsl_root_fdfsolver_type"><span class="n"><span class="pre">gsl_root_fdfsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">T</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fdfsolver_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a pointer to a newly allocated instance of a
derivative-based solver of type <a class="reference internal" href="#c.gsl_root_fdfsolver_alloc" title="T"><code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code></a>.  For example, the following
code creates an instance of a Newton-Raphson solver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">gsl_root_fdfsolver_type</span> <span class="o">*</span> <span class="n">T</span> <span class="o">=</span> <span class="n">gsl_root_fdfsolver_newton</span><span class="p">;</span>
<span class="n">gsl_root_fdfsolver</span> <span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">gsl_root_fdfsolver_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">);</span>
</pre></div>
</div>
<p>If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of <a class="reference internal" href="err.html#c.GSL_ENOMEM" title="GSL_ENOMEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_ENOMEM</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_set">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_function" title="gsl_function"><span class="n"><span class="pre">gsl_function</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x_lower</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x_upper</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function initializes, or reinitializes, an existing solver <a class="reference internal" href="#c.gsl_root_fsolver_set" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>
to use the function <a class="reference internal" href="#c.gsl_root_fsolver_set" title="f"><code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code></a> and the initial search interval
[<a class="reference internal" href="#c.gsl_root_fsolver_set" title="x_lower"><code class="xref c c-data docutils literal notranslate"><span class="pre">x_lower</span></code></a>, <a class="reference internal" href="#c.gsl_root_fsolver_set" title="x_upper"><code class="xref c c-data docutils literal notranslate"><span class="pre">x_upper</span></code></a>].</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_set">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_root_fdfsolver" title="gsl_root_fdfsolver"><span class="n"><span class="pre">gsl_root_fdfsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.gsl_function_fdf" title="gsl_function_fdf"><span class="n"><span class="pre">gsl_function_fdf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fdf</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">root</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fdfsolver_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function initializes, or reinitializes, an existing solver <a class="reference internal" href="#c.gsl_root_fdfsolver_set" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>
to use the function and derivative <a class="reference internal" href="#c.gsl_root_fdfsolver_set" title="fdf"><code class="xref c c-data docutils literal notranslate"><span class="pre">fdf</span></code></a> and the initial guess
<a class="reference internal" href="#c.gsl_root_fdfsolver_set" title="root"><code class="xref c c-data docutils literal notranslate"><span class="pre">root</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_free" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_root_fdfsolver" title="gsl_root_fdfsolver"><span class="n"><span class="pre">gsl_root_fdfsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fdfsolver_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions free all the memory associated with the solver <a class="reference internal" href="#c.gsl_root_fdfsolver_free" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_name" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fdfsolver" title="gsl_root_fdfsolver"><span class="n"><span class="pre">gsl_root_fdfsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fdfsolver_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return a pointer to the name of the solver.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;s is a &#39;</span><span class="si">%s</span><span class="s2">&#39; solver</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_root_fsolver_name</span> <span class="p">(</span><span class="n">s</span><span class="p">));</span>
</pre></div>
</div>
<p>would print something like <code class="code docutils literal notranslate"><span class="pre">s</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">'bisection'</span> <span class="pre">solver</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="providing-the-function-to-solve">
<span id="providing-function-to-solve"></span><span id="index-3"></span><h2>Providing the function to solve<a class="headerlink" href="#providing-the-function-to-solve" title="Permalink to this heading">¶</a></h2>
<p>You must provide a continuous function of one variable for the root
finders to operate on, and, sometimes, its first derivative.  In order
to allow for general parameters the functions are defined by the
following data types:</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_function">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_function</span></span></span><a class="headerlink" href="#c.gsl_function" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This data type defines a general function with parameters.</p>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">(*</span> <span class="pre">function)</span> <span class="pre">(double</span> <span class="pre">x,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params)</span></code></p>
<blockquote>
<div><p>this function should return the value
<img class="math" src="_images/math/6dea37df222c0d9f1bcf0f1a4cf97b1913ac5cc7.png" alt="f(x,params)"/> for argument <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code></p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">params</span></code></p>
<blockquote>
<div><p>a pointer to the parameters of the function</p>
</div></blockquote>
</dd></dl>

<p>Here is an example for the general quadratic function,</p>
<div class="math">
<p><img src="_images/math/966ad15dc12308976842c04a35f47574d70fc117.png" alt="f(x) = a x^2 + b x + c"/></p>
</div><p>with <img class="math" src="_images/math/97a91269f9bb43e573b4c0c9928c5e5ef035c546.png" alt="a = 3"/>, <img class="math" src="_images/math/9766d2b3d7bf2fc2584eb6c09105607788004682.png" alt="b = 2"/>, <img class="math" src="_images/math/43cb59c460acd4b894e8d23b2b56e84e918d2ae0.png" alt="c = 1"/>.  The following code
defines a <a class="reference internal" href="#c.gsl_function" title="gsl_function"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_function</span></code></a> <code class="code docutils literal notranslate"><span class="pre">F</span></code> which you could pass to a root
finder as a function pointer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">my_f_params</span> <span class="p">{</span> <span class="n">double</span> <span class="n">a</span><span class="p">;</span> <span class="n">double</span> <span class="n">b</span><span class="p">;</span> <span class="n">double</span> <span class="n">c</span><span class="p">;</span> <span class="p">};</span>

<span class="n">double</span>
<span class="n">my_f</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">struct</span> <span class="n">my_f_params</span> <span class="o">*</span> <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">my_f_params</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
    <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
    <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>

    <span class="k">return</span>  <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
  <span class="p">}</span>

<span class="n">gsl_function</span> <span class="n">F</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">my_f_params</span> <span class="n">params</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>

<span class="n">F</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_f</span><span class="p">;</span>
<span class="n">F</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">;</span>
</pre></div>
</div>
<p>The function <img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/> can be evaluated using the macro
<code class="code docutils literal notranslate"><span class="pre">GSL_FN_EVAL(&amp;F,x)</span></code> defined in <code class="file docutils literal notranslate"><span class="pre">gsl_math.h</span></code>.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_function_fdf">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_function_fdf</span></span></span><a class="headerlink" href="#c.gsl_function_fdf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This data type defines a general function with parameters and its first
derivative.</p>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">(*</span> <span class="pre">f)</span> <span class="pre">(double</span> <span class="pre">x,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params)</span></code></p>
<blockquote>
<div><p>this function should return the value of
<img class="math" src="_images/math/6dea37df222c0d9f1bcf0f1a4cf97b1913ac5cc7.png" alt="f(x,params)"/> for argument <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code></p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">(*</span> <span class="pre">df)</span> <span class="pre">(double</span> <span class="pre">x,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params)</span></code></p>
<blockquote>
<div><p>this function should return the value of the derivative of <code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code> with
respect to <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code>,
<img class="math" src="_images/math/f06f682467a9e086f26f5ef10e1907082254bbb1.png" alt="f'(x,params)"/>, for argument <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code></p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*</span> <span class="pre">fdf)</span> <span class="pre">(double</span> <span class="pre">x,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params,</span> <span class="pre">double</span> <span class="pre">*</span> <span class="pre">f,</span> <span class="pre">double</span> <span class="pre">*</span> <span class="pre">df)</span></code></p>
<blockquote>
<div><p>this function should set the values of the function <code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code> to
<img class="math" src="_images/math/6dea37df222c0d9f1bcf0f1a4cf97b1913ac5cc7.png" alt="f(x,params)"/>
and its derivative <code class="xref c c-data docutils literal notranslate"><span class="pre">df</span></code> to
<img class="math" src="_images/math/f06f682467a9e086f26f5ef10e1907082254bbb1.png" alt="f'(x,params)"/>
for argument <code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code> and parameters <code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code>.  This function
provides an optimization of the separate functions for <img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/> and
<img class="math" src="_images/math/1d6adaa4a67fd65726e3bd737c5224834028ac67.png" alt="f'(x)"/>—it is always faster to compute the function and its
derivative at the same time.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">params</span></code></p>
<blockquote>
<div><p>a pointer to the parameters of the function</p>
</div></blockquote>
</dd></dl>

<p>Here is an example where
<img class="math" src="_images/math/b16ff362a4564e3971641058fe433780921815e6.png" alt="f(x) = \exp(2x)"/>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span>
<span class="n">my_f</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span> <span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">exp</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">double</span>
<span class="n">my_df</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span> <span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">exp</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">my_fdf</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span> <span class="n">params</span><span class="p">,</span>
        <span class="n">double</span> <span class="o">*</span> <span class="n">f</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">double</span> <span class="n">t</span> <span class="o">=</span> <span class="n">exp</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>

   <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
   <span class="o">*</span><span class="n">df</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">uses</span> <span class="n">existing</span> <span class="n">value</span> <span class="o">*/</span>
<span class="p">}</span>

<span class="n">gsl_function_fdf</span> <span class="n">FDF</span><span class="p">;</span>

<span class="n">FDF</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_f</span><span class="p">;</span>
<span class="n">FDF</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_df</span><span class="p">;</span>
<span class="n">FDF</span><span class="o">.</span><span class="n">fdf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_fdf</span><span class="p">;</span>
<span class="n">FDF</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The function <img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/> can be evaluated using the macro
<code class="code docutils literal notranslate"><span class="pre">GSL_FN_FDF_EVAL_F(&amp;FDF,x)</span></code> and the derivative <img class="math" src="_images/math/1d6adaa4a67fd65726e3bd737c5224834028ac67.png" alt="f'(x)"/> can
be evaluated using the macro <code class="code docutils literal notranslate"><span class="pre">GSL_FN_FDF_EVAL_DF(&amp;FDF,x)</span></code>.  Both
the function <img class="math" src="_images/math/724e75752d713d79d99e8474afceac28eaf5c76d.png" alt="y = f(x)"/> and its derivative <img class="math" src="_images/math/f8a6f79dff634fbcd0788d1eb6b742851ab20a5b.png" alt="dy = f'(x)"/> can
be evaluated at the same time using the macro
<code class="code docutils literal notranslate"><span class="pre">GSL_FN_FDF_EVAL_F_DF(&amp;FDF,x,y,dy)</span></code>.  The macro stores
<img class="math" src="_images/math/affcac78cbf3ede97b9d3996b222aff08b185b08.png" alt="f(x)"/> in its <code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code> argument and <img class="math" src="_images/math/1d6adaa4a67fd65726e3bd737c5224834028ac67.png" alt="f'(x)"/> in its <code class="xref c c-data docutils literal notranslate"><span class="pre">dy</span></code>
argument—both of these should be pointers to <code class="code docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
<div class="section" id="search-bounds-and-guesses">
<span id="index-4"></span><h2>Search Bounds and Guesses<a class="headerlink" href="#search-bounds-and-guesses" title="Permalink to this heading">¶</a></h2>
<p>You provide either search bounds or an initial guess; this section
explains how search bounds and guesses work and how function arguments
control them.</p>
<p>A guess is simply an <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> value which is iterated until it is within
the desired precision of a root.  It takes the form of a <code class="code docutils literal notranslate"><span class="pre">double</span></code>.</p>
<p>Search bounds are the endpoints of an interval which is iterated until
the length of the interval is smaller than the requested precision.  The
interval is defined by two values, the lower limit and the upper limit.
Whether the endpoints are intended to be included in the interval or not
depends on the context in which the interval is used.</p>
</div>
<div class="section" id="iteration">
<h2>Iteration<a class="headerlink" href="#iteration" title="Permalink to this heading">¶</a></h2>
<p>The following functions drive the iteration of each algorithm.  Each
function performs one iteration to update the state of any solver of the
corresponding type.  The same functions work for all solvers so that
different methods can be substituted at runtime without modifications to
the code.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_iterate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_iterate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_iterate" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_iterate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_iterate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_root_fdfsolver" title="gsl_root_fdfsolver"><span class="n"><span class="pre">gsl_root_fdfsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fdfsolver_iterate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions perform a single iteration of the solver <a class="reference internal" href="#c.gsl_root_fdfsolver_iterate" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>.  If the
iteration encounters an unexpected problem then an error code will be
returned,</p>
<p><code class="code docutils literal notranslate"><span class="pre">GSL_EBADFUNC</span></code></p>
<blockquote>
<div><p>the iteration encountered a singular point where the function or its
derivative evaluated to <code class="code docutils literal notranslate"><span class="pre">Inf</span></code> or <code class="code docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">GSL_EZERODIV</span></code></p>
<blockquote>
<div><p>the derivative of the function vanished at the iteration point,
preventing the algorithm from continuing without a division by zero.</p>
</div></blockquote>
</dd></dl>

<p>The solver maintains a current best estimate of the root at all
times.  The bracketing solvers also keep track of the current best
interval bounding the root.  This information can be accessed with the
following auxiliary functions,</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_root">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_root</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_root" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_root">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_root</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fdfsolver" title="gsl_root_fdfsolver"><span class="n"><span class="pre">gsl_root_fdfsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fdfsolver_root" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return the current estimate of the root for the solver <a class="reference internal" href="#c.gsl_root_fdfsolver_root" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_x_lower">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_x_lower</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_x_lower" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_root_fsolver_x_upper">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_x_upper</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_root_fsolver" title="gsl_root_fsolver"><span class="n"><span class="pre">gsl_root_fsolver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_fsolver_x_upper" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions return the current bracketing interval for the solver <a class="reference internal" href="#c.gsl_root_fsolver_x_upper" title="s"><code class="xref c c-data docutils literal notranslate"><span class="pre">s</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="search-stopping-parameters">
<span id="index-5"></span><h2>Search Stopping Parameters<a class="headerlink" href="#search-stopping-parameters" title="Permalink to this heading">¶</a></h2>
<p>A root finding procedure should stop when one of the following conditions is
true:</p>
<ul class="simple">
<li><p>A root has been found to within the user-specified precision.</p></li>
<li><p>A user-specified maximum number of iterations has been reached.</p></li>
<li><p>An error has occurred.</p></li>
</ul>
<p>The handling of these conditions is under user control.  The functions
below allow the user to test the precision of the current result in
several standard ways.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_test_interval">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_test_interval</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x_lower</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x_upper</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">epsabs</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">epsrel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_test_interval" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function tests for the convergence of the interval [<a class="reference internal" href="#c.gsl_root_test_interval" title="x_lower"><code class="xref c c-data docutils literal notranslate"><span class="pre">x_lower</span></code></a>,
<a class="reference internal" href="#c.gsl_root_test_interval" title="x_upper"><code class="xref c c-data docutils literal notranslate"><span class="pre">x_upper</span></code></a>] with absolute error <a class="reference internal" href="#c.gsl_root_test_interval" title="epsabs"><code class="xref c c-data docutils literal notranslate"><span class="pre">epsabs</span></code></a> and relative error
<a class="reference internal" href="#c.gsl_root_test_interval" title="epsrel"><code class="xref c c-data docutils literal notranslate"><span class="pre">epsrel</span></code></a>.  The test returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SUCCESS</span></code> if the following
condition is achieved,</p>
<div class="math">
<p><img src="_images/math/934ff3f27d2a473824cdfdcdab443f0ecb2268e4.png" alt="|a - b| &lt; \hbox{\it epsabs} + \hbox{\it epsrel\/}\, \min(|a|,|b|)"/></p>
</div><p>when the interval <img class="math" src="_images/math/b7dfd6c9d58c7a97d19cba79a64601e86331937f.png" alt="x = [a,b]"/> does not include the origin.  If the
interval includes the origin then <img class="math" src="_images/math/f6f98e4bf95ec85aaf18edeb51c1a71073108ab5.png" alt="\min(|a|,|b|)"/> is replaced by
zero (which is the minimum value of <img class="math" src="_images/math/a55166d4393854cd267e7e344b9b6c2547f5a08c.png" alt="|x|"/> over the interval).  This
ensures that the relative error is accurately estimated for roots close
to the origin.</p>
<p>This condition on the interval also implies that any estimate of the
root <img class="math" src="_images/math/532311b00f74167e01e5b4d047f2c07f678dd321.png" alt="r"/> in the interval satisfies the same condition with respect
to the true root <img class="math" src="_images/math/9a8286f91070fedf75146a995d010cda49fbaa8e.png" alt="r^*"/>,</p>
<div class="math">
<p><img src="_images/math/18d749599b7f500c61c35df9faf95e7c0b387c5c.png" alt="|r - r^*| &lt; \hbox{\it epsabs} + \hbox{\it epsrel\/}\, r^*"/></p>
</div><p>assuming that the true root <img class="math" src="_images/math/9a8286f91070fedf75146a995d010cda49fbaa8e.png" alt="r^*"/> is contained within the interval.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_test_delta">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_test_delta</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x0</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">epsabs</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">epsrel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_test_delta" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function tests for the convergence of the sequence <a class="reference internal" href="#c.gsl_root_test_delta" title="x0"><code class="xref c c-data docutils literal notranslate"><span class="pre">x0</span></code></a>,
<a class="reference internal" href="#c.gsl_root_test_delta" title="x1"><code class="xref c c-data docutils literal notranslate"><span class="pre">x1</span></code></a> with absolute error <a class="reference internal" href="#c.gsl_root_test_delta" title="epsabs"><code class="xref c c-data docutils literal notranslate"><span class="pre">epsabs</span></code></a> and relative error
<a class="reference internal" href="#c.gsl_root_test_delta" title="epsrel"><code class="xref c c-data docutils literal notranslate"><span class="pre">epsrel</span></code></a>.  The test returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SUCCESS</span></code> if the following
condition is achieved,</p>
<div class="math">
<p><img src="_images/math/6a7ff1852b62db4c040a0dfdce40da05830b8cb8.png" alt="|x_1 - x_0| &lt; \hbox{\it epsabs} + \hbox{\it epsrel\/}\, |x_1|"/></p>
</div><p>and returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_CONTINUE</span></code> otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_root_test_residual">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_test_residual</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">epsabs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_root_test_residual" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function tests the residual value <a class="reference internal" href="#c.gsl_root_test_residual" title="f"><code class="xref c c-data docutils literal notranslate"><span class="pre">f</span></code></a> against the absolute
error bound <a class="reference internal" href="#c.gsl_root_test_residual" title="epsabs"><code class="xref c c-data docutils literal notranslate"><span class="pre">epsabs</span></code></a>.  The test returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SUCCESS</span></code> if the
following condition is achieved,</p>
<div class="math">
<p><img src="_images/math/17326d5c7efd195098474b471698d8b03c9c17d2.png" alt="|f| &lt; \hbox{\it epsabs}"/></p>
</div><p>and returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_CONTINUE</span></code> otherwise.  This criterion is suitable
for situations where the precise location of the root, <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>, is
unimportant provided a value can be found where the residual,
<img class="math" src="_images/math/40665784a54b72bbce54e7200f5e0ce175c3456c.png" alt="|f(x)|"/>, is small enough.</p>
</dd></dl>

</div>
<div class="section" id="root-bracketing-algorithms">
<h2>Root Bracketing Algorithms<a class="headerlink" href="#root-bracketing-algorithms" title="Permalink to this heading">¶</a></h2>
<p>The root bracketing algorithms described in this section require an
initial interval which is guaranteed to contain a root—if <img class="math" src="_images/math/ab8ec5d5a907c2d63aba6be0e2e1abbe131f208c.png" alt="a"/>
and <img class="math" src="_images/math/b9e7a11d6c55d13df40be0f0e33a142fd09d27af.png" alt="b"/> are the endpoints of the interval then <img class="math" src="_images/math/aaf22794c852db3fcb35c4d95a2d9b53cea58ea6.png" alt="f(a)"/> must
differ in sign from <img class="math" src="_images/math/399d21b704974237513e88a4dc291fcf0c705753.png" alt="f(b)"/>.  This ensures that the function crosses
zero at least once in the interval.  If a valid initial interval is used
then these algorithm cannot fail, provided the function is well-behaved.</p>
<p>Note that a bracketing algorithm cannot find roots of even degree, since
these do not cross the <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>-axis.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_type">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_type</span></span></span><a class="headerlink" href="#c.gsl_root_fsolver_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><span class="target" id="index-6"></span><dl class="c var">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_type.gsl_root_fsolver_bisection">
<a class="reference internal" href="#c.gsl_root_fsolver_type" title="gsl_root_fsolver_type"><span class="n"><span class="pre">gsl_root_fsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_bisection</span></span></span><a class="headerlink" href="#c.gsl_root_fsolver_type.gsl_root_fsolver_bisection" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <em>bisection algorithm</em> is the simplest method of bracketing the
roots of a function.   It is the slowest algorithm provided by
the library, with linear convergence.</p>
<p>On each iteration, the interval is bisected and the value of the
function at the midpoint is calculated.  The sign of this value is used
to determine which half of the interval does not contain a root.  That
half is discarded to give a new, smaller interval containing the
root.  This procedure can be continued indefinitely until the interval is
sufficiently small.</p>
<p>At any time the current estimate of the root is taken as the midpoint of
the interval.</p>
</dd></dl>

<span class="target" id="index-7"></span><dl class="c var">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_type.gsl_root_fsolver_falsepos">
<a class="reference internal" href="#c.gsl_root_fsolver_type" title="gsl_root_fsolver_type"><span class="n"><span class="pre">gsl_root_fsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_falsepos</span></span></span><a class="headerlink" href="#c.gsl_root_fsolver_type.gsl_root_fsolver_falsepos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <em>false position algorithm</em> is a method of finding roots based on
linear interpolation.  Its convergence is linear, but it is usually
faster than bisection.</p>
<p>On each iteration a line is drawn between the endpoints <img class="math" src="_images/math/11335546c65199e5b736128f9c39a812624cc80d.png" alt="(a,f(a))"/>
and <img class="math" src="_images/math/9ce8565b7d9a869ca077ccadb7292fdc9fb58e9c.png" alt="(b,f(b))"/> and the point where this line crosses the
<img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>-axis taken as a “midpoint”.  The value of the function at
this point is calculated and its sign is used to determine which side of
the interval does not contain a root.  That side is discarded to give a
new, smaller interval containing the root.  This procedure can be
continued indefinitely until the interval is sufficiently small.</p>
<p>The best estimate of the root is taken from the linear interpolation of
the interval on the current iteration.</p>
</dd></dl>

<span class="target" id="index-8"></span><dl class="c var">
<dt class="sig sig-object c" id="c.gsl_root_fsolver_type.gsl_root_fsolver_brent">
<a class="reference internal" href="#c.gsl_root_fsolver_type" title="gsl_root_fsolver_type"><span class="n"><span class="pre">gsl_root_fsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fsolver_brent</span></span></span><a class="headerlink" href="#c.gsl_root_fsolver_type.gsl_root_fsolver_brent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <em>Brent-Dekker method</em> (referred to here as <em>Brent’s method</em>)
combines an interpolation strategy with the bisection algorithm.  This
produces a fast algorithm which is still robust.</p>
<p>On each iteration Brent’s method approximates the function using an
interpolating curve.  On the first iteration this is a linear
interpolation of the two endpoints.  For subsequent iterations the
algorithm uses an inverse quadratic fit to the last three points, for
higher accuracy.  The intercept of the interpolating curve with the
<img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>-axis is taken as a guess for the root.  If it lies within the
bounds of the current interval then the interpolating point is accepted,
and used to generate a smaller interval.  If the interpolating point is
not accepted then the algorithm falls back to an ordinary bisection
step.</p>
<p>The best estimate of the root is taken from the most recent
interpolation or bisection.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="root-finding-algorithms-using-derivatives">
<h2>Root Finding Algorithms using Derivatives<a class="headerlink" href="#root-finding-algorithms-using-derivatives" title="Permalink to this heading">¶</a></h2>
<p>The root polishing algorithms described in this section require an
initial guess for the location of the root.  There is no absolute
guarantee of convergence—the function must be suitable for this
technique and the initial guess must be sufficiently close to the root
for it to work.  When these conditions are satisfied then convergence is
quadratic.</p>
<p>These algorithms make use of both the function and its derivative.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_type">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_type</span></span></span><a class="headerlink" href="#c.gsl_root_fdfsolver_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><span class="target" id="index-9"></span><dl class="c var">
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_type.gsl_root_fdfsolver_newton">
<a class="reference internal" href="#c.gsl_root_fdfsolver_type" title="gsl_root_fdfsolver_type"><span class="n"><span class="pre">gsl_root_fdfsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_newton</span></span></span><a class="headerlink" href="#c.gsl_root_fdfsolver_type.gsl_root_fdfsolver_newton" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Newton’s Method is the standard root-polishing algorithm.  The algorithm
begins with an initial guess for the location of the root.  On each
iteration, a line tangent to the function <img class="math" src="_images/math/297ac74049e250d35993e62353e189c7bfda5398.png" alt="f"/> is drawn at that
position.  The point where this line crosses the <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>-axis becomes
the new guess.  The iteration is defined by the following sequence,</p>
<div class="math">
<p><img src="_images/math/5362690a7c72e966dacd02eaf90c9352c0e3fe57.png" alt="x_{i+1} = x_i - {f(x_i) \over f'(x_i)}"/></p>
</div><p>Newton’s method converges quadratically for single roots, and linearly
for multiple roots.</p>
</dd></dl>

<span class="target" id="index-10"></span><dl class="c var">
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_type.gsl_root_fdfsolver_secant">
<a class="reference internal" href="#c.gsl_root_fdfsolver_type" title="gsl_root_fdfsolver_type"><span class="n"><span class="pre">gsl_root_fdfsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_secant</span></span></span><a class="headerlink" href="#c.gsl_root_fdfsolver_type.gsl_root_fdfsolver_secant" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <em>secant method</em> is a simplified version of Newton’s method which does
not require the computation of the derivative on every step.</p>
<p>On its first iteration the algorithm begins with Newton’s method, using
the derivative to compute a first step,</p>
<div class="math">
<p><img src="_images/math/d23965d3ac1e5bbff9a98e10b116a0a3e7ad14da.png" alt="x_1 = x_0 - {f(x_0) \over f'(x_0)}"/></p>
</div><p>Subsequent iterations avoid the evaluation of the derivative by
replacing it with a numerical estimate, the slope of the line through
the previous two points,</p>
<div class="math">
<p><img src="_images/math/dccd369a0b6766a66152b6a05331f66f8e2901d5.png" alt="x_{i+1} = x_i - {f(x_i) \over f'_{est}}
 ~\hbox{where}~
 f'_{est} =  {f(x_{i}) - f(x_{i-1}) \over x_i - x_{i-1}}"/></p>
</div><p>When the derivative does not change significantly in the vicinity of the
root the secant method gives a useful saving.  Asymptotically the secant
method is faster than Newton’s method whenever the cost of evaluating
the derivative is more than 0.44 times the cost of evaluating the
function itself.  As with all methods of computing a numerical
derivative the estimate can suffer from cancellation errors if the
separation of the points becomes too small.</p>
<p>On single roots, the method has a convergence of order <img class="math" src="_images/math/42a46c8cae344bbf84767f3dff14fdcba878ab8b.png" alt="(1 + \sqrt
5)/2"/> (approximately <img class="math" src="_images/math/a6694365bef8c5d2399da359a53d1a7ab7099fc5.png" alt="1.62"/>).  It converges linearly for multiple
roots.</p>
</dd></dl>

<span class="target" id="index-11"></span><dl class="c var">
<dt class="sig sig-object c" id="c.gsl_root_fdfsolver_type.gsl_root_fdfsolver_steffenson">
<a class="reference internal" href="#c.gsl_root_fdfsolver_type" title="gsl_root_fdfsolver_type"><span class="n"><span class="pre">gsl_root_fdfsolver_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_root_fdfsolver_steffenson</span></span></span><a class="headerlink" href="#c.gsl_root_fdfsolver_type.gsl_root_fdfsolver_steffenson" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <em>Steffenson Method</em> <a class="footnote-reference brackets" href="#f1" id="id1">1</a>
provides the fastest
convergence of all the routines.  It combines the basic Newton
algorithm with an Aitken “delta-squared” acceleration.  If the
Newton iterates are <img class="math" src="_images/math/3efd6fd1c2b0c335484bcd4bf7d5d98b99e619f4.png" alt="x_i"/> then the acceleration procedure
generates a new sequence <img class="math" src="_images/math/b6f27d9481d2fae733a0a26d3be8a24925f040ce.png" alt="R_i"/>,</p>
<div class="math">
<p><img src="_images/math/cd2a8842137bc225621703cdb6c4f0082fd4c08a.png" alt="R_i = x_i - {(x_{i+1} - x_i)^2 \over (x_{i+2} - 2 x_{i+1} + x_i)}"/></p>
</div><p>which converges faster than the original sequence under reasonable
conditions.  The new sequence requires three terms before it can produce
its first value so the method returns accelerated values on the second
and subsequent iterations.  On the first iteration it returns the
ordinary Newton estimate.  The Newton iterate is also returned if the
denominator of the acceleration term ever becomes zero.</p>
<p>As with all acceleration procedures this method can become unstable if
the function is not well-behaved.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<p>For any root finding algorithm we need to prepare the function to be
solved.  For this example we will use the general quadratic equation
described earlier.  We first need a header file (<code class="file docutils literal notranslate"><span class="pre">demo_fn.h</span></code>) to
define the function parameters,</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">quadratic_params</span>
  <span class="p">{</span>
    <span class="n">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
  <span class="p">};</span>

<span class="n">double</span> <span class="n">quadratic</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="n">double</span> <span class="n">quadratic_deriv</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
<span class="n">void</span> <span class="n">quadratic_fdf</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
                    <span class="n">double</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">dy</span><span class="p">);</span>
</pre></div>
</div>
<p>We place the function definitions in a separate file (<code class="file docutils literal notranslate"><span class="pre">demo_fn.c</span></code>),</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span>
<span class="n">quadratic</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">quadratic_params</span> <span class="o">*</span><span class="n">p</span>
    <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">quadratic_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>

  <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">double</span>
<span class="n">quadratic_deriv</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">quadratic_params</span> <span class="o">*</span><span class="n">p</span>
    <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">quadratic_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>

  <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span>
<span class="n">quadratic_fdf</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
               <span class="n">double</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">dy</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">struct</span> <span class="n">quadratic_params</span> <span class="o">*</span><span class="n">p</span>
    <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">quadratic_params</span> <span class="o">*</span><span class="p">)</span> <span class="n">params</span><span class="p">;</span>

  <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>

  <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
  <span class="o">*</span><span class="n">dy</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first program uses the function solver <code class="xref c c-data docutils literal notranslate"><span class="pre">gsl_root_fsolver_brent</span></code>
for Brent’s method and the general quadratic defined above to solve the
following equation,</p>
<div class="math">
<p><img src="_images/math/c438260566b8a5e927937cd5f22446fa8de89d68.png" alt="x^2 - 5 = 0"/></p>
</div><p>with solution <img class="math" src="_images/math/362afb2b1c1af1104dda9c9f877b0ced56ec91ca.png" alt="x = \sqrt 5 = 2.236068..."/></p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_errno.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_math.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_roots.h&gt;</span>

<span class="c1">#include &quot;demo_fn.h&quot;</span>
<span class="c1">#include &quot;demo_fn.c&quot;</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">status</span><span class="p">;</span>
  <span class="nb">int</span> <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">gsl_root_fsolver_type</span> <span class="o">*</span><span class="n">T</span><span class="p">;</span>
  <span class="n">gsl_root_fsolver</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r_expected</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">x_lo</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">x_hi</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="n">gsl_function</span> <span class="n">F</span><span class="p">;</span>
  <span class="n">struct</span> <span class="n">quadratic_params</span> <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">};</span>

  <span class="n">F</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">quadratic</span><span class="p">;</span>
  <span class="n">F</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">;</span>

  <span class="n">T</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_brent</span><span class="p">;</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">);</span>
  <span class="n">gsl_root_fsolver_set</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span> <span class="n">x_lo</span><span class="p">,</span> <span class="n">x_hi</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;using </span><span class="si">%s</span><span class="s2"> method</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">gsl_root_fsolver_name</span> <span class="p">(</span><span class="n">s</span><span class="p">));</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%5s</span><span class="s2"> [</span><span class="si">%9s</span><span class="s2">, </span><span class="si">%9s</span><span class="s2">] </span><span class="si">%9s</span><span class="s2"> </span><span class="si">%10s</span><span class="s2"> </span><span class="si">%9s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="s2">&quot;iter&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
          <span class="s2">&quot;err&quot;</span><span class="p">,</span> <span class="s2">&quot;err(est)&quot;</span><span class="p">);</span>

  <span class="n">do</span>
    <span class="p">{</span>
      <span class="nb">iter</span><span class="o">++</span><span class="p">;</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_iterate</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_root</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
      <span class="n">x_lo</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_x_lower</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
      <span class="n">x_hi</span> <span class="o">=</span> <span class="n">gsl_root_fsolver_x_upper</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">gsl_root_test_interval</span> <span class="p">(</span><span class="n">x_lo</span><span class="p">,</span> <span class="n">x_hi</span><span class="p">,</span>
                                       <span class="mi">0</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">GSL_SUCCESS</span><span class="p">)</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;Converged:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

      <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%5d</span><span class="s2"> [</span><span class="si">%.7f</span><span class="s2">, </span><span class="si">%.7f</span><span class="s2">] </span><span class="si">%.7f</span><span class="s2"> </span><span class="si">%+.7f</span><span class="s2"> </span><span class="si">%.7f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
              <span class="nb">iter</span><span class="p">,</span> <span class="n">x_lo</span><span class="p">,</span> <span class="n">x_hi</span><span class="p">,</span>
              <span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">r_expected</span><span class="p">,</span>
              <span class="n">x_hi</span> <span class="o">-</span> <span class="n">x_lo</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">GSL_CONTINUE</span> <span class="o">&amp;&amp;</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">);</span>

  <span class="n">gsl_root_fsolver_free</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here are the results of the iterations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./a.out
using brent method
 iter [    lower,     upper]      root        err  err(est)
    1 [1.0000000, 5.0000000] 1.0000000 -1.2360680 4.0000000
    2 [1.0000000, 3.0000000] 3.0000000 +0.7639320 2.0000000
    3 [2.0000000, 3.0000000] 2.0000000 -0.2360680 1.0000000
    4 [2.2000000, 3.0000000] 2.2000000 -0.0360680 0.8000000
    5 [2.2000000, 2.2366300] 2.2366300 +0.0005621 0.0366300
Converged:
    6 [2.2360634, 2.2366300] 2.2360634 -0.0000046 0.0005666
</pre></div>
</div>
<p>If the program is modified to use the bisection solver instead of
Brent’s method, by changing <code class="xref c c-data docutils literal notranslate"><span class="pre">gsl_root_fsolver_brent</span></code> to
<code class="xref c c-data docutils literal notranslate"><span class="pre">gsl_root_fsolver_bisection</span></code> the slower convergence of the
Bisection method can be observed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./a.out
using bisection method
 iter [    lower,     upper]      root        err  err(est)
    1 [0.0000000, 2.5000000] 1.2500000 -0.9860680 2.5000000
    2 [1.2500000, 2.5000000] 1.8750000 -0.3610680 1.2500000
    3 [1.8750000, 2.5000000] 2.1875000 -0.0485680 0.6250000
    4 [2.1875000, 2.5000000] 2.3437500 +0.1076820 0.3125000
    5 [2.1875000, 2.3437500] 2.2656250 +0.0295570 0.1562500
    6 [2.1875000, 2.2656250] 2.2265625 -0.0095055 0.0781250
    7 [2.2265625, 2.2656250] 2.2460938 +0.0100258 0.0390625
    8 [2.2265625, 2.2460938] 2.2363281 +0.0002601 0.0195312
    9 [2.2265625, 2.2363281] 2.2314453 -0.0046227 0.0097656
   10 [2.2314453, 2.2363281] 2.2338867 -0.0021813 0.0048828
   11 [2.2338867, 2.2363281] 2.2351074 -0.0009606 0.0024414
Converged:
   12 [2.2351074, 2.2363281] 2.2357178 -0.0003502 0.0012207
</pre></div>
</div>
<p>The next program solves the same function using a derivative solver
instead.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_errno.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_math.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_roots.h&gt;</span>

<span class="c1">#include &quot;demo_fn.h&quot;</span>
<span class="c1">#include &quot;demo_fn.c&quot;</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">status</span><span class="p">;</span>
  <span class="nb">int</span> <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">gsl_root_fdfsolver_type</span> <span class="o">*</span><span class="n">T</span><span class="p">;</span>
  <span class="n">gsl_root_fdfsolver</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">r_expected</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
  <span class="n">gsl_function_fdf</span> <span class="n">FDF</span><span class="p">;</span>
  <span class="n">struct</span> <span class="n">quadratic_params</span> <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">};</span>

  <span class="n">FDF</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">quadratic</span><span class="p">;</span>
  <span class="n">FDF</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">quadratic_deriv</span><span class="p">;</span>
  <span class="n">FDF</span><span class="o">.</span><span class="n">fdf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">quadratic_fdf</span><span class="p">;</span>
  <span class="n">FDF</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">;</span>

  <span class="n">T</span> <span class="o">=</span> <span class="n">gsl_root_fdfsolver_newton</span><span class="p">;</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">gsl_root_fdfsolver_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">);</span>
  <span class="n">gsl_root_fdfsolver_set</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FDF</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;using </span><span class="si">%s</span><span class="s2"> method</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">gsl_root_fdfsolver_name</span> <span class="p">(</span><span class="n">s</span><span class="p">));</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%-5s</span><span class="s2"> </span><span class="si">%10s</span><span class="s2"> </span><span class="si">%10s</span><span class="s2"> </span><span class="si">%10s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="s2">&quot;iter&quot;</span><span class="p">,</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span> <span class="s2">&quot;err&quot;</span><span class="p">,</span> <span class="s2">&quot;err(est)&quot;</span><span class="p">);</span>
  <span class="n">do</span>
    <span class="p">{</span>
      <span class="nb">iter</span><span class="o">++</span><span class="p">;</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">gsl_root_fdfsolver_iterate</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
      <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">gsl_root_fdfsolver_root</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
      <span class="n">status</span> <span class="o">=</span> <span class="n">gsl_root_test_delta</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">GSL_SUCCESS</span><span class="p">)</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;Converged:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

      <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%5d</span><span class="s2"> </span><span class="si">%10.7f</span><span class="s2"> </span><span class="si">%+10.7f</span><span class="s2"> </span><span class="si">%10.7f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
              <span class="nb">iter</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">r_expected</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">GSL_CONTINUE</span> <span class="o">&amp;&amp;</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">);</span>

  <span class="n">gsl_root_fdfsolver_free</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here are the results for Newton’s method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./a.out
using newton method
iter        root        err   err(est)
    1  3.0000000 +0.7639320 -2.0000000
    2  2.3333333 +0.0972654 -0.6666667
    3  2.2380952 +0.0020273 -0.0952381
Converged:
    4  2.2360689 +0.0000009 -0.0020263
</pre></div>
</div>
<p>Note that the error can be estimated more accurately by taking the
difference between the current iterate and next iterate rather than the
previous iterate.  The other derivative solvers can be investigated by
changing <code class="xref c c-data docutils literal notranslate"><span class="pre">gsl_root_fdfsolver_newton</span></code> to
<code class="xref c c-data docutils literal notranslate"><span class="pre">gsl_root_fdfsolver_secant</span></code> or
<code class="xref c c-data docutils literal notranslate"><span class="pre">gsl_root_fdfsolver_steffenson</span></code>.</p>
</div>
<div class="section" id="references-and-further-reading">
<h2>References and Further Reading<a class="headerlink" href="#references-and-further-reading" title="Permalink to this heading">¶</a></h2>
<p>For information on the Brent-Dekker algorithm see the following two
papers,</p>
<ul class="simple">
<li><p>R. P. Brent, “An algorithm with guaranteed convergence for finding a
zero of a function”, <em>Computer Journal</em>, 14 (1971) 422–425</p></li>
<li><p>J. C. P. Bus and T. J. Dekker, “Two Efficient Algorithms with Guaranteed
Convergence for Finding a Zero of a Function”, <em>ACM Transactions of
Mathematical Software</em>, Vol.: 1 No.: 4 (1975) 330–345</p></li>
</ul>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>J.F. Steffensen (1873–1961). The spelling used in the name of the
function is slightly incorrect, but has been preserved to avoid incompatibility.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="min.html" class="btn btn-neutral float-right" title="One Dimensional Minimization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="dht.html" class="btn btn-neutral float-left" title="Discrete Hankel Transforms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 1996-2024 The GSL Team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>