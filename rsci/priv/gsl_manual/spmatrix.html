

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Sparse Matrices &mdash; GSL 2.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Sparse BLAS Support" href="spblas.html" />
    <link rel="prev" title="Basis Splines" href="bspline.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GSL
          

          
          </a>

          
            
            
              <div class="version">
                2.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Using the Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="err.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Mathematical Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="poly.html">Polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="specfunc.html">Special Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="vectors.html">Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiset.html">Multisets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="eigen.html">Eigensystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Fast Fourier Transforms (FFTs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Numerical Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="rng.html">Random Number Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="qrng.html">Quasi-Random Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="randist.html">Random Number Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="rstat.html">Running Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="movstat.html">Moving Window Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Digital Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="histogram.html">Histograms</a></li>
<li class="toctree-l1"><a class="reference internal" href="ntuple.html">N-tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="montecarlo.html">Monte Carlo Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="siman.html">Simulated Annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="ode-initval.html">Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="interp.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="diff.html">Numerical Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheb.html">Chebyshev Approximations</a></li>
<li class="toctree-l1"><a class="reference internal" href="sum.html">Series Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dwt.html">Wavelet Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dht.html">Discrete Hankel Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="roots.html">One Dimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="min.html">One Dimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiroots.html">Multidimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="multimin.html">Multidimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="lls.html">Linear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="nls.html">Nonlinear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="bspline.html">Basis Splines</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Sparse Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#data-types">Data types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-matrix-storage-formats">Sparse Matrix Storage Formats</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coordinate-storage-coo">Coordinate Storage (COO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compressed-sparse-column-csc">Compressed Sparse Column (CSC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compressed-sparse-row-csr">Compressed Sparse Row (CSR)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#allocation">Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#accessing-matrix-elements">Accessing Matrix Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-matrix-elements">Initializing Matrix Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reading-and-writing-matrices">Reading and Writing Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#copying-matrices">Copying Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exchanging-rows-and-columns">Exchanging Rows and Columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#matrix-operations">Matrix Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#matrix-properties">Matrix Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="#finding-maximum-and-minimum-elements">Finding Maximum and Minimum Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compressed-format">Compressed Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conversion-between-sparse-and-dense-matrices">Conversion Between Sparse and Dense Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spblas.html">Sparse BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="splinalg.html">Sparse Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="const.html">Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="ieee754.html">IEEE floating-point arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debugging Numerical Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributors to GSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoconf.html">Autoconf Macros</a></li>
<li class="toctree-l1"><a class="reference internal" href="cblas.html">GSL CBLAS Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpl.html">GNU General Public License</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdl.html">GNU Free Documentation License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GSL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Sparse Matrices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/spmatrix.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="spblas.html" class="btn btn-neutral float-right" title="Sparse BLAS Support" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="bspline.html" class="btn btn-neutral float-left" title="Basis Splines" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sparse-matrices">
<span id="index-0"></span><h1>Sparse Matrices<a class="headerlink" href="#sparse-matrices" title="Permalink to this heading">¶</a></h1>
<p>This chapter describes functions for the construction and
manipulation of sparse matrices, matrices which are populated
primarily with zeros and contain only a few non-zero elements.
Sparse matrices often appear in the solution of partial
differential equations. It is beneficial to use specialized
data structures and algorithms for storing and working with
sparse matrices, since dense matrix algorithms and structures
can be prohibitively slow and use huge amounts of memory when applied
to sparse matrices.</p>
<p>The header file <code class="file docutils literal notranslate"><span class="pre">gsl_spmatrix.h</span></code> contains the prototypes for the
sparse matrix functions and related declarations.</p>
<div class="section" id="data-types">
<span id="index-1"></span><h2>Data types<a class="headerlink" href="#data-types" title="Permalink to this heading">¶</a></h2>
<p>All the functions are available for each of the standard data-types.
The versions for <code class="code docutils literal notranslate"><span class="pre">double</span></code> have the prefix <code class="code docutils literal notranslate"><span class="pre">gsl_spmatrix</span></code>,
Similarly the versions for single-precision <code class="code docutils literal notranslate"><span class="pre">float</span></code> arrays have the prefix
<code class="code docutils literal notranslate"><span class="pre">gsl_spmatrix_float</span></code>.  The full list of available types is given
below,</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Prefix</p></th>
<th class="head"><p>Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>gsl_spmatrix</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td><p>gsl_spmatrix_float</p></td>
<td><p>float</p></td>
</tr>
<tr class="row-even"><td><p>gsl_spmatrix_long_double</p></td>
<td><p>long double</p></td>
</tr>
<tr class="row-odd"><td><p>gsl_spmatrix_int</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>gsl_spmatrix_uint</p></td>
<td><p>unsigned int</p></td>
</tr>
<tr class="row-odd"><td><p>gsl_spmatrix_long</p></td>
<td><p>long</p></td>
</tr>
<tr class="row-even"><td><p>gsl_spmatrix_ulong</p></td>
<td><p>unsigned long</p></td>
</tr>
<tr class="row-odd"><td><p>gsl_spmatrix_short</p></td>
<td><p>short</p></td>
</tr>
<tr class="row-even"><td><p>gsl_spmatrix_ushort</p></td>
<td><p>unsigned short</p></td>
</tr>
<tr class="row-odd"><td><p>gsl_spmatrix_char</p></td>
<td><p>char</p></td>
</tr>
<tr class="row-even"><td><p>gsl_spmatrix_uchar</p></td>
<td><p>unsigned char</p></td>
</tr>
<tr class="row-odd"><td><p>gsl_spmatrix_complex</p></td>
<td><p>complex double</p></td>
</tr>
<tr class="row-even"><td><p>gsl_spmatrix_complex_float</p></td>
<td><p>complex float</p></td>
</tr>
<tr class="row-odd"><td><p>gsl_spmatrix_complex_long_double</p></td>
<td><p>complex long double</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sparse-matrix-storage-formats">
<span id="index-2"></span><h2>Sparse Matrix Storage Formats<a class="headerlink" href="#sparse-matrix-storage-formats" title="Permalink to this heading">¶</a></h2>
<p>GSL currently supports three storage formats for sparse matrices:
the coordinate (COO) representation, compressed sparse column (CSC)
and compressed sparse row (CSR) formats. These are discussed in more
detail below. In order to illustrate the different storage formats,
the following sections will reference this <img class="math" src="_images/math/e7ca688f7c1f0c4a6496a2d3b6b6bd815553b38b.png" alt="M"/>-by-<img class="math" src="_images/math/cb5c0921ee22e878437766648c5925b76e462235.png" alt="N"/>
sparse matrix, with <img class="math" src="_images/math/cb757484c1a73a0ea2cbb21586f4f830bc8de6c3.png" alt="M=4"/> and <img class="math" src="_images/math/d01c984606c064ef9c64c17413ed3fdacb0b251f.png" alt="N=5"/>:</p>
<div class="math">
<p><img src="_images/math/fd7f6f722acba24dd96cf0e4e88856dcad1f124c.png" alt="\begin{pmatrix}
  9 &amp; 0 &amp; 0 &amp; 0 &amp; -3 \\
  4 &amp; 7 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 8 &amp; -1 &amp; 8 &amp; 0 \\
  4 &amp; 0 &amp; 5 &amp; 6 &amp; 0
\end{pmatrix}"/></p>
</div><p>The number of non-zero elements in the matrix, also abbreviated as
<code class="code docutils literal notranslate"><span class="pre">nnz</span></code> is equal to <img class="math" src="_images/math/8f8a44e9f9b7ef1fb7d0e9585dc08a38a6f89021.png" alt="10"/> in this case.</p>
<div class="section" id="coordinate-storage-coo">
<span id="sec-spmatrix-coo"></span><span id="index-3"></span><h3>Coordinate Storage (COO)<a class="headerlink" href="#coordinate-storage-coo" title="Permalink to this heading">¶</a></h3>
<p>The coordinate storage format, also known as <em>triplet format</em>,
stores triplets <img class="math" src="_images/math/6a46ee351c5d15b24fffc5094d968fd1574b6896.png" alt="(i,j,x)"/> for each non-zero element of the matrix.
This notation means that the <img class="math" src="_images/math/92807ade5bf57ca25e8e9ad6a1d3169b9081d66d.png" alt="(i,j)"/> element of the matrix <img class="math" src="_images/math/fe895c925fafcf3161c4d10b14fb00b979c0015f.png" alt="A"/>
is <img class="math" src="_images/math/b30bc6935dfc52b5160e4fd6a7127a2a4e5257e7.png" alt="A_{ij} = x"/>. The matrix is stored using three arrays of the same
length, representing the row indices, column indices, and matrix data. For
the reference matrix above, one possible storage format is:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>data</p></td>
<td><p>9</p></td>
<td><p>7</p></td>
<td><p>4</p></td>
<td><p>8</p></td>
<td><p>-3</p></td>
<td><p>-1</p></td>
<td><p>8</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>row</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>col</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>Note that this representation is not unique - the coordinate triplets may
appear in any ordering and would still represent the same sparse matrix.
The length of the three arrays is equal to the number of non-zero elements
in the matrix, <code class="code docutils literal notranslate"><span class="pre">nnz</span></code>, which in this case is <img class="math" src="_images/math/8f8a44e9f9b7ef1fb7d0e9585dc08a38a6f89021.png" alt="10"/>. The coordinate format is
extremely convenient for sparse matrix <em>assembly</em>,
the process of adding new elements, or changing existing elements, in a
sparse matrix. However, it is generally not suitable for the efficient
implementation of matrix-matrix products, or matrix factorization algorithms.
For these applications it is better to use one of the compressed formats
discussed below.</p>
<p>In order to faciliate efficient sparse matrix assembly, GSL stores
the coordinate data in a balanced binary search tree, specifically an AVL
tree, in addition to the three arrays
discussed above. This allows GSL to efficiently determine whether an
entry <img class="math" src="_images/math/92807ade5bf57ca25e8e9ad6a1d3169b9081d66d.png" alt="(i,j)"/> already exists in the matrix, and to replace an existing
matrix entry with a new value, without needing to search unsorted arrays.</p>
</div>
<div class="section" id="compressed-sparse-column-csc">
<span id="sec-spmatrix-csc"></span><span id="index-4"></span><h3>Compressed Sparse Column (CSC)<a class="headerlink" href="#compressed-sparse-column-csc" title="Permalink to this heading">¶</a></h3>
<p>Compressed sparse column storage stores each column of
non-zero values in the sparse matrix in a continuous memory block, keeping
pointers to the beginning of each column in that memory block, and storing
the row indices of each non-zero element. For the reference matrix above,
these arrays look like</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>data</p></td>
<td><p>9</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>-1</p></td>
<td><p>5</p></td>
<td><p>8</p></td>
<td><p>6</p></td>
<td><p>-3</p></td>
</tr>
<tr class="row-even"><td><p>row</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>3</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>col_ptr</p></td>
<td><p>0</p></td>
<td><p>3</p></td>
<td><p>5</p></td>
<td><p>7</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The <code class="code docutils literal notranslate"><span class="pre">data</span></code> and <code class="code docutils literal notranslate"><span class="pre">row</span></code> arrays are of length <code class="code docutils literal notranslate"><span class="pre">nnz</span></code> and
are the same as the COO storage format. The <code class="code docutils literal notranslate"><span class="pre">col_ptr</span></code> array
has length <img class="math" src="_images/math/3aaf4d8532b1e15233991c50aedb30bc889cfdc9.png" alt="N+1"/>, and <code class="code docutils literal notranslate"><span class="pre">col_ptr[j]</span></code> gives the index in
<code class="code docutils literal notranslate"><span class="pre">data</span></code> of the start of column <code class="code docutils literal notranslate"><span class="pre">j</span></code>. Therefore, the
<img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>-th column of the matrix is stored in
<code class="code docutils literal notranslate"><span class="pre">data[col_ptr[j]]</span></code>, <code class="code docutils literal notranslate"><span class="pre">data[col_ptr[j]</span> <span class="pre">+</span> <span class="pre">1]</span></code>, …,
<code class="code docutils literal notranslate"><span class="pre">data[col_ptr[j+1]</span> <span class="pre">-</span> <span class="pre">1]</span></code>.
The last element of <code class="code docutils literal notranslate"><span class="pre">col_ptr</span></code> is <code class="code docutils literal notranslate"><span class="pre">nnz</span></code>.</p>
</div>
<div class="section" id="compressed-sparse-row-csr">
<span id="sec-spmatrix-csr"></span><span id="index-5"></span><h3>Compressed Sparse Row (CSR)<a class="headerlink" href="#compressed-sparse-row-csr" title="Permalink to this heading">¶</a></h3>
<p>Compressed row storage stores each row of non-zero values in a
continuous memory block, keeping pointers to the beginning of each
row in the block and storing the column indices of each non-zero element.
For the reference matrix above, these arrays look like</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>data</p></td>
<td><p>9</p></td>
<td><p>-3</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>-1</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>col</p></td>
<td><p>0</p></td>
<td><p>4</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>row_ptr</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>10</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The <code class="code docutils literal notranslate"><span class="pre">data</span></code> and <code class="code docutils literal notranslate"><span class="pre">col</span></code> arrays are of length <code class="code docutils literal notranslate"><span class="pre">nnz</span></code> and
are the same as the COO storage format. The <code class="code docutils literal notranslate"><span class="pre">row_ptr</span></code> array
has length <img class="math" src="_images/math/f5a0c9a72b158d8607b0f4c63a2731d6d47e0337.png" alt="M+1"/>, and <code class="code docutils literal notranslate"><span class="pre">row_ptr[i]</span></code> gives the index in
<code class="code docutils literal notranslate"><span class="pre">data</span></code> of the start of row <code class="code docutils literal notranslate"><span class="pre">i</span></code>. Therefore, the
<img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th row of the matrix is stored in
<code class="code docutils literal notranslate"><span class="pre">data[row_ptr[i]]</span></code>, <code class="code docutils literal notranslate"><span class="pre">data[row_ptr[i]</span> <span class="pre">+</span> <span class="pre">1]</span></code>,
…, <code class="code docutils literal notranslate"><span class="pre">data[row_ptr[i+1]</span> <span class="pre">-</span> <span class="pre">1]</span></code>.
The last element of <code class="code docutils literal notranslate"><span class="pre">row_ptr</span></code> is <code class="code docutils literal notranslate"><span class="pre">nnz</span></code>.</p>
</div>
</div>
<div class="section" id="overview">
<span id="index-6"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>These routines provide support for constructing and manipulating
sparse matrices in GSL, using an API similar to <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_matrix</span></code></a>.
The basic structure is called <a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_spmatrix</span></code></a>.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_spmatrix">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix</span></span></span><a class="headerlink" href="#c.gsl_spmatrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This structure is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span>
<span class="p">{</span>
  <span class="n">size_t</span> <span class="n">size1</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">size2</span><span class="p">;</span>
  <span class="nb">int</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
  <span class="n">double</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
  <span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">nzmax</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">nz</span><span class="p">;</span>
  <span class="p">[</span> <span class="o">...</span> <span class="n">variables</span> <span class="k">for</span> <span class="n">binary</span> <span class="n">tree</span> <span class="ow">and</span> <span class="n">memory</span> <span class="n">management</span> <span class="o">...</span> <span class="p">]</span>
  <span class="n">size_t</span> <span class="n">sptype</span><span class="p">;</span>
<span class="p">}</span> <span class="n">gsl_spmatrix</span><span class="p">;</span>
</pre></div>
</div>
<p>This defines a <code class="xref c c-data docutils literal notranslate"><span class="pre">size1</span></code>-by-<code class="xref c c-data docutils literal notranslate"><span class="pre">size2</span></code> sparse matrix. The number of non-zero
elements currently in the matrix is given by <code class="xref c c-data docutils literal notranslate"><span class="pre">nz</span></code>. For the triplet
representation, <code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code>, <code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code>, and <code class="xref c c-data docutils literal notranslate"><span class="pre">data</span></code> are arrays of size <code class="xref c c-data docutils literal notranslate"><span class="pre">nz</span></code>
which contain the row indices, column indices, and element value, respectively.
So if <img class="math" src="_images/math/cacb5b457f3ad8aca39bc0d96cf4b6c363c7dd4c.png" alt="data[k] = A(i,j)"/>, then <img class="math" src="_images/math/aace99a82c95b5669dfd6dc8b4af03d091434a2d.png" alt="i = i[k]"/> and <img class="math" src="_images/math/3bbe6cef79f61a91cb47baf9156120d37afba17d.png" alt="j = p[k]"/>.</p>
<p>For compressed column storage, <code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code> and <code class="xref c c-data docutils literal notranslate"><span class="pre">data</span></code> are arrays of size
<code class="xref c c-data docutils literal notranslate"><span class="pre">nz</span></code> containing the row indices and element values, identical to the triplet
case. <code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code> is an array of size <code class="xref c c-data docutils literal notranslate"><span class="pre">size2</span></code> + 1 where <code class="code docutils literal notranslate"><span class="pre">p[j]</span></code> points
to the index in <code class="xref c c-data docutils literal notranslate"><span class="pre">data</span></code> of the start of column <code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code>. Thus, if
<img class="math" src="_images/math/cacb5b457f3ad8aca39bc0d96cf4b6c363c7dd4c.png" alt="data[k] = A(i,j)"/>, then <img class="math" src="_images/math/aace99a82c95b5669dfd6dc8b4af03d091434a2d.png" alt="i = i[k]"/> and <img class="math" src="_images/math/87ba1005abed8a1b1d0758af2d2c7803cdbc60ba.png" alt="p[j] &lt;= k &lt; p[j+1]"/>.</p>
<p>For compressed row storage, <code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code> and <code class="xref c c-data docutils literal notranslate"><span class="pre">data</span></code> are arrays of size
<code class="xref c c-data docutils literal notranslate"><span class="pre">nz</span></code> containing the column indices and element values, identical to the triplet
case. <code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code> is an array of size <code class="xref c c-data docutils literal notranslate"><span class="pre">size1</span></code> + 1 where <code class="code docutils literal notranslate"><span class="pre">p[i]</span></code> points
to the index in <code class="xref c c-data docutils literal notranslate"><span class="pre">data</span></code> of the start of row <code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code>. Thus, if
<img class="math" src="_images/math/cacb5b457f3ad8aca39bc0d96cf4b6c363c7dd4c.png" alt="data[k] = A(i,j)"/>, then <img class="math" src="_images/math/16257b474203cde98d39998c85ad8f56f339601e.png" alt="j = i[k]"/> and <img class="math" src="_images/math/5dde6383461957b3f4e6d62fe5395975b3a33b85.png" alt="p[i] &lt;= k &lt; p[i+1]"/>.</p>
<p>There are additional variables in the <a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_spmatrix</span></code></a> structure related
to binary tree storage and memory management. The GSL implementation of sparse
matrices uses balanced AVL trees to sort matrix elements in the triplet representation.
This speeds up element searches and duplicate detection during the matrix assembly process.
The <a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_spmatrix</span></code></a> structure also contains additional workspace variables needed
for various operations like converting from triplet to compressed storage.
<code class="xref c c-data docutils literal notranslate"><span class="pre">sptype</span></code> indicates the type of storage format being used (COO, CSC or CSR).</p>
<p>The compressed storage format defined above makes it very simple
to interface with sophisticated external linear solver libraries
which accept compressed storage input. The user can simply
pass the arrays <code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code>, <code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code>, and <code class="xref c c-data docutils literal notranslate"><span class="pre">data</span></code> as the
inputs to external libraries.</p>
</dd></dl>

</div>
<div class="section" id="allocation">
<span id="index-7"></span><h2>Allocation<a class="headerlink" href="#allocation" title="Permalink to this heading">¶</a></h2>
<p>The functions for allocating memory for a sparse matrix follow the style of
<code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>. They also perform their own error checking. If
there is insufficient memory available to allocate a matrix then the functions
call the GSL error handler with an error code of <a class="reference internal" href="err.html#c.GSL_ENOMEM" title="GSL_ENOMEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_ENOMEM</span></code></a> in addition
to returning a null pointer.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_alloc">
<a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function allocates a sparse matrix of size <a class="reference internal" href="#c.gsl_spmatrix_alloc" title="n1"><code class="xref c c-data docutils literal notranslate"><span class="pre">n1</span></code></a>-by-<a class="reference internal" href="#c.gsl_spmatrix_alloc" title="n2"><code class="xref c c-data docutils literal notranslate"><span class="pre">n2</span></code></a> and
initializes it to all zeros. If the size of the matrix is not known at allocation
time, both <a class="reference internal" href="#c.gsl_spmatrix_alloc" title="n1"><code class="xref c c-data docutils literal notranslate"><span class="pre">n1</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_alloc" title="n2"><code class="xref c c-data docutils literal notranslate"><span class="pre">n2</span></code></a> may be set to 1, and they will automatically
grow as elements are added to the matrix. This function sets the
matrix to the triplet representation, which is the easiest for adding
and accessing matrix elements. This function tries to make a reasonable guess
for the number of non-zero elements (<code class="xref c c-data docutils literal notranslate"><span class="pre">nzmax</span></code>) which will be added to the matrix by
assuming a sparse density of <img class="math" src="_images/math/a8053ca9eba9d57b3639ae12d4154afd62542a92.png" alt="10\%"/>. The function
<a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="gsl_spmatrix_alloc_nzmax"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_spmatrix_alloc_nzmax()</span></code></a> can be used if this number is known more
accurately. The workspace is of size <img class="math" src="_images/math/e7643aa32fda910186a70fbe4695f644581dcb10.png" alt="O(nzmax)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_alloc_nzmax">
<a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_alloc_nzmax</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nzmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">sptype</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_alloc_nzmax" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function allocates a sparse matrix of size <a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="n1"><code class="xref c c-data docutils literal notranslate"><span class="pre">n1</span></code></a>-by-<a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="n2"><code class="xref c c-data docutils literal notranslate"><span class="pre">n2</span></code></a> and
initializes it to all zeros. If the size of the matrix is not known at allocation
time, both <a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="n1"><code class="xref c c-data docutils literal notranslate"><span class="pre">n1</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="n2"><code class="xref c c-data docutils literal notranslate"><span class="pre">n2</span></code></a> may be set to 1, and they will automatically
grow as elements are added to the matrix. The parameter <a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="nzmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nzmax</span></code></a> specifies
the maximum number of non-zero elements which will be added to the matrix.
It does not need to be precisely known in advance, since storage space will
automatically grow using <a class="reference internal" href="#c.gsl_spmatrix_realloc" title="gsl_spmatrix_realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_spmatrix_realloc()</span></code></a> if <a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="nzmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nzmax</span></code></a> is not
large enough. Accurate knowledge of this parameter reduces the number of
reallocation calls required. The parameter <a class="reference internal" href="#c.gsl_spmatrix_alloc_nzmax" title="sptype"><code class="xref c c-data docutils literal notranslate"><span class="pre">sptype</span></code></a> specifies the
storage format of the sparse matrix. Possible values are</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_spmatrix_alloc_nzmax.GSL_SPMATRIX_COO">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_SPMATRIX_COO</span></span></span><a class="headerlink" href="#c.gsl_spmatrix_alloc_nzmax.GSL_SPMATRIX_COO" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This flag specifies coordinate (triplet) storage.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_spmatrix_alloc_nzmax.GSL_SPMATRIX_CSC">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_SPMATRIX_CSC</span></span></span><a class="headerlink" href="#c.gsl_spmatrix_alloc_nzmax.GSL_SPMATRIX_CSC" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This flag specifies compressed sparse column storage.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.gsl_spmatrix_alloc_nzmax.GSL_SPMATRIX_CSR">
<span class="sig-name descname"><span class="n"><span class="pre">GSL_SPMATRIX_CSR</span></span></span><a class="headerlink" href="#c.gsl_spmatrix_alloc_nzmax.GSL_SPMATRIX_CSR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This flag specifies compressed sparse row storage.</p>
</dd></dl>

<p>The allocated <a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_spmatrix</span></code></a> structure is of size <img class="math" src="_images/math/e7643aa32fda910186a70fbe4695f644581dcb10.png" alt="O(nzmax)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_realloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_realloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nzmax</span></span>, <a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_realloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function reallocates the storage space for <a class="reference internal" href="#c.gsl_spmatrix_realloc" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> to accomodate
<a class="reference internal" href="#c.gsl_spmatrix_realloc" title="nzmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nzmax</span></code></a> non-zero elements. It is typically called internally by
<a class="reference internal" href="#c.gsl_spmatrix_set" title="gsl_spmatrix_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_spmatrix_set()</span></code></a> if the user wants to add more elements to the
sparse matrix than the previously specified <a class="reference internal" href="#c.gsl_spmatrix_realloc" title="nzmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">nzmax</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function frees the memory associated with the sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_free" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="accessing-matrix-elements">
<span id="index-8"></span><h2>Accessing Matrix Elements<a class="headerlink" href="#accessing-matrix-elements" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_get">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns element (<a class="reference internal" href="#c.gsl_spmatrix_get" title="i"><code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code></a>, <a class="reference internal" href="#c.gsl_spmatrix_get" title="j"><code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code></a>) of the matrix <a class="reference internal" href="#c.gsl_spmatrix_get" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_set">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function sets element (<a class="reference internal" href="#c.gsl_spmatrix_set" title="i"><code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code></a>, <a class="reference internal" href="#c.gsl_spmatrix_set" title="j"><code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code></a>) of the matrix <a class="reference internal" href="#c.gsl_spmatrix_set" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> to
the value <a class="reference internal" href="#c.gsl_spmatrix_set" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_ptr">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_ptr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_ptr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a pointer to the (<a class="reference internal" href="#c.gsl_spmatrix_ptr" title="i"><code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code></a>, <a class="reference internal" href="#c.gsl_spmatrix_ptr" title="j"><code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code></a>) element of the matrix <a class="reference internal" href="#c.gsl_spmatrix_ptr" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>.
If the (<a class="reference internal" href="#c.gsl_spmatrix_ptr" title="i"><code class="xref c c-data docutils literal notranslate"><span class="pre">i</span></code></a>, <a class="reference internal" href="#c.gsl_spmatrix_ptr" title="j"><code class="xref c c-data docutils literal notranslate"><span class="pre">j</span></code></a>) element is not explicitly stored in the matrix,
a null pointer is returned.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="initializing-matrix-elements">
<span id="index-9"></span><h2>Initializing Matrix Elements<a class="headerlink" href="#initializing-matrix-elements" title="Permalink to this heading">¶</a></h2>
<p>Since the sparse matrix format only stores the non-zero elements, it is automatically
initialized to zero upon allocation. The function <a class="reference internal" href="#c.gsl_spmatrix_set_zero" title="gsl_spmatrix_set_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_spmatrix_set_zero()</span></code></a> may
be used to re-initialize a matrix to zero after elements have been added to it.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_set_zero">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_set_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_set_zero" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function sets (or resets) all the elements of the matrix <a class="reference internal" href="#c.gsl_spmatrix_set_zero" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> to zero.
For CSC and CSR matrices, the cost of this operation is <img class="math" src="_images/math/7a8c96471eb27bf3896037e79cd6bf6262bd5fb6.png" alt="O(1)"/>. For
COO matrices, the binary tree structure must be dismantled, so the cost is
<img class="math" src="_images/math/5b1cd6d6f6f5808550922e8428821d31781f5419.png" alt="O(nz)"/>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="reading-and-writing-matrices">
<span id="index-10"></span><h2>Reading and Writing Matrices<a class="headerlink" href="#reading-and-writing-matrices" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_fwrite">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_fwrite</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stream</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_fwrite" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function writes the elements of the matrix <a class="reference internal" href="#c.gsl_spmatrix_fwrite" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> to the stream
<a class="reference internal" href="#c.gsl_spmatrix_fwrite" title="stream"><code class="xref c c-data docutils literal notranslate"><span class="pre">stream</span></code></a> in binary format.  The return value is 0 for success and
<code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EFAILED</span></code> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_fread">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_fread</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stream</span></span>, <a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_fread" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function reads into the matrix <a class="reference internal" href="#c.gsl_spmatrix_fread" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> from the open stream
<a class="reference internal" href="#c.gsl_spmatrix_fread" title="stream"><code class="xref c c-data docutils literal notranslate"><span class="pre">stream</span></code></a> in binary format.  The matrix <a class="reference internal" href="#c.gsl_spmatrix_fread" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> must be preallocated
with the correct storage format, dimensions and have a sufficiently large <code class="xref c c-data docutils literal notranslate"><span class="pre">nzmax</span></code>
in order to read in all matrix elements, otherwise <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EBADLEN</span></code>
is returned. The return value is 0 for success and
<code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EFAILED</span></code> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_fprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_fprintf</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stream</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_fprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function writes the elements of the matrix <a class="reference internal" href="#c.gsl_spmatrix_fprintf" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> line-by-line to
the stream <a class="reference internal" href="#c.gsl_spmatrix_fprintf" title="stream"><code class="xref c c-data docutils literal notranslate"><span class="pre">stream</span></code></a> using the format specifier <a class="reference internal" href="#c.gsl_spmatrix_fprintf" title="format"><code class="xref c c-data docutils literal notranslate"><span class="pre">format</span></code></a>, which
should be one of the <code class="code docutils literal notranslate"><span class="pre">%g</span></code>, <code class="code docutils literal notranslate"><span class="pre">%e</span></code> or <code class="code docutils literal notranslate"><span class="pre">%f</span></code> formats for
floating point numbers.  The function returns 0 for success and
<code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EFAILED</span></code> if there was a problem writing to the file. The
input matrix <a class="reference internal" href="#c.gsl_spmatrix_fprintf" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> may be in any storage format, and the output file
will be written in MatrixMarket format.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_fscanf">
<a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_fscanf</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stream</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_fscanf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function reads sparse matrix data in the MatrixMarket format
from the stream <a class="reference internal" href="#c.gsl_spmatrix_fscanf" title="stream"><code class="xref c c-data docutils literal notranslate"><span class="pre">stream</span></code></a> and stores it in a newly allocated matrix
which is returned in <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a> format.  The function returns 0 for success and
<code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EFAILED</span></code> if there was a problem reading from the file. The
user should free the returned matrix when it is no longer needed.</p>
</dd></dl>

</div>
<div class="section" id="copying-matrices">
<span id="index-11"></span><h2>Copying Matrices<a class="headerlink" href="#copying-matrices" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_memcpy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_memcpy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_memcpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function copies the elements of the sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_memcpy" title="src"><code class="xref c c-data docutils literal notranslate"><span class="pre">src</span></code></a> into
<a class="reference internal" href="#c.gsl_spmatrix_memcpy" title="dest"><code class="xref c c-data docutils literal notranslate"><span class="pre">dest</span></code></a>. The two matrices must have the same dimensions and be in the
same storage format.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="exchanging-rows-and-columns">
<span id="index-12"></span><h2>Exchanging Rows and Columns<a class="headerlink" href="#exchanging-rows-and-columns" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_transpose_memcpy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_transpose_memcpy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_transpose_memcpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function copies the transpose of the sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_transpose_memcpy" title="src"><code class="xref c c-data docutils literal notranslate"><span class="pre">src</span></code></a> into
<a class="reference internal" href="#c.gsl_spmatrix_transpose_memcpy" title="dest"><code class="xref c c-data docutils literal notranslate"><span class="pre">dest</span></code></a>. The dimensions of <a class="reference internal" href="#c.gsl_spmatrix_transpose_memcpy" title="dest"><code class="xref c c-data docutils literal notranslate"><span class="pre">dest</span></code></a> must match the transpose of the
matrix <a class="reference internal" href="#c.gsl_spmatrix_transpose_memcpy" title="src"><code class="xref c c-data docutils literal notranslate"><span class="pre">src</span></code></a>. Also, both matrices must use the same sparse storage
format.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_transpose">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_transpose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_transpose" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function replaces the matrix <a class="reference internal" href="#c.gsl_spmatrix_transpose" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> by its transpose, but
changes the storage format for compressed matrix inputs. Since
compressed column storage is the transpose of compressed row storage,
this function simply converts a CSC matrix to CSR and vice versa.
This is the most efficient way to transpose a compressed storage
matrix, but the user should note that the storage format of their
compressed matrix will change on output. For COO matrix inputs,
the output matrix is also in COO storage.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="matrix-operations">
<span id="index-13"></span><h2>Matrix Operations<a class="headerlink" href="#matrix-operations" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_scale">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_scale</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_scale" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function scales all elements of the matrix <a class="reference internal" href="#c.gsl_spmatrix_scale" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a> by the constant
factor <a class="reference internal" href="#c.gsl_spmatrix_scale" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>. The result <img class="math" src="_images/math/949863e26ab9ee9e7f0aa50f2cb616d00f5e06a1.png" alt="m(i,j) \leftarrow x m(i,j)"/> is stored in <a class="reference internal" href="#c.gsl_spmatrix_scale" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_scale_columns">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_scale_columns</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_scale_columns" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function scales the columns of the <img class="math" src="_images/math/e7ca688f7c1f0c4a6496a2d3b6b6bd815553b38b.png" alt="M"/>-by-<img class="math" src="_images/math/cb5c0921ee22e878437766648c5925b76e462235.png" alt="N"/> sparse matrix
<a class="reference internal" href="#c.gsl_spmatrix_scale_columns" title="A"><code class="xref c c-data docutils literal notranslate"><span class="pre">A</span></code></a> by the elements of the vector <a class="reference internal" href="#c.gsl_spmatrix_scale_columns" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, of length <img class="math" src="_images/math/cb5c0921ee22e878437766648c5925b76e462235.png" alt="N"/>. The
<img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/>-th column of <a class="reference internal" href="#c.gsl_spmatrix_scale_columns" title="A"><code class="xref c c-data docutils literal notranslate"><span class="pre">A</span></code></a> is multiplied by <code class="code docutils literal notranslate"><span class="pre">x[j]</span></code>. This is equivalent to
forming</p>
<div class="math">
<p><img src="_images/math/6cc18abfdcbbba3ab5604e986282a35d125e19cb.png" alt="A \rightarrow A X"/></p>
</div><p>where <img class="math" src="_images/math/b8c3bdbdebb5960dcdbd020fda01b90140ed91af.png" alt="X = \textrm{diag}(x)"/>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_scale_rows">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_scale_rows</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_scale_rows" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function scales the rows of the <img class="math" src="_images/math/e7ca688f7c1f0c4a6496a2d3b6b6bd815553b38b.png" alt="M"/>-by-<img class="math" src="_images/math/cb5c0921ee22e878437766648c5925b76e462235.png" alt="N"/> sparse matrix
<a class="reference internal" href="#c.gsl_spmatrix_scale_rows" title="A"><code class="xref c c-data docutils literal notranslate"><span class="pre">A</span></code></a> by the elements of the vector <a class="reference internal" href="#c.gsl_spmatrix_scale_rows" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, of length <img class="math" src="_images/math/e7ca688f7c1f0c4a6496a2d3b6b6bd815553b38b.png" alt="M"/>. The
<img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th row of <a class="reference internal" href="#c.gsl_spmatrix_scale_rows" title="A"><code class="xref c c-data docutils literal notranslate"><span class="pre">A</span></code></a> is multiplied by <code class="code docutils literal notranslate"><span class="pre">x[i]</span></code>. This is equivalent to
forming</p>
<div class="math">
<p><img src="_images/math/4bbd871516c171b47000515f4dd12a2c83e68c23.png" alt="A \rightarrow X A"/></p>
</div><p>where <img class="math" src="_images/math/b8c3bdbdebb5960dcdbd020fda01b90140ed91af.png" alt="X = \textrm{diag}(x)"/>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the sum <img class="math" src="_images/math/40b919a12b2ecbfbb4da22238501ec23488b5c82.png" alt="c = a + b"/>. The three matrices must
have the same dimensions.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_dense_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_dense_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_dense_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function adds the elements of the sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_dense_add" title="b"><code class="xref c c-data docutils literal notranslate"><span class="pre">b</span></code></a> to the elements of
the dense matrix <a class="reference internal" href="#c.gsl_spmatrix_dense_add" title="a"><code class="xref c c-data docutils literal notranslate"><span class="pre">a</span></code></a>. The result <img class="math" src="_images/math/f7b72226283a4eeed49810a3386ae5ef9f85d2c9.png" alt="a(i,j) \leftarrow a(i,j) + b(i,j)"/> is
stored in <a class="reference internal" href="#c.gsl_spmatrix_dense_add" title="a"><code class="xref c c-data docutils literal notranslate"><span class="pre">a</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_dense_add" title="b"><code class="xref c c-data docutils literal notranslate"><span class="pre">b</span></code></a> remains unchanged. The two matrices must have
the same dimensions.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_dense_sub">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_dense_sub</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_dense_sub" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function subtracts the elements of the sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_dense_sub" title="b"><code class="xref c c-data docutils literal notranslate"><span class="pre">b</span></code></a> from the elements of
the dense matrix <a class="reference internal" href="#c.gsl_spmatrix_dense_sub" title="a"><code class="xref c c-data docutils literal notranslate"><span class="pre">a</span></code></a>. The result <img class="math" src="_images/math/4d39d97f72693e4bfbcda21b976af47c3cc5da2e.png" alt="a(i,j) \leftarrow a(i,j) - b(i,j)"/> is
stored in <a class="reference internal" href="#c.gsl_spmatrix_dense_sub" title="a"><code class="xref c c-data docutils literal notranslate"><span class="pre">a</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_dense_sub" title="b"><code class="xref c c-data docutils literal notranslate"><span class="pre">b</span></code></a> remains unchanged. The two matrices must have
the same dimensions.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="matrix-properties">
<span id="index-14"></span><h2>Matrix Properties<a class="headerlink" href="#matrix-properties" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_type">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_type</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a string describing the sparse storage format of
the matrix <a class="reference internal" href="#c.gsl_spmatrix_type" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;matrix is &#39;</span><span class="si">%s</span><span class="s2">&#39; format.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_spmatrix_type</span> <span class="p">(</span><span class="n">m</span><span class="p">));</span>
</pre></div>
</div>
<p>would print something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matrix</span> <span class="ow">is</span> <span class="s1">&#39;CSR&#39;</span> <span class="nb">format</span><span class="o">.</span>
</pre></div>
</div>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_nnz">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_nnz</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_nnz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the number of non-zero elements in <a class="reference internal" href="#c.gsl_spmatrix_nnz" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_equal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_equal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_equal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns 1 if the matrices <a class="reference internal" href="#c.gsl_spmatrix_equal" title="a"><code class="xref c c-data docutils literal notranslate"><span class="pre">a</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_equal" title="b"><code class="xref c c-data docutils literal notranslate"><span class="pre">b</span></code></a> are equal (by comparison of
element values) and 0 otherwise. The matrices <a class="reference internal" href="#c.gsl_spmatrix_equal" title="a"><code class="xref c c-data docutils literal notranslate"><span class="pre">a</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_equal" title="b"><code class="xref c c-data docutils literal notranslate"><span class="pre">b</span></code></a> must be in the same
sparse storage format for comparison.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_norm1">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_norm1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_norm1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the 1-norm of the <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>-by-<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> matrix <a class="reference internal" href="#c.gsl_spmatrix_norm1" title="A"><code class="xref c c-data docutils literal notranslate"><span class="pre">A</span></code></a>, defined as
the maximum column sum,</p>
<div class="math">
<p><img src="_images/math/c7a27a341b0d95d1126b99fe8e231aa6203bfe3e.png" alt="||A||_1 = \textrm{max}_{1 \le j \le n} \sum_{i=1}^m |A_{ij}|"/></p>
</div><p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="finding-maximum-and-minimum-elements">
<span id="index-15"></span><h2>Finding Maximum and Minimum Elements<a class="headerlink" href="#finding-maximum-and-minimum-elements" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_minmax">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_minmax</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">min_out</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">max_out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_minmax" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the minimum and maximum elements of the matrix
<a class="reference internal" href="#c.gsl_spmatrix_minmax" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>, storing them in <a class="reference internal" href="#c.gsl_spmatrix_minmax" title="min_out"><code class="xref c c-data docutils literal notranslate"><span class="pre">min_out</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_minmax" title="max_out"><code class="xref c c-data docutils literal notranslate"><span class="pre">max_out</span></code></a>, and searching
only the non-zero values.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_min_index">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_min_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">imin</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">jmin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_min_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the indices of the minimum value in the matrix
<a class="reference internal" href="#c.gsl_spmatrix_min_index" title="m"><code class="xref c c-data docutils literal notranslate"><span class="pre">m</span></code></a>, searching only the non-zero values, and storing them in <a class="reference internal" href="#c.gsl_spmatrix_min_index" title="imin"><code class="xref c c-data docutils literal notranslate"><span class="pre">imin</span></code></a> and <a class="reference internal" href="#c.gsl_spmatrix_min_index" title="jmin"><code class="xref c c-data docutils literal notranslate"><span class="pre">jmin</span></code></a>.
When there are several equal minimum elements then the first element found is returned.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="compressed-format">
<span id="index-16"></span><h2>Compressed Format<a class="headerlink" href="#compressed-format" title="Permalink to this heading">¶</a></h2>
<p>These routines calculate a compressed matrix from a coordinate representation.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_csc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_csc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_csc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function creates a sparse matrix in <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">compressed sparse column</span></a>
format from the input sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_csc" title="src"><code class="xref c c-data docutils literal notranslate"><span class="pre">src</span></code></a> which must be in COO format. The
compressed matrix is stored in <a class="reference internal" href="#c.gsl_spmatrix_csc" title="dest"><code class="xref c c-data docutils literal notranslate"><span class="pre">dest</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_csr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_csr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_csr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function creates a sparse matrix in <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">compressed sparse row</span></a>
format from the input sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_csr" title="src"><code class="xref c c-data docutils literal notranslate"><span class="pre">src</span></code></a> which must be in COO format. The
compressed matrix is stored in <a class="reference internal" href="#c.gsl_spmatrix_csr" title="dest"><code class="xref c c-data docutils literal notranslate"><span class="pre">dest</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_compress">
<a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_compress</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sptype</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_compress" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function allocates a new sparse matrix, and stores <a class="reference internal" href="#c.gsl_spmatrix_compress" title="src"><code class="xref c c-data docutils literal notranslate"><span class="pre">src</span></code></a> into it using the
format specified by <a class="reference internal" href="#c.gsl_spmatrix_compress" title="sptype"><code class="xref c c-data docutils literal notranslate"><span class="pre">sptype</span></code></a>. The input <a class="reference internal" href="#c.gsl_spmatrix_compress" title="sptype"><code class="xref c c-data docutils literal notranslate"><span class="pre">sptype</span></code></a> can be one of
<code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SPMATRIX_COO</span></code>, <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SPMATRIX_CSC</span></code>, or <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_SPMATRIX_CSR</span></code>.
A pointer to the newly allocated matrix is returned, and must be freed by the caller
when no longer needed.</p>
</dd></dl>

</div>
<div class="section" id="conversion-between-sparse-and-dense-matrices">
<span id="index-17"></span><h2>Conversion Between Sparse and Dense Matrices<a class="headerlink" href="#conversion-between-sparse-and-dense-matrices" title="Permalink to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_spmatrix</span></code></a> structure can be converted into the dense <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_matrix</span></code></a>
format and vice versa with the following routines.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_d2sp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_d2sp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">S</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_d2sp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function converts the dense matrix <a class="reference internal" href="#c.gsl_spmatrix_d2sp" title="A"><code class="xref c c-data docutils literal notranslate"><span class="pre">A</span></code></a> into sparse COO format
and stores the result in <a class="reference internal" href="#c.gsl_spmatrix_d2sp" title="S"><code class="xref c c-data docutils literal notranslate"><span class="pre">S</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_spmatrix_sp2d">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_spmatrix_sp2d</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_spmatrix" title="gsl_spmatrix"><span class="n"><span class="pre">gsl_spmatrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">S</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_spmatrix_sp2d" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function converts the sparse matrix <a class="reference internal" href="#c.gsl_spmatrix_sp2d" title="S"><code class="xref c c-data docutils literal notranslate"><span class="pre">S</span></code></a> into a dense matrix and
stores the result in <a class="reference internal" href="#c.gsl_spmatrix_sp2d" title="A"><code class="xref c c-data docutils literal notranslate"><span class="pre">A</span></code></a>.</p>
<p>Input matrix formats supported: <a class="reference internal" href="#sec-spmatrix-coo"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sec-spmatrix-csc"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sec-spmatrix-csr"><span class="std std-ref">CSR</span></a></p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="index-18"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<p>The following example program builds a 5-by-4 sparse matrix
and prints it in coordinate, compressed column, and compressed
row format. The matrix which is constructed is</p>
<div class="math">
<p><img src="_images/math/2b5320c26cf4a7e3905a5c4885c3cd370aa6f749.png" alt="\left(
  \begin{array}{cccc}
    0 &amp; 0 &amp; 3.1 &amp; 4.6 \\
    1 &amp; 0 &amp; 7.2 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 \\
    2.1 &amp; 2.9 &amp; 0 &amp; 8.5 \\
    4.1 &amp; 0 &amp; 0 &amp; 0
  \end{array}
\right)"/></p>
</div><p>The output of the program is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">printing</span> <span class="nb">all</span> <span class="n">matrix</span> <span class="n">elements</span><span class="p">:</span>
<span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.1</span>
<span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.6</span>
<span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.1</span>
<span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">matrix</span> <span class="ow">in</span> <span class="n">triplet</span> <span class="nb">format</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">Aij</span><span class="p">):</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.6</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">)</span>
<span class="n">matrix</span> <span class="ow">in</span> <span class="n">compressed</span> <span class="n">column</span> <span class="nb">format</span><span class="p">:</span>
<span class="n">i</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="p">]</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">4.6</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="p">]</span>
<span class="n">matrix</span> <span class="ow">in</span> <span class="n">compressed</span> <span class="n">row</span> <span class="nb">format</span><span class="p">:</span>
<span class="n">i</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="p">]</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">4.6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">,</span> <span class="p">]</span>
</pre></div>
</div>
<p>We see in the compressed column output, the data array stores
each column contiguously, the array <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/> stores
the row index of the corresponding data element, and the
array <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> stores the index of the start of each column in the
data array. Similarly, for the compressed row output, the
data array stores each row contiguously, the array <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>
stores the column index of the corresponding data element, and
the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> array stores the index of the start of each row
in the data array.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>

<span class="c1">#include &lt;gsl/gsl_spmatrix.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">gsl_spmatrix</span> <span class="o">*</span><span class="n">A</span> <span class="o">=</span> <span class="n">gsl_spmatrix_alloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="o">/*</span> <span class="n">triplet</span> <span class="nb">format</span> <span class="o">*/</span>
  <span class="n">gsl_spmatrix</span> <span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="o">*</span><span class="n">C</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">build</span> <span class="n">the</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="o">*/</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.6</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_set</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;printing all matrix elements:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;A(%zu,%zu) = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
             <span class="n">gsl_spmatrix_get</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>

  <span class="o">/*</span> <span class="nb">print</span> <span class="n">out</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">triplet</span> <span class="nb">format</span> <span class="o">*/</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;matrix in triplet format (i,j,Aij):</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%.1f</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">compressed</span> <span class="n">column</span> <span class="nb">format</span> <span class="o">*/</span>
  <span class="n">B</span> <span class="o">=</span> <span class="n">gsl_spmatrix_ccs</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;matrix in compressed column format:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;i = [ &quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">nz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;p = [ &quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">size2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;d = [ &quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">nz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">compressed</span> <span class="n">row</span> <span class="nb">format</span> <span class="o">*/</span>
  <span class="n">C</span> <span class="o">=</span> <span class="n">gsl_spmatrix_crs</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;matrix in compressed row format:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;i = [ &quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">nz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;p = [ &quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">size1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;d = [ &quot;</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">nz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">gsl_spmatrix_free</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_free</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
  <span class="n">gsl_spmatrix_free</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="references-and-further-reading">
<span id="index-19"></span><h2>References and Further Reading<a class="headerlink" href="#references-and-further-reading" title="Permalink to this heading">¶</a></h2>
<p>The algorithms used by these functions are described in the
following sources,</p>
<ul class="simple">
<li><p>Davis, T. A., Direct Methods for Sparse Linear Systems, SIAM, 2006.</p></li>
<li><p>CSparse software library, <a class="reference external" href="https://www.cise.ufl.edu/research/sparse/CSparse">https://www.cise.ufl.edu/research/sparse/CSparse</a></p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="spblas.html" class="btn btn-neutral float-right" title="Sparse BLAS Support" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="bspline.html" class="btn btn-neutral float-left" title="Basis Splines" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 1996-2024 The GSL Team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>