

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Linear Least-Squares Fitting &mdash; GSL 2.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Nonlinear Least-Squares Fitting" href="nls.html" />
    <link rel="prev" title="Multidimensional Minimization" href="multimin.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GSL
          

          
          </a>

          
            
            
              <div class="version">
                2.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Using the Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="err.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Mathematical Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="poly.html">Polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="specfunc.html">Special Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="vectors.html">Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiset.html">Multisets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="eigen.html">Eigensystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Fast Fourier Transforms (FFTs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Numerical Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="rng.html">Random Number Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="qrng.html">Quasi-Random Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="randist.html">Random Number Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="rstat.html">Running Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="movstat.html">Moving Window Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Digital Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="histogram.html">Histograms</a></li>
<li class="toctree-l1"><a class="reference internal" href="ntuple.html">N-tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="montecarlo.html">Monte Carlo Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="siman.html">Simulated Annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="ode-initval.html">Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="interp.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="diff.html">Numerical Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheb.html">Chebyshev Approximations</a></li>
<li class="toctree-l1"><a class="reference internal" href="sum.html">Series Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dwt.html">Wavelet Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dht.html">Discrete Hankel Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="roots.html">One Dimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="min.html">One Dimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiroots.html">Multidimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="multimin.html">Multidimensional Minimization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linear Least-Squares Fitting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linear-regression">Linear regression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#linear-regression-with-a-constant-term">Linear regression with a constant term</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-regression-without-a-constant-term">Linear regression without a constant term</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multi-parameter-regression">Multi-parameter regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#regularized-regression">Regularized regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#robust-linear-regression">Robust linear regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#large-dense-linear-systems">Large dense linear systems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#normal-equations-approach">Normal Equations Approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tall-skinny-qr-tsqr-approach">Tall Skinny QR (TSQR) Approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#large-dense-linear-systems-solution-steps">Large Dense Linear Systems Solution Steps</a></li>
<li class="toctree-l3"><a class="reference internal" href="#large-dense-linear-least-squares-routines">Large Dense Linear Least Squares Routines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simple-linear-regression-example">Simple Linear Regression Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-parameter-linear-regression-example">Multi-parameter Linear Regression Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regularized-linear-regression-example-1">Regularized Linear Regression Example 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regularized-linear-regression-example-2">Regularized Linear Regression Example 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#robust-linear-regression-example">Robust Linear Regression Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#large-dense-linear-regression-example">Large Dense Linear Regression Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nls.html">Nonlinear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="bspline.html">Basis Splines</a></li>
<li class="toctree-l1"><a class="reference internal" href="spmatrix.html">Sparse Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="spblas.html">Sparse BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="splinalg.html">Sparse Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="const.html">Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="ieee754.html">IEEE floating-point arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debugging Numerical Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributors to GSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoconf.html">Autoconf Macros</a></li>
<li class="toctree-l1"><a class="reference internal" href="cblas.html">GSL CBLAS Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpl.html">GNU General Public License</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdl.html">GNU Free Documentation License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GSL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Linear Least-Squares Fitting</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/lls.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="nls.html" class="btn btn-neutral float-right" title="Nonlinear Least-Squares Fitting" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="multimin.html" class="btn btn-neutral float-left" title="Multidimensional Minimization" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linear-least-squares-fitting">
<span id="index-0"></span><h1>Linear Least-Squares Fitting<a class="headerlink" href="#linear-least-squares-fitting" title="Permalink to this heading">¶</a></h1>
<p>This chapter describes routines for performing least squares fits to
experimental data using linear combinations of functions.  The data
may be weighted or unweighted, i.e. with known or unknown errors.  For
weighted data the functions compute the best fit parameters and their
associated covariance matrix.  For unweighted data the covariance
matrix is estimated from the scatter of the points, giving a
variance-covariance matrix.</p>
<p>The functions are divided into separate versions for simple one- or
two-parameter regression and multiple-parameter fits.</p>
<div class="section" id="overview">
<span id="sec-lls-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>Least-squares fits are found by minimizing <img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/>
(chi-squared), the weighted sum of squared residuals over <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>
experimental datapoints <img class="math" src="_images/math/ad70f3d040259e139198076b85f94c1562e72e4b.png" alt="(x_i, y_i)"/> for the model <img class="math" src="_images/math/94623636b07513dc32f3725edb00f647d824ad46.png" alt="Y(c,x)"/>,</p>
<div class="math">
<p><img src="_images/math/21469ccea34d4ba6551e5fdbd728f8773d82c53e.png" alt="\chi^2 = \sum_i w_i (y_i - Y(c, x_i))^2"/></p>
</div><p>The <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> parameters of the model are <img class="math" src="_images/math/4511468c2aa284b812fe18996f7ff31e0199e368.png" alt="c = \{c_0, c_1, \dots\}"/>.
The weight factors <img class="math" src="_images/math/ece130da0e1e9c9e66b0053903b5cffae6299256.png" alt="w_i"/> are given by <img class="math" src="_images/math/13838869480e9999005177447ac34ee219a43dba.png" alt="w_i = 1/\sigma_i^2"/>
where <img class="math" src="_images/math/1afc114625647181415bffab4b941a8da2855b04.png" alt="\sigma_i"/> is the experimental error on the data-point
<img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/>.  The errors are assumed to be
Gaussian and uncorrelated.
For unweighted data the chi-squared sum is computed without any weight factors.</p>
<p id="index-1">The fitting routines return the best-fit parameters <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/> and their
<img class="math" src="_images/math/f46eb57a4fad2fac363a30afc7b61e2d2b1c10dd.png" alt="p \times p"/> covariance matrix.  The covariance matrix measures the
statistical errors on the best-fit parameters resulting from the
errors on the data, <img class="math" src="_images/math/1afc114625647181415bffab4b941a8da2855b04.png" alt="\sigma_i"/>, and is defined
as</p>
<div class="math">
<p><img src="_images/math/baae4909796b081f0ea4bd4ac490f944f99578f1.png" alt="C_{ab} = \langle \delta c_a \delta c_b \rangle"/></p>
</div><p>where <img class="math" src="_images/math/9bf474654940bc727457f71d8bfd9393194b2447.png" alt="\langle \, \rangle"/>
denotes an average over the Gaussian error distributions of the underlying datapoints.</p>
<p>The covariance matrix is calculated by error propagation from the data
errors <img class="math" src="_images/math/1afc114625647181415bffab4b941a8da2855b04.png" alt="\sigma_i"/>.  The change in a fitted parameter <img class="math" src="_images/math/687963bd27cefbc36b932f6b957b3a126d9fa544.png" alt="\delta c_a"/>
caused by a small change in the data <img class="math" src="_images/math/82014635755ff1af5db1ce4732ec1fcb5b758d98.png" alt="\delta y_i"/> is given
by</p>
<div class="math">
<p><img src="_images/math/8b7e2b404a2bd4b85990ce6c62686bba0b7c5535.png" alt="\delta c_a = \sum_i {\partial c_a \over \partial y_i} \delta y_i"/></p>
</div><p>allowing the covariance matrix to be written in terms of the errors on the data,</p>
<div class="math">
<p><img src="_images/math/aabafd09640c6bbcc29744964a8ed016adc52fb5.png" alt="C_{ab} =  \sum_{i,j} {\partial c_a \over \partial y_i}
                     {\partial c_b \over \partial y_j}
                     \langle \delta y_i \delta y_j \rangle"/></p>
</div><p>For uncorrelated data the fluctuations of the underlying datapoints satisfy</p>
<div class="math">
<p><img src="_images/math/f56c607b21568f7265ba34c1896b13c748da5e36.png" alt="\langle \delta y_i \delta y_j \rangle = \sigma_i^2 \delta_{ij}"/></p>
</div><p>giving a corresponding parameter covariance matrix of</p>
<div class="math">
<p><img src="_images/math/4cbc74438b4cde3ef131ab197e74a98ece9771e5.png" alt="C_{ab} = \sum_{i} {1 \over w_i} {\partial c_a \over \partial y_i} {\partial c_b \over \partial y_i}"/></p>
</div><p id="index-2">When computing the covariance matrix for unweighted data, i.e. data with unknown errors,
the weight factors <img class="math" src="_images/math/ece130da0e1e9c9e66b0053903b5cffae6299256.png" alt="w_i"/> in this sum are replaced by the single estimate
<img class="math" src="_images/math/56dc89d9e28fcd4390cb4b859b6719e77b4e959c.png" alt="w = 1/\sigma^2"/>, where <img class="math" src="_images/math/fee663798dc7011f5d64a60f621ad813428ddaa4.png" alt="\sigma^2"/> is the computed variance of the
residuals about the best-fit model, <img class="math" src="_images/math/bcddbe3c546faad3ff2d245d502079ff442505b2.png" alt="\sigma^2 = \sum (y_i - Y(c,x_i))^2 / (n-p)"/>.
This is referred to as the <em>variance-covariance matrix</em>.</p>
<p>The standard deviations of the best-fit parameters are given by the
square root of the corresponding diagonal elements of
the covariance matrix, <img class="math" src="_images/math/8f170a0a894445380941972586f7afa3ba848bf0.png" alt="\sigma_{c_a} = \sqrt{C_{aa}}"/>.
The correlation coefficient of the fit parameters <img class="math" src="_images/math/a93a8532eba733808acabd91f2b7007af1666581.png" alt="c_a"/> and <img class="math" src="_images/math/efb09a5f936c171dab5394bf6d76fe8ef1a078df.png" alt="c_b"/>
is given by <img class="math" src="_images/math/d8c545148b8d4e645d4457e0b29339d54eaf85bf.png" alt="\rho_{ab} = C_{ab} / \sqrt{C_{aa} C_{bb}}"/>.</p>
</div>
<div class="section" id="linear-regression">
<span id="index-3"></span><h2>Linear regression<a class="headerlink" href="#linear-regression" title="Permalink to this heading">¶</a></h2>
<p>The functions in this section are used to fit simple one or two
parameter linear regression models. The functions are declared in
the header file <code class="file docutils literal notranslate"><span class="pre">gsl_fit.h</span></code>.</p>
<div class="section" id="linear-regression-with-a-constant-term">
<h3>Linear regression with a constant term<a class="headerlink" href="#linear-regression-with-a-constant-term" title="Permalink to this heading">¶</a></h3>
<p>The functions described in this section can be used to perform
least-squares fits to a straight line model, <img class="math" src="_images/math/7227fe332833079cc0640dbe1df6a1f3005eea73.png" alt="Y(c,x) = c_0 + c_1 x"/>.</p>
<span class="target" id="index-4"></span><dl class="c function">
<dt class="sig sig-object c" id="c.gsl_fit_linear">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_fit_linear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">xstride</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ystride</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c0</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov00</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov01</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov11</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sumsq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_fit_linear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit linear regression coefficients
(<a class="reference internal" href="#c.gsl_fit_linear" title="c0"><code class="xref c c-data docutils literal notranslate"><span class="pre">c0</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a>) of the model <img class="math" src="_images/math/2dd8061791551d81eef867a6c3883c67b2e1ba53.png" alt="Y = c_0 + c_1 X"/> for the dataset
(<a class="reference internal" href="#c.gsl_fit_linear" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>), two vectors of length <a class="reference internal" href="#c.gsl_fit_linear" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> with strides
<a class="reference internal" href="#c.gsl_fit_linear" title="xstride"><code class="xref c c-data docutils literal notranslate"><span class="pre">xstride</span></code></a> and <a class="reference internal" href="#c.gsl_fit_linear" title="ystride"><code class="xref c c-data docutils literal notranslate"><span class="pre">ystride</span></code></a>.  The errors on <a class="reference internal" href="#c.gsl_fit_linear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> are assumed unknown so
the variance-covariance matrix for the
parameters (<a class="reference internal" href="#c.gsl_fit_linear" title="c0"><code class="xref c c-data docutils literal notranslate"><span class="pre">c0</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a>) is estimated from the scatter of the
points around the best-fit line and returned via the parameters
(<a class="reference internal" href="#c.gsl_fit_linear" title="cov00"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov00</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear" title="cov01"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov01</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear" title="cov11"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov11</span></code></a>).
The sum of squares of the residuals from the best-fit line is returned
in <a class="reference internal" href="#c.gsl_fit_linear" title="sumsq"><code class="xref c c-data docutils literal notranslate"><span class="pre">sumsq</span></code></a>.  Note: the correlation coefficient of the data can be computed using
<a class="reference internal" href="statistics.html#c.gsl_stats_correlation" title="gsl_stats_correlation"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_stats_correlation()</span></code></a>, it does not depend on the fit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_fit_wlinear">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_fit_wlinear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">xstride</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">wstride</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ystride</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c0</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov00</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov01</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov11</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chisq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_fit_wlinear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit linear regression coefficients
(<a class="reference internal" href="#c.gsl_fit_wlinear" title="c0"><code class="xref c c-data docutils literal notranslate"><span class="pre">c0</span></code></a>, <a class="reference internal" href="#c.gsl_fit_wlinear" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a>) of the model <img class="math" src="_images/math/2dd8061791551d81eef867a6c3883c67b2e1ba53.png" alt="Y = c_0 + c_1 X"/> for the weighted
dataset (<a class="reference internal" href="#c.gsl_fit_wlinear" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <a class="reference internal" href="#c.gsl_fit_wlinear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>), two vectors of length <a class="reference internal" href="#c.gsl_fit_wlinear" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> with strides
<a class="reference internal" href="#c.gsl_fit_wlinear" title="xstride"><code class="xref c c-data docutils literal notranslate"><span class="pre">xstride</span></code></a> and <a class="reference internal" href="#c.gsl_fit_wlinear" title="ystride"><code class="xref c c-data docutils literal notranslate"><span class="pre">ystride</span></code></a>.  The vector <a class="reference internal" href="#c.gsl_fit_wlinear" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>, of length <a class="reference internal" href="#c.gsl_fit_wlinear" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>
and stride <a class="reference internal" href="#c.gsl_fit_wlinear" title="wstride"><code class="xref c c-data docutils literal notranslate"><span class="pre">wstride</span></code></a>, specifies the weight of each datapoint. The
weight is the reciprocal of the variance for each datapoint in <a class="reference internal" href="#c.gsl_fit_wlinear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>.</p>
<p>The covariance matrix for the parameters (<a class="reference internal" href="#c.gsl_fit_wlinear" title="c0"><code class="xref c c-data docutils literal notranslate"><span class="pre">c0</span></code></a>, <a class="reference internal" href="#c.gsl_fit_wlinear" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a>) is
computed using the weights and returned via the parameters
(<a class="reference internal" href="#c.gsl_fit_wlinear" title="cov00"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov00</span></code></a>, <a class="reference internal" href="#c.gsl_fit_wlinear" title="cov01"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov01</span></code></a>, <a class="reference internal" href="#c.gsl_fit_wlinear" title="cov11"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov11</span></code></a>).  The weighted sum of squares
of the residuals from the best-fit line, <img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/>, is returned in
<a class="reference internal" href="#c.gsl_fit_wlinear" title="chisq"><code class="xref c c-data docutils literal notranslate"><span class="pre">chisq</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_fit_linear_est">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_fit_linear_est</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c0</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">cov00</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">cov01</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">cov11</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y_err</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_fit_linear_est" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function uses the best-fit linear regression coefficients
<a class="reference internal" href="#c.gsl_fit_linear_est" title="c0"><code class="xref c c-data docutils literal notranslate"><span class="pre">c0</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear_est" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a> and their covariance
<a class="reference internal" href="#c.gsl_fit_linear_est" title="cov00"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov00</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear_est" title="cov01"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov01</span></code></a>, <a class="reference internal" href="#c.gsl_fit_linear_est" title="cov11"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov11</span></code></a> to compute the fitted function
<a class="reference internal" href="#c.gsl_fit_linear_est" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and its standard deviation <a class="reference internal" href="#c.gsl_fit_linear_est" title="y_err"><code class="xref c c-data docutils literal notranslate"><span class="pre">y_err</span></code></a> for the model <img class="math" src="_images/math/2dd8061791551d81eef867a6c3883c67b2e1ba53.png" alt="Y = c_0 + c_1 X"/>
at the point <a class="reference internal" href="#c.gsl_fit_linear_est" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="linear-regression-without-a-constant-term">
<h3>Linear regression without a constant term<a class="headerlink" href="#linear-regression-without-a-constant-term" title="Permalink to this heading">¶</a></h3>
<p>The functions described in this section can be used to perform
least-squares fits to a straight line model without a constant term,
<img class="math" src="_images/math/e2673ec96b878738d2d11d755ecc34317aa7bd51.png" alt="Y = c_1 X"/>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_fit_mul">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_fit_mul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">xstride</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ystride</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov11</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sumsq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_fit_mul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit linear regression coefficient
<a class="reference internal" href="#c.gsl_fit_mul" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a> of the model <img class="math" src="_images/math/e2673ec96b878738d2d11d755ecc34317aa7bd51.png" alt="Y = c_1 X"/> for the datasets (<a class="reference internal" href="#c.gsl_fit_mul" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>,
<a class="reference internal" href="#c.gsl_fit_mul" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>), two vectors of length <a class="reference internal" href="#c.gsl_fit_mul" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> with strides <a class="reference internal" href="#c.gsl_fit_mul" title="xstride"><code class="xref c c-data docutils literal notranslate"><span class="pre">xstride</span></code></a> and
<a class="reference internal" href="#c.gsl_fit_mul" title="ystride"><code class="xref c c-data docutils literal notranslate"><span class="pre">ystride</span></code></a>.  The errors on <a class="reference internal" href="#c.gsl_fit_mul" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> are assumed unknown so the
variance of the parameter <a class="reference internal" href="#c.gsl_fit_mul" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a> is estimated from
the scatter of the points around the best-fit line and returned via the
parameter <a class="reference internal" href="#c.gsl_fit_mul" title="cov11"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov11</span></code></a>.  The sum of squares of the residuals from the
best-fit line is returned in <a class="reference internal" href="#c.gsl_fit_mul" title="sumsq"><code class="xref c c-data docutils literal notranslate"><span class="pre">sumsq</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_fit_wmul">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_fit_wmul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">xstride</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">wstride</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ystride</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov11</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sumsq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_fit_wmul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit linear regression coefficient
<a class="reference internal" href="#c.gsl_fit_wmul" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a> of the model <img class="math" src="_images/math/e2673ec96b878738d2d11d755ecc34317aa7bd51.png" alt="Y = c_1 X"/> for the weighted datasets
(<a class="reference internal" href="#c.gsl_fit_wmul" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>, <a class="reference internal" href="#c.gsl_fit_wmul" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>), two vectors of length <a class="reference internal" href="#c.gsl_fit_wmul" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a> with strides
<a class="reference internal" href="#c.gsl_fit_wmul" title="xstride"><code class="xref c c-data docutils literal notranslate"><span class="pre">xstride</span></code></a> and <a class="reference internal" href="#c.gsl_fit_wmul" title="ystride"><code class="xref c c-data docutils literal notranslate"><span class="pre">ystride</span></code></a>.  The vector <a class="reference internal" href="#c.gsl_fit_wmul" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>, of length <a class="reference internal" href="#c.gsl_fit_wmul" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>
and stride <a class="reference internal" href="#c.gsl_fit_wmul" title="wstride"><code class="xref c c-data docutils literal notranslate"><span class="pre">wstride</span></code></a>, specifies the weight of each datapoint. The
weight is the reciprocal of the variance for each datapoint in <a class="reference internal" href="#c.gsl_fit_wmul" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>.</p>
<p>The variance of the parameter <a class="reference internal" href="#c.gsl_fit_wmul" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a> is computed using the weights
and returned via the parameter <a class="reference internal" href="#c.gsl_fit_wmul" title="cov11"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov11</span></code></a>.  The weighted sum of
squares of the residuals from the best-fit line, <img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/>, is
returned in <code class="xref c c-data docutils literal notranslate"><span class="pre">chisq</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_fit_mul_est">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_fit_mul_est</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">cov11</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y_err</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_fit_mul_est" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function uses the best-fit linear regression coefficient <a class="reference internal" href="#c.gsl_fit_mul_est" title="c1"><code class="xref c c-data docutils literal notranslate"><span class="pre">c1</span></code></a>
and its covariance <a class="reference internal" href="#c.gsl_fit_mul_est" title="cov11"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov11</span></code></a> to compute the fitted function
<a class="reference internal" href="#c.gsl_fit_mul_est" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and its standard deviation <a class="reference internal" href="#c.gsl_fit_mul_est" title="y_err"><code class="xref c c-data docutils literal notranslate"><span class="pre">y_err</span></code></a> for the model <img class="math" src="_images/math/e2673ec96b878738d2d11d755ecc34317aa7bd51.png" alt="Y = c_1 X"/>
at the point <a class="reference internal" href="#c.gsl_fit_mul_est" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="multi-parameter-regression">
<span id="index-5"></span><h2>Multi-parameter regression<a class="headerlink" href="#multi-parameter-regression" title="Permalink to this heading">¶</a></h2>
<p>This section describes routines which perform least squares fits
to a linear model by minimizing the cost function</p>
<div class="math">
<p><img src="_images/math/0275f9dbe9fc03f96470ded94ea1872001feb9f2.png" alt="\chi^2 = \sum_i w_i (y_i - \sum_j X_{ij} c_j)^2 = || y - Xc ||_W^2"/></p>
</div><p>where <img class="math" src="_images/math/e5b4bb56c8a593a62ae474d2b008601486633c57.png" alt="y"/> is a vector of <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> observations, <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is an
<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> matrix of predictor variables, <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>
is a vector of the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> unknown best-fit parameters to be estimated,
and <img class="math" src="_images/math/90318343df24eb2dbc5fc98eab73e2224f98db1e.png" alt="||r||_W^2 = r^T W r"/>.
The matrix <img class="math" src="_images/math/8bb90d710f2483236cf508b737cf308fd3311a5c.png" alt="W = \diag(w_1,w_2,...,w_n)"/>
defines the weights or uncertainties of the observation vector.</p>
<p>This formulation can be used for fits to any number of functions and/or
variables by preparing the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>
appropriately.  For example, to fit to a <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-th order polynomial in
<code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code>, use the following matrix,</p>
<div class="math">
<p><img src="_images/math/ad3a9bb52d27e8bae43286fed808d04b5ef5f1f1.png" alt="X_{ij} = x_i^j"/></p>
</div><p>where the index <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/> runs over the observations and the index
<img class="math" src="_images/math/247a8ccf6f990a64b94856540b903c7d1e5eef57.png" alt="j"/> runs from 0 to <img class="math" src="_images/math/f319dc0b455b56a0bfb2a7448142a82b8d12d43b.png" alt="p-1"/>.</p>
<p>To fit to a set of <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> sinusoidal functions with fixed frequencies
<img class="math" src="_images/math/d54dd7742085276680aa4c681fc1088c1b13b17c.png" alt="\omega_1"/>, <img class="math" src="_images/math/aa57569d7043a6201dce6cbd2cb10a2c7b494682.png" alt="\omega_2"/>, <img class="math" src="_images/math/53256bc793b26b48478d059a5d9cce53967ac5b8.png" alt="\ldots"/>, <img class="math" src="_images/math/fb3d1a4176e5ae3780c64e3ef166b14c6cc9ece4.png" alt="\omega_p"/>, use,</p>
<div class="math">
<p><img src="_images/math/df0506c51616fb109c486ed5148504381f648815.png" alt="X_{ij} = \sin(\omega_j x_i)"/></p>
</div><p>To fit to <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> independent variables <img class="math" src="_images/math/24602676470d1b68669ee2c8c4d27881b06c2bfb.png" alt="x_1"/>, <img class="math" src="_images/math/d01babce8c7bf4a2bfac70acab479ab87273eb6b.png" alt="x_2"/>, <img class="math" src="_images/math/53256bc793b26b48478d059a5d9cce53967ac5b8.png" alt="\ldots"/>,
<img class="math" src="_images/math/c3cd8fdfe6289bf282f822fa4e618d8319950078.png" alt="x_p"/>, use,</p>
<div class="math">
<p><img src="_images/math/657c98dad0cae681091507c7092c0a2dd1cbd584.png" alt="X_{ij} = x_j(i)"/></p>
</div><p>where <img class="math" src="_images/math/503ee0719115f055b01d8c3c83082afef73632e9.png" alt="x_j(i)"/> is the <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th value of the predictor variable
<img class="math" src="_images/math/c5242f856a421244a55e05fc48cca97da5d6357d.png" alt="x_j"/>.</p>
<p>The solution of the general linear least-squares system requires an
additional working space for intermediate results, such as the singular
value decomposition of the matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>.</p>
<p>These functions are declared in the header file <code class="file docutils literal notranslate"><span class="pre">gsl_multifit.h</span></code>.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_workspace">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></span><a class="headerlink" href="#c.gsl_multifit_linear_workspace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This workspace contains internal variables for fitting multi-parameter models.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_alloc">
<a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function allocates a workspace for fitting a model to a maximum of <a class="reference internal" href="#c.gsl_multifit_linear_alloc" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>
observations using a maximum of <a class="reference internal" href="#c.gsl_multifit_linear_alloc" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a> parameters. The user may later supply
a smaller least squares system if desired. The size of the workspace is
<img class="math" src="_images/math/c62e6562fa6037dd1aa9b7e1c574f434a511d1c2.png" alt="O(np + p^2)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function frees the memory associated with the workspace <code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_svd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_svd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_svd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function performs a singular value decomposition of the
matrix <a class="reference internal" href="#c.gsl_multifit_linear_svd" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and stores the SVD factors internally in <a class="reference internal" href="#c.gsl_multifit_linear_svd" title="work"><code class="xref c c-data docutils literal notranslate"><span class="pre">work</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_bsvd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_bsvd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_bsvd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function performs a singular value decomposition of the
matrix <a class="reference internal" href="#c.gsl_multifit_linear_bsvd" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and stores the SVD factors internally in <a class="reference internal" href="#c.gsl_multifit_linear_bsvd" title="work"><code class="xref c c-data docutils literal notranslate"><span class="pre">work</span></code></a>.
The matrix <a class="reference internal" href="#c.gsl_multifit_linear_bsvd" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> is first balanced by applying column scaling
factors to improve the accuracy of the singular values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chisq</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit parameters <a class="reference internal" href="#c.gsl_multifit_linear" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> of the model
<img class="math" src="_images/math/99cbc107343e7510de0a1bf2df0cc5ffb55518f5.png" alt="y = X c"/> for the observations <a class="reference internal" href="#c.gsl_multifit_linear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and the matrix of
predictor variables <a class="reference internal" href="#c.gsl_multifit_linear" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, using the preallocated workspace provided
in <a class="reference internal" href="#c.gsl_multifit_linear" title="work"><code class="xref c c-data docutils literal notranslate"><span class="pre">work</span></code></a>.  The <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> variance-covariance matrix of the model parameters
<a class="reference internal" href="#c.gsl_multifit_linear" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> is set to <img class="math" src="_images/math/1fa39602bd12370391bcd2710922b2d41a48cf37.png" alt="\sigma^2 (X^T X)^{-1}"/>, where <img class="math" src="_images/math/0b7620936fd7a90e5dde43c07609be992245871a.png" alt="\sigma"/> is
the standard deviation of the fit residuals.
The sum of squares of the residuals from the best-fit,
<img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/>, is returned in <a class="reference internal" href="#c.gsl_multifit_linear" title="chisq"><code class="xref c c-data docutils literal notranslate"><span class="pre">chisq</span></code></a>. If the coefficient of
determination is desired, it can be computed from the expression
<img class="math" src="_images/math/4a4becbc9be1aa45dc5406f110c3865c68655aca.png" alt="R^2 = 1 - \chi^2 / TSS"/>, where the total sum of squares (TSS) of
the observations <a class="reference internal" href="#c.gsl_multifit_linear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> may be computed from <a class="reference internal" href="statistics.html#c.gsl_stats_tss" title="gsl_stats_tss"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_stats_tss()</span></code></a>.</p>
<p>The best-fit is found by singular value decomposition of the matrix
<a class="reference internal" href="#c.gsl_multifit_linear" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> using the modified Golub-Reinsch SVD algorithm, with column
scaling to improve the accuracy of the singular values. Any components
which have zero singular value (to machine precision) are discarded
from the fit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_tsvd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_tsvd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">tol</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chisq</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rank</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_tsvd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit parameters <a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> of the model
<img class="math" src="_images/math/99cbc107343e7510de0a1bf2df0cc5ffb55518f5.png" alt="y = X c"/> for the observations <a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and the matrix of
predictor variables <a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, using a truncated SVD expansion.
Singular values which satisfy <img class="math" src="_images/math/0453ebb68dbc21e2569d349fe20d387d2440fad9.png" alt="s_i \le tol \times s_0"/>
are discarded from the fit, where <img class="math" src="_images/math/8480379ede7b7f654be53425ceaee08d7bacafa5.png" alt="s_0"/> is the largest singular value.
The <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> variance-covariance matrix of the model parameters
<a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> is set to <img class="math" src="_images/math/1fa39602bd12370391bcd2710922b2d41a48cf37.png" alt="\sigma^2 (X^T X)^{-1}"/>, where <img class="math" src="_images/math/0b7620936fd7a90e5dde43c07609be992245871a.png" alt="\sigma"/> is
the standard deviation of the fit residuals.
The sum of squares of the residuals from the best-fit,
<img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/>, is returned in <a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="chisq"><code class="xref c c-data docutils literal notranslate"><span class="pre">chisq</span></code></a>. The effective rank
(number of singular values used in solution) is returned in <a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="rank"><code class="xref c c-data docutils literal notranslate"><span class="pre">rank</span></code></a>.
If the coefficient of
determination is desired, it can be computed from the expression
<img class="math" src="_images/math/4a4becbc9be1aa45dc5406f110c3865c68655aca.png" alt="R^2 = 1 - \chi^2 / TSS"/>, where the total sum of squares (TSS) of
the observations <a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> may be computed from <a class="reference internal" href="statistics.html#c.gsl_stats_tss" title="gsl_stats_tss"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_stats_tss()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_wlinear">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_wlinear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chisq</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_wlinear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit parameters <a class="reference internal" href="#c.gsl_multifit_wlinear" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> of the weighted
model <img class="math" src="_images/math/99cbc107343e7510de0a1bf2df0cc5ffb55518f5.png" alt="y = X c"/> for the observations <a class="reference internal" href="#c.gsl_multifit_wlinear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> with weights <a class="reference internal" href="#c.gsl_multifit_wlinear" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>
and the matrix of predictor variables <a class="reference internal" href="#c.gsl_multifit_wlinear" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, using the preallocated
workspace provided in <a class="reference internal" href="#c.gsl_multifit_wlinear" title="work"><code class="xref c c-data docutils literal notranslate"><span class="pre">work</span></code></a>.  The <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> covariance matrix of the model
parameters <a class="reference internal" href="#c.gsl_multifit_wlinear" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> is computed as <img class="math" src="_images/math/3d30aadd1b8eee6f86565fc23fae88d3dee0df0c.png" alt="(X^T W X)^{-1}"/>. The weighted
sum of squares of the residuals from the best-fit, <img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/>, is
returned in <a class="reference internal" href="#c.gsl_multifit_wlinear" title="chisq"><code class="xref c c-data docutils literal notranslate"><span class="pre">chisq</span></code></a>. If the coefficient of determination is
desired, it can be computed from the expression <img class="math" src="_images/math/6572ea04e6494aa014f7d6f357b086bc2c3f222a.png" alt="R^2 = 1 - \chi^2 / WTSS"/>,
where the weighted total sum of squares (WTSS) of the
observations <a class="reference internal" href="#c.gsl_multifit_wlinear" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> may be computed from <a class="reference internal" href="statistics.html#c.gsl_stats_wtss" title="gsl_stats_wtss"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_stats_wtss()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_wlinear_tsvd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_wlinear_tsvd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">tol</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chisq</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rank</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_wlinear_tsvd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit parameters <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> of the weighted
model <img class="math" src="_images/math/99cbc107343e7510de0a1bf2df0cc5ffb55518f5.png" alt="y = X c"/> for the observations <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> with weights <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>
and the matrix of predictor variables <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, using a truncated SVD expansion.
Singular values which satisfy <img class="math" src="_images/math/0453ebb68dbc21e2569d349fe20d387d2440fad9.png" alt="s_i \le tol \times s_0"/>
are discarded from the fit, where <img class="math" src="_images/math/8480379ede7b7f654be53425ceaee08d7bacafa5.png" alt="s_0"/> is the largest singular value.
The <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> covariance matrix of the model
parameters <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> is computed as <img class="math" src="_images/math/3d30aadd1b8eee6f86565fc23fae88d3dee0df0c.png" alt="(X^T W X)^{-1}"/>. The weighted
sum of squares of the residuals from the best-fit, <img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/>, is
returned in <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="chisq"><code class="xref c c-data docutils literal notranslate"><span class="pre">chisq</span></code></a>. The effective rank of the system (number of
singular values used in the solution) is returned in <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="rank"><code class="xref c c-data docutils literal notranslate"><span class="pre">rank</span></code></a>.
If the coefficient of determination is
desired, it can be computed from the expression <img class="math" src="_images/math/6572ea04e6494aa014f7d6f357b086bc2c3f222a.png" alt="R^2 = 1 - \chi^2 / WTSS"/>,
where the weighted total sum of squares (WTSS) of the
observations <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> may be computed from <a class="reference internal" href="statistics.html#c.gsl_stats_wtss" title="gsl_stats_wtss"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_stats_wtss()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_est">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_est</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y_err</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_est" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function uses the best-fit multilinear regression coefficients
<a class="reference internal" href="#c.gsl_multifit_linear_est" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> and their covariance matrix
<a class="reference internal" href="#c.gsl_multifit_linear_est" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> to compute the fitted function value
<a class="reference internal" href="#c.gsl_multifit_linear_est" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and its standard deviation <a class="reference internal" href="#c.gsl_multifit_linear_est" title="y_err"><code class="xref c c-data docutils literal notranslate"><span class="pre">y_err</span></code></a> for the model <img class="math" src="_images/math/494d25330922c5ba36fac0504244794ea178b92e.png" alt="y = x.c"/>
at the point <a class="reference internal" href="#c.gsl_multifit_linear_est" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_residuals">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_residuals</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_residuals" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the vector of residuals <img class="math" src="_images/math/337af926c0a6897677095257998619bb210f66f0.png" alt="r = y - X c"/> for
the observations <a class="reference internal" href="#c.gsl_multifit_linear_residuals" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>, coefficients <a class="reference internal" href="#c.gsl_multifit_linear_residuals" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> and matrix of predictor
variables <a class="reference internal" href="#c.gsl_multifit_linear_residuals" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_rank">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_rank</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">tol</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_rank" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the rank of the matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> which must first have its
singular value decomposition computed. The rank is computed by counting the number
of singular values <img class="math" src="_images/math/53ba22e50835b710332437fc47ab0081590cc64d.png" alt="\sigma_j"/> which satisfy <img class="math" src="_images/math/3e3aad716ac2c8b628b0b10b06aca2d8266ed3e8.png" alt="\sigma_j &gt; tol \times \sigma_0"/>,
where <img class="math" src="_images/math/d9b236be63f1b6cf53f78a56edc1c0ecdab5f2fb.png" alt="\sigma_0"/> is the largest singular value.</p>
</dd></dl>

</div>
<div class="section" id="regularized-regression">
<span id="sec-regularized-regression"></span><span id="index-6"></span><h2>Regularized regression<a class="headerlink" href="#regularized-regression" title="Permalink to this heading">¶</a></h2>
<p>Ordinary weighted least squares models seek a solution vector <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>
which minimizes the residual</p>
<div class="math">
<p><img src="_images/math/a5d4ff2e3403d48d336874d718e61dbf4088d748.png" alt="\chi^2 = || y - Xc ||_W^2"/></p>
</div><p>where <img class="math" src="_images/math/e5b4bb56c8a593a62ae474d2b008601486633c57.png" alt="y"/> is the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> observation vector,
<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> design matrix, <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/> is
the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> solution vector,
<img class="math" src="_images/math/80a48286f7653341c11da72e4739a79fd43b19ff.png" alt="W = \diag(w_1,...,w_n)"/> is the data weighting matrix,
and <img class="math" src="_images/math/90318343df24eb2dbc5fc98eab73e2224f98db1e.png" alt="||r||_W^2 = r^T W r"/>.
In cases where the least squares matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is ill-conditioned,
small perturbations (ie: noise) in the observation vector could lead to
widely different solution vectors <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>.
One way of dealing with ill-conditioned matrices is to use a “truncated SVD”
in which small singular values, below some given tolerance, are discarded
from the solution. The truncated SVD method is available using the functions
<a class="reference internal" href="#c.gsl_multifit_linear_tsvd" title="gsl_multifit_linear_tsvd"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_tsvd()</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_wlinear_tsvd" title="gsl_multifit_wlinear_tsvd"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_wlinear_tsvd()</span></code></a>. Another way
to help solve ill-posed problems is to include a regularization term in the least squares
minimization</p>
<div class="math">
<p><img src="_images/math/c4a1da929344f61da379b7b9e1a4868b3d3237f1.png" alt="\chi^2 = || y - Xc ||_W^2 + \lambda^2 || L c ||^2"/></p>
</div><p>for a suitably chosen regularization parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> and
matrix <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>. This type of regularization is known as Tikhonov, or ridge,
regression. In some applications, <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/> is chosen as the identity matrix, giving
preference to solution vectors <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/> with smaller norms.
Including this regularization term leads to the explicit “normal equations” solution</p>
<div class="math">
<p><img src="_images/math/d75e9fb4f52767b167e0e4c9443a06eeb8584b58.png" alt="c = \left( X^T W X + \lambda^2 L^T L \right)^{-1} X^T W y"/></p>
</div><p>which reduces to the ordinary least squares solution when <img class="math" src="_images/math/652b67ac387643dd29b8ba744b5ddfcc2ac69314.png" alt="L = 0"/>.
In practice, it is often advantageous to transform a regularized least
squares system into the form</p>
<div class="math">
<p><img src="_images/math/6869e58f32e10de3235ac54bd0977fff503855d4.png" alt="\chi^2 = || \tilde{y} - \tilde{X} \tilde{c} ||^2 + \lambda^2 || \tilde{c} ||^2"/></p>
</div><p>This is known as the Tikhonov “standard form” and has the normal equations solution</p>
<div class="math">
<p><img src="_images/math/c0a9a434c2da5ef77048576e8c1a9e7d4ad032e7.png" alt="\tilde{c} = \left( \tilde{X}^T \tilde{X} + \lambda^2 I \right)^{-1} \tilde{X}^T \tilde{y}"/></p>
</div><p>For an <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> matrix <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/> which is full rank and has <img class="math" src="_images/math/b9069a3b1bc7efa713c798061cd96efc13f11bf8.png" alt="m &gt;= p"/> (ie: <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/> is
square or has more rows than columns), we can calculate the “thin” QR decomposition of <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>, and
note that <img class="math" src="_images/math/5e3a73d33dae9b46a082ca9b3d40fd869200a091.png" alt="||L c|| = ||R c||"/> since the <img class="math" src="_images/math/e103d281ada9f45ddb73d266667a18adc3e50536.png" alt="Q"/> factor will not change the norm. Since
<img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> is <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>, we can then use the transformation</p>
<div class="math">
<p><img src="_images/math/695a9180baa54212d68ac2c3aa5a685b22a3c357.png" alt="\tilde{X} &amp;= W^{1 \over 2} X R^{-1} \\
\tilde{y} &amp;= W^{1 \over 2} y \\
\tilde{c} &amp;= R c"/></p>
</div><p>to achieve the standard form. For a rectangular matrix <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/> with <img class="math" src="_images/math/362201b066e8e87e1fa8c3f7873914c3b6d5659f.png" alt="m &lt; p"/>,
a more sophisticated approach is needed (see Hansen 1998, chapter 2.3).
In practice, the normal equations solution above is not desirable due to
numerical instabilities, and so the system is solved using the
singular value decomposition of the matrix <img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>.
The matrix <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/> is often chosen as the identity matrix, or as a first
or second finite difference operator, to ensure a smoothly varying
coefficient vector <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>, or as a diagonal matrix to selectively damp
each model parameter differently. If <img class="math" src="_images/math/69f2bc1efc42f3636c85009484d57df6dbd19e88.png" alt="L \ne I"/>, the user must first
convert the least squares problem to standard form using
<a class="reference internal" href="#c.gsl_multifit_linear_stdform1" title="gsl_multifit_linear_stdform1"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_stdform1()</span></code></a> or <a class="reference internal" href="#c.gsl_multifit_linear_stdform2" title="gsl_multifit_linear_stdform2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_stdform2()</span></code></a>,
solve the system, and then backtransform the solution vector to recover
the solution of the original problem (see
<a class="reference internal" href="#c.gsl_multifit_linear_genform1" title="gsl_multifit_linear_genform1"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_genform1()</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_genform2" title="gsl_multifit_linear_genform2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_genform2()</span></code></a>).</p>
<p>In many regularization problems, care must be taken when choosing
the regularization parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/>. Since both the
residual norm <img class="math" src="_images/math/9387d7df765bf77a9bcc70af7d6ffa9cbc3601c4.png" alt="||y - X c||"/> and solution norm <img class="math" src="_images/math/4096020c4dcaa6e48790dd0d53081a7923320328.png" alt="||L c||"/>
are being minimized, the parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> represents
a tradeoff between minimizing either the residuals or the
solution vector. A common tool for visualizing the comprimise between
the minimization of these two quantities is known as the L-curve.
The L-curve is a log-log plot of the residual norm <img class="math" src="_images/math/9387d7df765bf77a9bcc70af7d6ffa9cbc3601c4.png" alt="||y - X c||"/>
on the horizontal axis and the solution norm <img class="math" src="_images/math/4096020c4dcaa6e48790dd0d53081a7923320328.png" alt="||L c||"/> on the
vertical axis. This curve nearly always as an <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/> shaped
appearance, with a distinct corner separating the horizontal
and vertical sections of the curve. The regularization parameter
corresponding to this corner is often chosen as the optimal
value. GSL provides routines to calculate the L-curve for all
relevant regularization parameters as well as locating the corner.</p>
<p>Another method of choosing the regularization parameter is known
as Generalized Cross Validation (GCV). This method is based on
the idea that if an arbitrary element <img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/> is left out of the
right hand side, the resulting regularized solution should predict this element
accurately. This leads to choosing the parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/>
which minimizes the GCV function</p>
<div class="math">
<p><img src="_images/math/d6f6f70c67e1d99a5f7e931260edda6f076d0fec.png" alt="G(\lambda) = {||y - X c_{\lambda}||^2 \over \textrm{Tr}(I_n - X X_{\lambda}^I)^2}"/></p>
</div><p>where <img class="math" src="_images/math/eac4706de5f850c2dc215c3410a707fb11f22e7e.png" alt="X_{\lambda}^I"/> is the matrix which relates the solution <img class="math" src="_images/math/7f4a3fd21a997635dd0909679f0f2563b8b9d129.png" alt="c_{\lambda}"/>
to the right hand side <img class="math" src="_images/math/e5b4bb56c8a593a62ae474d2b008601486633c57.png" alt="y"/>, ie: <img class="math" src="_images/math/58fd20930ffae27f7ed344e06099fa1a3aa66135.png" alt="c_{\lambda} = X_{\lambda}^I y"/>. GSL
provides routines to compute the GCV curve and its minimum.</p>
<p>For most applications, the steps required to solve a regularized least
squares problem are as follows:</p>
<ol class="arabic simple">
<li><p>Construct the least squares system (<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>, <img class="math" src="_images/math/e5b4bb56c8a593a62ae474d2b008601486633c57.png" alt="y"/>, <img class="math" src="_images/math/3e0a087f1ba0411943c6deb7302825e47c187635.png" alt="W"/>, <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>)</p></li>
<li><p>Transform the system to standard form (<img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>, <img class="math" src="_images/math/fb66b789ec86f2ea9b05b20a80f9485ef0dd4f55.png" alt="\tilde{y}"/>). This
step can be skipped if <img class="math" src="_images/math/13e11c89208db2d5a53e4975e109e601c745a9a9.png" alt="L = I_p"/> and <img class="math" src="_images/math/8a7f3d51758880a49a21561e048fa41025c5cb4b.png" alt="W = I_n"/>.</p></li>
<li><p>Calculate the SVD of <img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>.</p></li>
<li><p>Determine an appropriate regularization parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> (using for example
L-curve or GCV analysis).</p></li>
<li><p>Solve the standard form system using the chosen <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> and the SVD of <img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>.</p></li>
<li><p>Backtransform the standard form solution <img class="math" src="_images/math/d595cf6fc55e8feab2b73cc1099ccdb6ec695d46.png" alt="\tilde{c}"/> to recover the
original solution vector <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>.</p></li>
</ol>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_stdform1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_stdform1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_stdform1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multifit_linear_wstdform1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_wstdform1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_wstdform1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions define a regularization matrix
<img class="math" src="_images/math/c04aeaa2e316655ead39b01d5d1b62af409679c8.png" alt="L = \diag(l_0,l_1,...,l_{p-1})"/>.
The diagonal matrix element <img class="math" src="_images/math/799fdcdc5a755a13e87ed5f26d03acd53305516f.png" alt="l_i"/> is provided by the
<img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th element of the input vector <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a>.
The <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> least squares matrix <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and
vector <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> of length <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> are then
converted to standard form as described above and the parameters
(<img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>, <img class="math" src="_images/math/fb66b789ec86f2ea9b05b20a80f9485ef0dd4f55.png" alt="\tilde{y}"/>) are stored in <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a>
on output.  <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> have the same dimensions as
<a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>. Optional data weights may be supplied in the
vector <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a> of length <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>. In order to apply this transformation,
<img class="math" src="_images/math/9a74993ef564e44ea7bb959c0555afff5884e9e0.png" alt="L^{-1}"/> must exist and so none of the <img class="math" src="_images/math/799fdcdc5a755a13e87ed5f26d03acd53305516f.png" alt="l_i"/>
may be zero. After the standard form system has been solved,
use <a class="reference internal" href="#c.gsl_multifit_linear_genform1" title="gsl_multifit_linear_genform1"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_genform1()</span></code></a> to recover the original solution vector.
It is allowed to have <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> = <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> = <a class="reference internal" href="#c.gsl_multifit_linear_wstdform1" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> for an in-place transform.
In order to perform a weighted regularized fit with <img class="math" src="_images/math/a1c0cd9abf11352165b5e8846ec6d28d89562741.png" alt="L = I"/>, the user may
call <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="gsl_multifit_linear_applyW"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_applyW()</span></code></a> to convert to standard form.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_L_decomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_L_decomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tau</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_L_decomp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function factors the <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> regularization matrix
<a class="reference internal" href="#c.gsl_multifit_linear_L_decomp" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> into a form needed for the later transformation to standard form. <a class="reference internal" href="#c.gsl_multifit_linear_L_decomp" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a>
may have any number of rows <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>. If <img class="math" src="_images/math/bb6504b682fe562d5163328de253718ef192a0b9.png" alt="m \ge p"/> the QR decomposition of
<a class="reference internal" href="#c.gsl_multifit_linear_L_decomp" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> is computed and stored in <a class="reference internal" href="#c.gsl_multifit_linear_L_decomp" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> on output. If <img class="math" src="_images/math/362201b066e8e87e1fa8c3f7873914c3b6d5659f.png" alt="m &lt; p"/>, the QR decomposition
of <img class="math" src="_images/math/b1fcb8b1d40199ad30b23fab16715b718be66c70.png" alt="L^T"/> is computed and stored in <a class="reference internal" href="#c.gsl_multifit_linear_L_decomp" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> on output. On output,
the Householder scalars are stored in the vector <a class="reference internal" href="#c.gsl_multifit_linear_L_decomp" title="tau"><code class="xref c c-data docutils literal notranslate"><span class="pre">tau</span></code></a> of size <img class="math" src="_images/math/9a9346b788642654a83ef549d2c13ef04b07c9ec.png" alt="MIN(m,p)"/>.
These outputs will be used by <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="gsl_multifit_linear_wstdform2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_wstdform2()</span></code></a> to complete the
transformation to standard form.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_stdform2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_stdform2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">LQR</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Ltau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">M</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_stdform2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multifit_linear_wstdform2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_wstdform2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">LQR</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Ltau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">M</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_wstdform2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions convert the least squares system (<a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>, <code class="xref c c-data docutils literal notranslate"><span class="pre">W</span></code>, <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>) to standard
form (<img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>, <img class="math" src="_images/math/fb66b789ec86f2ea9b05b20a80f9485ef0dd4f55.png" alt="\tilde{y}"/>) which are stored in <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a>
respectively. The <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> regularization matrix <code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code> is specified by the inputs
<a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="LQR"><code class="xref c c-data docutils literal notranslate"><span class="pre">LQR</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="Ltau"><code class="xref c c-data docutils literal notranslate"><span class="pre">Ltau</span></code></a>, which are outputs from <a class="reference internal" href="#c.gsl_multifit_linear_L_decomp" title="gsl_multifit_linear_L_decomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_L_decomp()</span></code></a>.
The dimensions of the standard form parameters (<img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>, <img class="math" src="_images/math/fb66b789ec86f2ea9b05b20a80f9485ef0dd4f55.png" alt="\tilde{y}"/>)
depend on whether <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/> is larger or less than <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>. For <img class="math" src="_images/math/bb6504b682fe562d5163328de253718ef192a0b9.png" alt="m \ge p"/>,
<a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> is <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>, <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> is <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-1, and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="M"><code class="xref c c-data docutils literal notranslate"><span class="pre">M</span></code></a> is
not used. For <img class="math" src="_images/math/362201b066e8e87e1fa8c3f7873914c3b6d5659f.png" alt="m &lt; p"/>, <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> is <img class="math" src="_images/math/e5289e7753fdab6587fae17f4ad4c21b1e70bbdc.png" alt="(n - p + m)"/>-by-<img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>,
<a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> is <img class="math" src="_images/math/e5289e7753fdab6587fae17f4ad4c21b1e70bbdc.png" alt="(n - p + m)"/>-by-1, and <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="M"><code class="xref c c-data docutils literal notranslate"><span class="pre">M</span></code></a> is additional <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> workspace,
which is required to recover the original solution vector after the system has been
solved (see <a class="reference internal" href="#c.gsl_multifit_linear_genform2" title="gsl_multifit_linear_genform2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_genform2()</span></code></a>). Optional data weights may be supplied in the
vector <a class="reference internal" href="#c.gsl_multifit_linear_wstdform2" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a> of length <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>, where <img class="math" src="_images/math/b04dd2ceeeb4d3b4997d06afd068d326bf508861.png" alt="W = \diag(w)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_solve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_solve</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rnorm</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">snorm</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_solve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the regularized best-fit parameters <img class="math" src="_images/math/d595cf6fc55e8feab2b73cc1099ccdb6ec695d46.png" alt="\tilde{c}"/>
which minimize the cost function
<img class="math" src="_images/math/ccaeee44c84def052dd88f9224ffca0b565d5300.png" alt="\chi^2 = || \tilde{y} - \tilde{X} \tilde{c} ||^2 + \lambda^2 || \tilde{c} ||^2"/>
which is in standard form. The least squares system must therefore be converted
to standard form prior to calling this function.
The observation vector <img class="math" src="_images/math/fb66b789ec86f2ea9b05b20a80f9485ef0dd4f55.png" alt="\tilde{y}"/> is provided in <a class="reference internal" href="#c.gsl_multifit_linear_solve" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> and the matrix of
predictor variables <img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/> in <a class="reference internal" href="#c.gsl_multifit_linear_solve" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a>. The solution vector <img class="math" src="_images/math/d595cf6fc55e8feab2b73cc1099ccdb6ec695d46.png" alt="\tilde{c}"/> is
returned in <a class="reference internal" href="#c.gsl_multifit_linear_solve" title="cs"><code class="xref c c-data docutils literal notranslate"><span class="pre">cs</span></code></a>, which has length min(<img class="math" src="_images/math/b37e480a005be514bf9b641bb47d00547e60fea5.png" alt="m,p"/>). The SVD of <a class="reference internal" href="#c.gsl_multifit_linear_solve" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> must be computed prior
to calling this function, using <a class="reference internal" href="#c.gsl_multifit_linear_svd" title="gsl_multifit_linear_svd"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_svd()</span></code></a>.
The regularization parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> is provided in <a class="reference internal" href="#c.gsl_multifit_linear_solve" title="lambda"><code class="xref c c-data docutils literal notranslate"><span class="pre">lambda</span></code></a>.
The residual norm <img class="math" src="_images/math/99f55b06d730f0b868e26259155e5de951777757.png" alt="|| \tilde{y} - \tilde{X} \tilde{c} || = ||y - X c||_W"/>
is returned in <a class="reference internal" href="#c.gsl_multifit_linear_solve" title="rnorm"><code class="xref c c-data docutils literal notranslate"><span class="pre">rnorm</span></code></a>.
The solution norm <img class="math" src="_images/math/7d79675da0d1d7a76407f95c6f8ea2785d1a6351.png" alt="|| \tilde{c} || = ||L c||"/> is returned in
<a class="reference internal" href="#c.gsl_multifit_linear_solve" title="snorm"><code class="xref c c-data docutils literal notranslate"><span class="pre">snorm</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_genform1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_genform1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_genform1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>After a regularized system has been solved with
<img class="math" src="_images/math/9b034af2b5b38d62812c122df790dba7e16c1ee0.png" alt="L = \diag(\l_0,\l_1,...,\l_{p-1})"/>,
this function backtransforms the standard form solution vector <a class="reference internal" href="#c.gsl_multifit_linear_genform1" title="cs"><code class="xref c c-data docutils literal notranslate"><span class="pre">cs</span></code></a>
to recover the solution vector of the original problem <a class="reference internal" href="#c.gsl_multifit_linear_genform1" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a>. The
diagonal matrix elements <img class="math" src="_images/math/799fdcdc5a755a13e87ed5f26d03acd53305516f.png" alt="l_i"/> are provided in
the vector <a class="reference internal" href="#c.gsl_multifit_linear_genform1" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a>. It is allowed to have <a class="reference internal" href="#c.gsl_multifit_linear_genform1" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> = <a class="reference internal" href="#c.gsl_multifit_linear_genform1" title="cs"><code class="xref c c-data docutils literal notranslate"><span class="pre">cs</span></code></a> for an
in-place transform.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_genform2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_genform2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">LQR</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Ltau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">M</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_genform2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multifit_linear_wgenform2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_wgenform2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">LQR</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Ltau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">M</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_wgenform2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>After a regularized system has been solved with a general rectangular matrix <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>,
specified by (<a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="LQR"><code class="xref c c-data docutils literal notranslate"><span class="pre">LQR</span></code></a>, <a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="Ltau"><code class="xref c c-data docutils literal notranslate"><span class="pre">Ltau</span></code></a>), this function backtransforms the standard form solution <a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="cs"><code class="xref c c-data docutils literal notranslate"><span class="pre">cs</span></code></a>
to recover the solution vector of the original problem, which is stored in <a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a>,
of length <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>. The original least squares matrix and observation vector are provided in
<a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> respectively. <a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="M"><code class="xref c c-data docutils literal notranslate"><span class="pre">M</span></code></a> is the matrix computed by
<a class="reference internal" href="#c.gsl_multifit_linear_stdform2" title="gsl_multifit_linear_stdform2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_stdform2()</span></code></a>. For weighted fits, the weight vector
<a class="reference internal" href="#c.gsl_multifit_linear_wgenform2" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a> must also be supplied.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_applyW">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_applyW</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">WX</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Wy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_applyW" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For weighted least squares systems with <img class="math" src="_images/math/a1c0cd9abf11352165b5e8846ec6d28d89562741.png" alt="L = I"/>, this function may be used to
convert the system to standard form by applying the weight matrix <img class="math" src="_images/math/b04dd2ceeeb4d3b4997d06afd068d326bf508861.png" alt="W = \diag(w)"/>
to the least squares matrix <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and observation vector <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>. On output, <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="WX"><code class="xref c c-data docutils literal notranslate"><span class="pre">WX</span></code></a>
is equal to <img class="math" src="_images/math/0acee686a70c4f5ceaacd53b522b114fbf455889.png" alt="W^{1/2} X"/> and <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="Wy"><code class="xref c c-data docutils literal notranslate"><span class="pre">Wy</span></code></a> is equal to <img class="math" src="_images/math/5ccfdf1f8d5a9132aa8bd69f8fdc9eebf75db2c8.png" alt="W^{1/2} y"/>. It is allowed
for <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="WX"><code class="xref c c-data docutils literal notranslate"><span class="pre">WX</span></code></a> = <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="Wy"><code class="xref c c-data docutils literal notranslate"><span class="pre">Wy</span></code></a> = <a class="reference internal" href="#c.gsl_multifit_linear_applyW" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> for an in-place transform.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_lreg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_lreg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">smin</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">smax</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_lreg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes a set of possible regularization parameters for L-curve analysis
and stores them in the output vector <a class="reference internal" href="#c.gsl_multifit_linear_lreg" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a> of length <img class="math" src="_images/math/71e6c03676f7f43b827bdaf404bc29149f5d99d7.png" alt="k"/>, where <img class="math" src="_images/math/71e6c03676f7f43b827bdaf404bc29149f5d99d7.png" alt="k"/> is
the number of desired points on the L-curve. The regularization parameters are equally logarithmically
distributed between the provided values <a class="reference internal" href="#c.gsl_multifit_linear_lreg" title="smin"><code class="xref c c-data docutils literal notranslate"><span class="pre">smin</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_lreg" title="smax"><code class="xref c c-data docutils literal notranslate"><span class="pre">smax</span></code></a>, which typically correspond to
the minimum and maximum singular value of the least squares matrix in standard form.
The regularization parameters are calculated as,</p>
<div class="math">
<p><img src="_images/math/36b58803cb0a9ca3943b599716930a1b1de07579.png" alt="\lambda_i = S_{min} \left( \frac{S_{max}}{S_{min}} \right)^{\frac{i-1}{k-1}}, \quad i = 1, \dots, k"/></p>
</div></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_lcurve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_lcurve</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rho</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_lcurve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the L-curve for a least squares system
using the right hand side vector <a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and the SVD decomposition
of the least squares matrix <code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code>, which must be provided
to <a class="reference internal" href="#c.gsl_multifit_linear_svd" title="gsl_multifit_linear_svd"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_svd()</span></code></a> prior to
calling this function. The output vectors <a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a>,
<a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="rho"><code class="xref c c-data docutils literal notranslate"><span class="pre">rho</span></code></a>, and <a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a> must all be the same size, and will
contain the regularization parameters <img class="math" src="_images/math/bb25874f406594c2fab03b21c91e2678f1d52391.png" alt="\lambda_i"/>, residual norms
<img class="math" src="_images/math/91f5dc9d3074eec263bc403de9b35541248bcb81.png" alt="||y - X c_i||"/>, and solution norms <img class="math" src="_images/math/91e027cc6ac8b9369b0c078fbaf56ce22865866a.png" alt="|| L c_i ||"/>
which compose the L-curve, where <img class="math" src="_images/math/8f3ed3aa23232b84b9d4f7e1d0068c62e5869384.png" alt="c_i"/> is the regularized
solution vector corresponding to <img class="math" src="_images/math/bb25874f406594c2fab03b21c91e2678f1d52391.png" alt="\lambda_i"/>.
The user may determine the number of points on the L-curve by
adjusting the size of these input arrays. The regularization
parameters <img class="math" src="_images/math/bb25874f406594c2fab03b21c91e2678f1d52391.png" alt="\lambda_i"/> are estimated from the singular values
of <code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code>, and chosen to represent the most relevant portion of
the L-curve.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_lcurvature">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_lcurvature</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rho</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kappa</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_lcurvature" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the curvature of the L-curve
<img class="math" src="_images/math/0baff7aa1f0a75263942f88fe0978c0f03cba4c9.png" alt="(\log{\hat{\rho}(\lambda)}, \log{\hat{\eta}(\lambda)})"/>, where
<img class="math" src="_images/math/e84cd401d0194f91cb15eb7e196b70aae7a1d70f.png" alt="\hat{\rho}(\lambda) = \log{||y - X c_{\lambda}||}"/> and
<img class="math" src="_images/math/5a4e8f4c6d35c2a3f6579b253b334cc51d2bfe93.png" alt="\hat{\eta}(\lambda) = \log{|| L c_{\lambda} ||}"/>.
This function uses the right hand side vector <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>,
the vector of regularization parameters, <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a>,
vector of residual norms, <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="rho"><code class="xref c c-data docutils literal notranslate"><span class="pre">rho</span></code></a>, and vector of solution norms, <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a>.
The arrays <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a>, <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="rho"><code class="xref c c-data docutils literal notranslate"><span class="pre">rho</span></code></a>, and <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a> can be computed by
<a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="gsl_multifit_linear_lcurve"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_lcurve()</span></code></a>.  The curvature is defined as</p>
<div class="math">
<p><img src="_images/math/8dba10aac6837988e0fbed064f3b9624296ea966.png" alt="\kappa(\lambda) = \frac{\hat{\rho}' \hat{\eta}'' - \hat{\rho}'' \hat{\eta}'}{\left( (\hat{\rho}')^2 + (\hat{\eta}')^2 \right)^{\frac{3}{2}}}"/></p>
</div><p>The curvature values are stored in <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="kappa"><code class="xref c c-data docutils literal notranslate"><span class="pre">kappa</span></code></a> on output. The function
<a class="reference internal" href="#c.gsl_multifit_linear_svd" title="gsl_multifit_linear_svd"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_svd()</span></code></a> must be called on the least squares matrix
<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> prior to calling this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_lcurvature_menger">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_lcurvature_menger</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rho</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kappa</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_lcurvature_menger" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the Menger curvature of the L-curve
<img class="math" src="_images/math/0baff7aa1f0a75263942f88fe0978c0f03cba4c9.png" alt="(\log{\hat{\rho}(\lambda)}, \log{\hat{\eta}(\lambda)})"/>, where
<img class="math" src="_images/math/e84cd401d0194f91cb15eb7e196b70aae7a1d70f.png" alt="\hat{\rho}(\lambda) = \log{||y - X c_{\lambda}||}"/> and
<img class="math" src="_images/math/5a4e8f4c6d35c2a3f6579b253b334cc51d2bfe93.png" alt="\hat{\eta}(\lambda) = \log{|| L c_{\lambda} ||}"/>.
The function computes the Menger curvature for each consecutive triplet of points,
<img class="math" src="_images/math/02b8a369aa65fdcc2ce1f6ffb669ed9b582e9d69.png" alt="\kappa_i = 1/R_i"/>, where <img class="math" src="_images/math/b6f27d9481d2fae733a0a26d3be8a24925f040ce.png" alt="R_i"/> is the radius of the unique
circle fitted to the points
<img class="math" src="_images/math/c22618b4e7ebbf2df712adaf5650fea1248cd044.png" alt="(\hat{\rho}_{i-1}, \hat{\eta}_{i-1}), (\hat{\rho}_i, \hat{\eta}_i), (\hat{\rho}_{i+1}, \hat{\eta}_{i+1})"/>.</p>
<p>The vector of residual norms <img class="math" src="_images/math/f9f673b6b08ecb6a65fd6a71cd811dec43eb1f94.png" alt="|| y - X c_{\lambda} ||"/> is provided in <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature_menger" title="rho"><code class="xref c c-data docutils literal notranslate"><span class="pre">rho</span></code></a>,
the vector of solution norms <img class="math" src="_images/math/0787f9c1e7ebbf3ebf60d38de8a0c307b5bd3163.png" alt="|| L c_{\lambda} ||"/> is provided in <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature_menger" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a>.
These arrays can be calculated by calling <a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="gsl_multifit_linear_lcurve"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_lcurve()</span></code></a>.
The Menger curvature output is stored in <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature_menger" title="kappa"><code class="xref c c-data docutils literal notranslate"><span class="pre">kappa</span></code></a>. The Menger curvature is
an approximation to the curvature calculated by <a class="reference internal" href="#c.gsl_multifit_linear_lcurvature" title="gsl_multifit_linear_lcurvature"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_lcurvature()</span></code></a> but
may be faster to calculate.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_lcorner">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_lcorner</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rho</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">eta</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_lcorner" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function attempts to locate the corner of the L-curve
<img class="math" src="_images/math/8bd93116977e7119162fdaa83417a27bf4edc57e.png" alt="(||y - X c||, ||L c||)"/> defined by the <a class="reference internal" href="#c.gsl_multifit_linear_lcorner" title="rho"><code class="xref c c-data docutils literal notranslate"><span class="pre">rho</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_lcorner" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a>
input arrays respectively. The corner is defined as the point of maximum
curvature of the L-curve in log-log scale. The <a class="reference internal" href="#c.gsl_multifit_linear_lcorner" title="rho"><code class="xref c c-data docutils literal notranslate"><span class="pre">rho</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_lcorner" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a>
arrays can be outputs of <a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="gsl_multifit_linear_lcurve"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_lcurve()</span></code></a>. The
algorithm used simply fits a circle to 3 consecutive points on the L-curve
and uses the circle’s radius to determine the curvature at
the middle point. Therefore, the input array sizes must be
<img class="math" src="_images/math/c5d8230a817d75c87612a8312323db4d95687365.png" alt="\ge 3"/>. With more points provided for the L-curve, a better
estimate of the curvature can be obtained. The array index
corresponding to maximum curvature (ie: the corner) is returned
in <a class="reference internal" href="#c.gsl_multifit_linear_lcorner" title="idx"><code class="xref c c-data docutils literal notranslate"><span class="pre">idx</span></code></a>. If the input arrays contain colinear points,
this function could fail and return <a class="reference internal" href="err.html#c.GSL_EINVAL" title="GSL_EINVAL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EINVAL</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_lcorner2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_lcorner2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">eta</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_lcorner2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function attempts to locate the corner of an alternate L-curve
<img class="math" src="_images/math/b27c662efb542ff8c0b07c4762c8fcbf1ecc28d7.png" alt="(\lambda^2, ||L c||^2)"/> studied by Rezghi and Hosseini, 2009.
This alternate L-curve can provide better estimates of the
regularization parameter for smooth solution vectors. The regularization
parameters <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> and solution norms <img class="math" src="_images/math/4096020c4dcaa6e48790dd0d53081a7923320328.png" alt="||L c||"/> are provided
in the <a class="reference internal" href="#c.gsl_multifit_linear_lcorner2" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_lcorner2" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a> input arrays respectively. The
corner is defined as the point of maximum curvature of this
alternate L-curve in linear scale. The <a class="reference internal" href="#c.gsl_multifit_linear_lcorner2" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_lcorner2" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a>
arrays can be outputs of <a class="reference internal" href="#c.gsl_multifit_linear_lcurve" title="gsl_multifit_linear_lcurve"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_lcurve()</span></code></a>. The
algorithm used simply fits a circle to 3 consecutive points on the L-curve
and uses the circle’s radius to determine the curvature at
the middle point. Therefore, the input array sizes must be
<img class="math" src="_images/math/c5d8230a817d75c87612a8312323db4d95687365.png" alt="\ge 3"/>. With more points provided for the L-curve, a better
estimate of the curvature can be obtained. The array index
corresponding to maximum curvature (ie: the corner) is returned
in <a class="reference internal" href="#c.gsl_multifit_linear_lcorner2" title="idx"><code class="xref c c-data docutils literal notranslate"><span class="pre">idx</span></code></a>. If the input arrays contain colinear points,
this function could fail and return <a class="reference internal" href="err.html#c.GSL_EINVAL" title="GSL_EINVAL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EINVAL</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_gcv_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_gcv_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">UTy</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">delta0</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_gcv_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function performs some initialization in preparation for computing
the GCV curve and its minimum. The right hand side vector is provided
in <a class="reference internal" href="#c.gsl_multifit_linear_gcv_init" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>. On output, <a class="reference internal" href="#c.gsl_multifit_linear_gcv_init" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a> is set to a vector of regularization
parameters in decreasing order and may be of any size. The vector
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_init" title="UTy"><code class="xref c c-data docutils literal notranslate"><span class="pre">UTy</span></code></a> of size <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> is set to <img class="math" src="_images/math/1071b52b26a5752e3579c4da38d24ff505076f83.png" alt="U^T y"/>. The parameter
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_init" title="delta0"><code class="xref c c-data docutils literal notranslate"><span class="pre">delta0</span></code></a> is needed for subsequent steps of the GCV calculation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_gcv_curve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_gcv_curve</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">UTy</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta0</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">G</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_gcv_curve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This funtion calculates the GCV curve <img class="math" src="_images/math/8812773eb298326ecb560027b946f33e1fab53e7.png" alt="G(\lambda)"/> and stores it in
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_curve" title="G"><code class="xref c c-data docutils literal notranslate"><span class="pre">G</span></code></a> on output, which must be the same size as <a class="reference internal" href="#c.gsl_multifit_linear_gcv_curve" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a>. The
inputs <a class="reference internal" href="#c.gsl_multifit_linear_gcv_curve" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a>, <a class="reference internal" href="#c.gsl_multifit_linear_gcv_curve" title="UTy"><code class="xref c c-data docutils literal notranslate"><span class="pre">UTy</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_gcv_curve" title="delta0"><code class="xref c c-data docutils literal notranslate"><span class="pre">delta0</span></code></a> are computed in
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_init" title="gsl_multifit_linear_gcv_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_gcv_init()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_gcv_min">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_gcv_min</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">UTy</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">G</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta0</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_gcv_min" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the value of the regularization parameter
which minimizes the GCV curve <img class="math" src="_images/math/8812773eb298326ecb560027b946f33e1fab53e7.png" alt="G(\lambda)"/> and stores it in
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_min" title="lambda"><code class="xref c c-data docutils literal notranslate"><span class="pre">lambda</span></code></a>. The input <a class="reference internal" href="#c.gsl_multifit_linear_gcv_min" title="G"><code class="xref c c-data docutils literal notranslate"><span class="pre">G</span></code></a> is calculated by
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_curve" title="gsl_multifit_linear_gcv_curve"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_gcv_curve()</span></code></a> and the inputs
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_min" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a>, <a class="reference internal" href="#c.gsl_multifit_linear_gcv_min" title="UTy"><code class="xref c c-data docutils literal notranslate"><span class="pre">UTy</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_linear_gcv_min" title="delta0"><code class="xref c c-data docutils literal notranslate"><span class="pre">delta0</span></code></a> are computed by
<a class="reference internal" href="#c.gsl_multifit_linear_gcv_init" title="gsl_multifit_linear_gcv_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_gcv_init()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_gcv_calc">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_gcv_calc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">UTy</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta0</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_gcv_calc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the value of the GCV curve <img class="math" src="_images/math/8812773eb298326ecb560027b946f33e1fab53e7.png" alt="G(\lambda)"/> corresponding
to the input <a class="reference internal" href="#c.gsl_multifit_linear_gcv_calc" title="lambda"><code class="xref c c-data docutils literal notranslate"><span class="pre">lambda</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_gcv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_gcv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">G</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">G_lambda</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_gcv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function combines the steps <code class="code docutils literal notranslate"><span class="pre">gcv_init</span></code>, <code class="code docutils literal notranslate"><span class="pre">gcv_curve</span></code>,
and <code class="code docutils literal notranslate"><span class="pre">gcv_min</span></code> defined above into a single function. The input
<a class="reference internal" href="#c.gsl_multifit_linear_gcv" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> is the right hand side vector. On output, <a class="reference internal" href="#c.gsl_multifit_linear_gcv" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a> and
<a class="reference internal" href="#c.gsl_multifit_linear_gcv" title="G"><code class="xref c c-data docutils literal notranslate"><span class="pre">G</span></code></a>, which must be the same size, are set to vectors of
<img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> and <img class="math" src="_images/math/8812773eb298326ecb560027b946f33e1fab53e7.png" alt="G(\lambda)"/> values respectively. The
output <a class="reference internal" href="#c.gsl_multifit_linear_gcv" title="lambda"><code class="xref c c-data docutils literal notranslate"><span class="pre">lambda</span></code></a> is set to the optimal value of <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/>
which minimizes the GCV curve. The minimum value of the GCV curve is
returned in <a class="reference internal" href="#c.gsl_multifit_linear_gcv" title="G_lambda"><code class="xref c c-data docutils literal notranslate"><span class="pre">G_lambda</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_Lk">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_Lk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_Lk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the discrete approximation to the derivative operator <img class="math" src="_images/math/cfac37029605cd2b04874c5019beffc5bf30f347.png" alt="L_k"/> of
order <a class="reference internal" href="#c.gsl_multifit_linear_Lk" title="k"><code class="xref c c-data docutils literal notranslate"><span class="pre">k</span></code></a> on a regular grid of <a class="reference internal" href="#c.gsl_multifit_linear_Lk" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a> points and stores it in <a class="reference internal" href="#c.gsl_multifit_linear_Lk" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a>. The dimensions of <a class="reference internal" href="#c.gsl_multifit_linear_Lk" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> are
<img class="math" src="_images/math/7a960854d9c46767fffd67a711cdb02580eaceb4.png" alt="(p-k)"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_Lsobolev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_Lsobolev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">kmax</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">alpha</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_Lsobolev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the regularization matrix <a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> corresponding to the
weighted Sobolov norm
<img class="math" src="_images/math/3df926567b26c52d17a340e11ce2996477e265c0.png" alt="||L c||^2 = \sum_k \alpha_k^2 ||L_k c||^2"/> where <img class="math" src="_images/math/cfac37029605cd2b04874c5019beffc5bf30f347.png" alt="L_k"/> approximates
the derivative operator of order <img class="math" src="_images/math/71e6c03676f7f43b827bdaf404bc29149f5d99d7.png" alt="k"/>. This regularization norm can be useful
in applications where it is necessary to smooth several derivatives of the solution.
<a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a> is the number of model parameters, <a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="kmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">kmax</span></code></a> is the highest derivative
to include in the summation above, and <a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="alpha"><code class="xref c c-data docutils literal notranslate"><span class="pre">alpha</span></code></a> is the vector of weights of
size <a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="kmax"><code class="xref c c-data docutils literal notranslate"><span class="pre">kmax</span></code></a> + 1, where <code class="code docutils literal notranslate"><span class="pre">alpha[k]</span></code> = <img class="math" src="_images/math/3c9f2c4daf48275cbfb3a09d9eb35dc7ab5ff2d7.png" alt="\alpha_k"/> is the weight
assigned to the derivative of order <img class="math" src="_images/math/71e6c03676f7f43b827bdaf404bc29149f5d99d7.png" alt="k"/>.  The output matrix <a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> is size
<a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a>-by-<a class="reference internal" href="#c.gsl_multifit_linear_Lsobolev" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a> and upper triangular.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_linear_rcond">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_linear_rcond</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multifit_linear_workspace" title="gsl_multifit_linear_workspace"><span class="n"><span class="pre">gsl_multifit_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_linear_rcond" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the reciprocal condition number of the least squares matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>,
defined as the ratio of the smallest and largest singular values,
rcond = <img class="math" src="_images/math/a16d6372b1dd11479efc5cece627559f499c18a9.png" alt="\sigma_{min}/\sigma_{max}"/>.
The routine <a class="reference internal" href="#c.gsl_multifit_linear_svd" title="gsl_multifit_linear_svd"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_linear_svd()</span></code></a> must first be called to compute the SVD
of <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>.</p>
</dd></dl>

</div>
<div class="section" id="robust-linear-regression">
<span id="index-7"></span><h2>Robust linear regression<a class="headerlink" href="#robust-linear-regression" title="Permalink to this heading">¶</a></h2>
<p>Ordinary least squares (OLS) models are often heavily influenced by the presence of outliers.
Outliers are data points which do not follow the general trend of the other observations,
although there is strictly no precise definition of an outlier. Robust linear regression
refers to regression algorithms which are robust to outliers. The most common type of
robust regression is M-estimation. The general M-estimator minimizes the objective function</p>
<div class="math">
<p><img src="_images/math/98f45832eef1555a2e5681a3e99d362560d80656.png" alt="\sum_i \rho(e_i) = \sum_i \rho (y_i - Y(c, x_i))"/></p>
</div><p>where <img class="math" src="_images/math/febdc4a5220217f8f155b516e063a1d378593232.png" alt="e_i = y_i - Y(c, x_i)"/> is the residual of the ith data point, and
<img class="math" src="_images/math/a317a0262cf0141e04a67550d7ce43821df56a3f.png" alt="\rho(e_i)"/> is a function which should have the following properties:</p>
<ul class="simple">
<li><p><img class="math" src="_images/math/83bbf46bc9740a57f828bb47f9ba7fd81b3b8441.png" alt="\rho(e) \ge 0"/></p></li>
<li><p><img class="math" src="_images/math/a6e9281bafada312f1a7815a496e4c4c72fd6c2e.png" alt="\rho(0) = 0"/></p></li>
<li><p><img class="math" src="_images/math/c4ae55c169433d2622036a42ac274690690566fd.png" alt="\rho(-e) = \rho(e)"/></p></li>
<li><p><img class="math" src="_images/math/97d7d2cafa680787707b5e98e643a8c53ff160f9.png" alt="\rho(e_1) &gt; \rho(e_2)"/> for <img class="math" src="_images/math/1f218e2011d37bdd2fba6be81355ba0f60fe8df3.png" alt="|e_1| &gt; |e_2|"/></p></li>
</ul>
<p>The special case of ordinary least squares is given by <img class="math" src="_images/math/e527da936a60da9680320e2329503570099e7df4.png" alt="\rho(e_i) = e_i^2"/>.
Letting <img class="math" src="_images/math/fb418cca42f0fee65d4aafb34421fa2079f92b3e.png" alt="\psi = \rho'"/> be the derivative of <img class="math" src="_images/math/bade0603338b31a83ab671f1acda28b1341b57f4.png" alt="\rho"/>, differentiating
the objective function with respect to the coefficients <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>
and setting the partial derivatives to zero produces the system of equations</p>
<div class="math">
<p><img src="_images/math/a2d35899d8b213af0010a8f52c06d25c3abee416.png" alt="\sum_i \psi(e_i) X_i = 0"/></p>
</div><p>where <img class="math" src="_images/math/de92d570bb8cd7ac37485299512c8171b0425403.png" alt="X_i"/> is a vector containing row <img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/> of the design matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>.
Next, we define a weight function <img class="math" src="_images/math/295c0bf9091c014222cf4b6b3b39a665f3cbb29d.png" alt="w(e) = \psi(e)/e"/>, and let
<img class="math" src="_images/math/882145a80aa6cb4f888c4feca482f60d5d77f108.png" alt="w_i = w(e_i)"/>:</p>
<div class="math">
<p><img src="_images/math/d9e8d35dec6f3a83a47de26b8ac3380e31b70e0c.png" alt="\sum_i w_i e_i X_i = 0"/></p>
</div><p>This system of equations is equivalent to solving a weighted ordinary least squares
problem, minimizing <img class="math" src="_images/math/9faa5cb6e4de59c5c7917144d7139c5889cc7cbf.png" alt="\chi^2 = \sum_i w_i e_i^2"/>. The weights however, depend
on the residuals <img class="math" src="_images/math/b5c2c066fca7ca80e6d5e8944b32706039c544c5.png" alt="e_i"/>, which depend on the coefficients <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>, which depend
on the weights. Therefore, an iterative solution is used, called Iteratively Reweighted
Least Squares (IRLS).</p>
<ol class="arabic simple">
<li><p>Compute initial estimates of the coefficients <img class="math" src="_images/math/a49310b88c6ff865e483b68fecc66f095d7d8269.png" alt="c^{(0)}"/> using ordinary least squares</p></li>
<li><p>For iteration <img class="math" src="_images/math/71e6c03676f7f43b827bdaf404bc29149f5d99d7.png" alt="k"/>, form the residuals <img class="math" src="_images/math/c3f95eeea019f7bdfca27d777f6545b05a44407e.png" alt="e_i^{(k)} = (y_i - X_i c^{(k-1)})/(t \sigma^{(k)} \sqrt{1 - h_i})"/>,
where <img class="math" src="_images/math/6f8cfe577555c6a7a9baff60b7e8169ef9c203eb.png" alt="t"/> is a tuning constant depending on the choice of <img class="math" src="_images/math/46bcc3713a4764034c7b901e6230d4dcd4a02b0f.png" alt="\psi"/>, and <img class="math" src="_images/math/26de677dd88e228d732c6df2b4751f24e13cdc79.png" alt="h_i"/> are the
statistical leverages (diagonal elements of the matrix <img class="math" src="_images/math/d11fb1f4916eda5a74b4f6a68bf796b4ae7f564b.png" alt="X (X^T X)^{-1} X^T"/>). Including <img class="math" src="_images/math/6f8cfe577555c6a7a9baff60b7e8169ef9c203eb.png" alt="t"/>
and <img class="math" src="_images/math/26de677dd88e228d732c6df2b4751f24e13cdc79.png" alt="h_i"/> in the residual calculation has been shown to improve the convergence of the method.
The residual standard deviation is approximated as <img class="math" src="_images/math/668c6cd6c3e88ddf697797bcb1398a146a6a8f0f.png" alt="\sigma^{(k)} = MAD / 0.6745"/>, where MAD is the
Median-Absolute-Deviation of the <img class="math" src="_images/math/d90d7fab72f9c7a1d861e2d3316ab75279d29ca6.png" alt="n-p"/> largest residuals from the previous iteration.</p></li>
<li><p>Compute new weights <img class="math" src="_images/math/5cd49d8c3e5fd72a176e9d4ccf135ea929d4fa5c.png" alt="w_i^{(k)} = \psi(e_i^{(k)})/e_i^{(k)}"/>.</p></li>
<li><p>Compute new coefficients <img class="math" src="_images/math/37aacac5776a0827d3df0f8d084caf416f2412af.png" alt="c^{(k)}"/> by solving the weighted least squares problem with
weights <img class="math" src="_images/math/689661d1579dd3b9409c970c3edb3f7cd0e7d1ab.png" alt="w_i^{(k)}"/>.</p></li>
<li><p>Steps 2 through 4 are iterated until the coefficients converge or until some maximum iteration
limit is reached. Coefficients are tested for convergence using the critera:</p></li>
</ol>
<blockquote>
<div><div class="math">
<p><img src="_images/math/5cf04a8ca9f94bd288d725af19a1f63cb69cb3aa.png" alt="|c_i^{(k)} - c_i^{(k-1)}| \le \epsilon \times \hbox{max}(|c_i^{(k)}|, |c_i^{(k-1)}|)"/></p>
</div><p>for all <img class="math" src="_images/math/16a980faadc2f491bef8b01ca63f408908e47368.png" alt="0 \le i &lt; p"/> where <img class="math" src="_images/math/be3df5344ca00c17e18e2e38fde14b3415593780.png" alt="\epsilon"/> is a small tolerance factor.</p>
</div></blockquote>
<p>The key to this method lies in selecting the function <img class="math" src="_images/math/529a20230060b39d0b4c2b048c76c9b970c4b6f2.png" alt="\psi(e_i)"/> to assign
smaller weights to large residuals, and larger weights to smaller residuals. As
the iteration proceeds, outliers are assigned smaller and smaller weights, eventually
having very little or no effect on the fitted model.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_workspace">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_workspace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This workspace is used for robust least squares fitting.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc">
<a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">T</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function allocates a workspace for fitting a model to <a class="reference internal" href="#c.gsl_multifit_robust_alloc" title="n"><code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></a>
observations using <a class="reference internal" href="#c.gsl_multifit_robust_alloc" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a> parameters. The size of the workspace
is <img class="math" src="_images/math/c62e6562fa6037dd1aa9b7e1c574f434a511d1c2.png" alt="O(np + p^2)"/>. The type <a class="reference internal" href="#c.gsl_multifit_robust_alloc" title="T"><code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code></a> specifies the
function <img class="math" src="_images/math/46bcc3713a4764034c7b901e6230d4dcd4a02b0f.png" alt="\psi"/> and can be selected from the following choices.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_default">
<a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_default</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_default" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies the <a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_bisquare" title="gsl_multifit_robust_bisquare"><code class="xref c c-data docutils literal notranslate"><span class="pre">gsl_multifit_robust_bisquare</span></code></a> type (see below) and is a good
general purpose choice for robust regression.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_bisquare">
<a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_bisquare</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_bisquare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is Tukey’s biweight (bisquare) function and is a good general purpose choice for
robust regression. The weight function is given by</p>
<div class="math">
<p><img src="_images/math/f39000458c2310071bdb0798b8b4c89576a21581.png" alt="w(e) =
\left\{
  \begin{array}{cc}
    (1 - e^2)^2, &amp; |e| \le 1 \\
     0, &amp; |e| &gt; 1
  \end{array}
\right."/></p>
</div><p>and the default tuning constant is <img class="math" src="_images/math/4413df5498b88923281ee9bbae76fe56f4595fcf.png" alt="t = 4.685"/>.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_cauchy">
<a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_cauchy</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_cauchy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is Cauchy’s function, also known as the Lorentzian function.
This function does not guarantee a unique solution,
meaning different choices of the coefficient vector <code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code>
could minimize the objective function. Therefore this option should
be used with care. The weight function is given by</p>
<div class="math">
<p><img src="_images/math/507ae22b1d694d12f8f851e4b2d35d429d88eda3.png" alt="w(e) = {1 \over 1 + e^2}"/></p>
</div><p>and the default tuning constant is <img class="math" src="_images/math/99867095e02a85e28096b624b57e177e188ef011.png" alt="t = 2.385"/>.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_fair">
<a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_fair</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_fair" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is the fair <img class="math" src="_images/math/bade0603338b31a83ab671f1acda28b1341b57f4.png" alt="\rho"/> function, which guarantees a unique solution and
has continuous derivatives to three orders. The weight function is given by</p>
<div class="math">
<p><img src="_images/math/23918ff0408fda0ae885da1337c75def321c6ab5.png" alt="w(e) = {1 \over 1 + |e|}"/></p>
</div><p>and the default tuning constant is <img class="math" src="_images/math/91a81c1b86264c1be2677dcdc5d4eda4221041e0.png" alt="t = 1.400"/>.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_huber">
<a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_huber</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_huber" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies Huber’s <img class="math" src="_images/math/bade0603338b31a83ab671f1acda28b1341b57f4.png" alt="\rho"/> function, which is a parabola in the vicinity of zero and
increases linearly for a given threshold <img class="math" src="_images/math/12ecb011c918477bf2bdf264f5aa291abf394869.png" alt="|e| &gt; t"/>. This function is also considered
an excellent general purpose robust estimator, however, occasional difficulties can
be encountered due to the discontinuous first derivative of the <img class="math" src="_images/math/46bcc3713a4764034c7b901e6230d4dcd4a02b0f.png" alt="\psi"/> function.
The weight function is given by</p>
<div class="math">
<p><img src="_images/math/f0758df90d1c631d2beed7fc28d31916d7608fa3.png" alt="w(e) =
\left\{
  \begin{array}{cc}
    1, &amp; |e| \le 1 \\
    {1 \over |e|}, &amp; |e| &gt; 1
  \end{array}
\right."/></p>
</div><p>and the default tuning constant is <img class="math" src="_images/math/beb96e728c6de6ea91688e6101134ac3b86c45f1.png" alt="t = 1.345"/>.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_ols">
<a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_ols</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_ols" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies the ordinary least squares solution, which can be useful for quickly
checking the difference between the various robust and OLS solutions. The
weight function is given by</p>
<div class="math">
<p><img src="_images/math/c1323060d44b0915047cd134cdd0b5ea97c96b0f.png" alt="w(e) = 1"/></p>
</div><p>and the default tuning constant is <img class="math" src="_images/math/e726098650cf8dea09f9d5e98de1aded50811c69.png" alt="t = 1"/>.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_welsch">
<a class="reference internal" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type" title="gsl_multifit_robust_type"><span class="n"><span class="pre">gsl_multifit_robust_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_welsch</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_alloc.gsl_multifit_robust_type.gsl_multifit_robust_welsch" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies the Welsch function which can perform well in cases where the
residuals have an exponential distribution. The weight function is given by</p>
<div class="math">
<p><img src="_images/math/076c43b07c0b8fc7f1a959cc506a29ec2dd211bc.png" alt="w(e) = \exp{(-e^2)}"/></p>
</div><p>and the default tuning constant is <img class="math" src="_images/math/c3ae59dd4991a57afbe4a23161b4b9e71e19ba51.png" alt="t = 2.985"/>.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function frees the memory associated with the workspace <a class="reference internal" href="#c.gsl_multifit_robust_free" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the name of the robust type <code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code> specified to
<a class="reference internal" href="#c.gsl_multifit_robust_alloc" title="gsl_multifit_robust_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_robust_alloc()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_tune">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_tune</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">tune</span></span>, <a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_tune" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function sets the tuning constant <img class="math" src="_images/math/6f8cfe577555c6a7a9baff60b7e8169ef9c203eb.png" alt="t"/> used to adjust the residuals at each
iteration to <a class="reference internal" href="#c.gsl_multifit_robust_tune" title="tune"><code class="xref c c-data docutils literal notranslate"><span class="pre">tune</span></code></a>.  Decreasing the tuning constant increases the downweight
assigned to large residuals, while increasing the tuning constant decreases the
downweight assigned to large residuals.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_maxiter">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_maxiter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">maxiter</span></span>, <a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_maxiter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function sets the maximum number of iterations in the iteratively
reweighted least squares algorithm to <a class="reference internal" href="#c.gsl_multifit_robust_maxiter" title="maxiter"><code class="xref c c-data docutils literal notranslate"><span class="pre">maxiter</span></code></a>. By default,
this value is set to 100 by <a class="reference internal" href="#c.gsl_multifit_robust_alloc" title="gsl_multifit_robust_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_robust_alloc()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_weights">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_weights</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wts</span></span>, <a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_weights" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function assigns weights to the vector <a class="reference internal" href="#c.gsl_multifit_robust_weights" title="wts"><code class="xref c c-data docutils literal notranslate"><span class="pre">wts</span></code></a> using the residual vector
<a class="reference internal" href="#c.gsl_multifit_robust_weights" title="r"><code class="xref c c-data docutils literal notranslate"><span class="pre">r</span></code></a> and previously specified weighting function. The output weights are given
by <img class="math" src="_images/math/8cb3f62ecc8cc2a3c165b051f1f59b7c5b4a50e3.png" alt="wts_i = w(r_i / (t \sigma))"/>, where the weighting functions <img class="math" src="_images/math/1df53cea3e680fa96972fb44268b919a256cc4b7.png" alt="w"/> are
detailed in <a class="reference internal" href="#c.gsl_multifit_robust_alloc" title="gsl_multifit_robust_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_robust_alloc()</span></code></a>. <img class="math" src="_images/math/0b7620936fd7a90e5dde43c07609be992245871a.png" alt="\sigma"/> is an estimate of the
residual standard deviation based on the Median-Absolute-Deviation and <img class="math" src="_images/math/6f8cfe577555c6a7a9baff60b7e8169ef9c203eb.png" alt="t"/>
is the tuning constant. This function is useful if the user wishes to implement
their own robust regression rather than using
the supplied <a class="reference internal" href="#c.gsl_multifit_robust" title="gsl_multifit_robust"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_robust()</span></code></a> routine below.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov</span></span>, <a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the best-fit parameters <a class="reference internal" href="#c.gsl_multifit_robust" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> of the model
<img class="math" src="_images/math/99cbc107343e7510de0a1bf2df0cc5ffb55518f5.png" alt="y = X c"/> for the observations <a class="reference internal" href="#c.gsl_multifit_robust" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and the matrix of
predictor variables <a class="reference internal" href="#c.gsl_multifit_robust" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, attemping to reduce the influence
of outliers using the algorithm outlined above.
The <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> variance-covariance matrix of the model parameters
<a class="reference internal" href="#c.gsl_multifit_robust" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> is estimated as <img class="math" src="_images/math/1fa39602bd12370391bcd2710922b2d41a48cf37.png" alt="\sigma^2 (X^T X)^{-1}"/>, where <img class="math" src="_images/math/0b7620936fd7a90e5dde43c07609be992245871a.png" alt="\sigma"/> is
an approximation of the residual standard deviation using the theory of robust
regression. Special care must be taken when estimating <img class="math" src="_images/math/0b7620936fd7a90e5dde43c07609be992245871a.png" alt="\sigma"/> and
other statistics such as <img class="math" src="_images/math/c9aafc49551d1e3663fa14ea35217f5f8760c6be.png" alt="R^2"/>, and so these
are computed internally and are available by calling the function
<a class="reference internal" href="#c.gsl_multifit_robust_statistics" title="gsl_multifit_robust_statistics"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_robust_statistics()</span></code></a>.</p>
<p>If the coefficients do not converge within the maximum iteration
limit, the function returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">GSL_EMAXITER</span></code>. In this case,
the current estimates of the coefficients and covariance matrix
are returned in <a class="reference internal" href="#c.gsl_multifit_robust" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> and <a class="reference internal" href="#c.gsl_multifit_robust" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> and the internal fit statistics
are computed with these estimates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_est">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_est</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cov</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y_err</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_est" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function uses the best-fit robust regression coefficients
<a class="reference internal" href="#c.gsl_multifit_robust_est" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> and their covariance matrix
<a class="reference internal" href="#c.gsl_multifit_robust_est" title="cov"><code class="xref c c-data docutils literal notranslate"><span class="pre">cov</span></code></a> to compute the fitted function value
<a class="reference internal" href="#c.gsl_multifit_robust_est" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> and its standard deviation <a class="reference internal" href="#c.gsl_multifit_robust_est" title="y_err"><code class="xref c c-data docutils literal notranslate"><span class="pre">y_err</span></code></a> for the model <img class="math" src="_images/math/41e045ef9d9a4cfe2c7f39d188c9c7835781a398.png" alt="y = x \cdot c"/>
at the point <a class="reference internal" href="#c.gsl_multifit_robust_est" title="x"><code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_residuals">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_residuals</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_residuals" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the vector of studentized residuals
<img class="math" src="_images/math/78829b3aed215ede6ed84103befdadd34561147d.png" alt="r_i = {y_i - (X c)_i \over \sigma \sqrt{1 - h_i}}"/> for
the observations <a class="reference internal" href="#c.gsl_multifit_robust_residuals" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>, coefficients <a class="reference internal" href="#c.gsl_multifit_robust_residuals" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> and matrix of predictor
variables <a class="reference internal" href="#c.gsl_multifit_robust_residuals" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>. The routine <a class="reference internal" href="#c.gsl_multifit_robust" title="gsl_multifit_robust"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_robust()</span></code></a> must
first be called to compute the statisical leverages <img class="math" src="_images/math/26de677dd88e228d732c6df2b4751f24e13cdc79.png" alt="h_i"/> of
the matrix <a class="reference internal" href="#c.gsl_multifit_robust_residuals" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and residual standard deviation estimate <img class="math" src="_images/math/0b7620936fd7a90e5dde43c07609be992245871a.png" alt="\sigma"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_statistics">
<a class="reference internal" href="#c.gsl_multifit_robust_statistics.gsl_multifit_robust_stats" title="gsl_multifit_robust_stats"><span class="n"><span class="pre">gsl_multifit_robust_stats</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_statistics</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multifit_robust_workspace" title="gsl_multifit_robust_workspace"><span class="n"><span class="pre">gsl_multifit_robust_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multifit_robust_statistics" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a structure containing relevant statistics from a robust regression.
The function <a class="reference internal" href="#c.gsl_multifit_robust" title="gsl_multifit_robust"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_robust()</span></code></a> must be called first to perform the regression and
calculate these statistics.  The returned <a class="reference internal" href="#c.gsl_multifit_robust_statistics.gsl_multifit_robust_stats" title="gsl_multifit_robust_stats"><code class="xref c c-type docutils literal notranslate"><span class="pre">gsl_multifit_robust_stats</span></code></a> structure
contains the following fields.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multifit_robust_statistics.gsl_multifit_robust_stats">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multifit_robust_stats</span></span></span><a class="headerlink" href="#c.gsl_multifit_robust_statistics.gsl_multifit_robust_stats" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">sigma_ols</span></code></p>
<blockquote>
<div><p>This contains the standard deviation of the residuals as computed from ordinary
least squares (OLS).</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">sigma_mad</span></code></p>
<blockquote>
<div><p>This contains an estimate of the standard deviation of the final residuals using
the Median-Absolute-Deviation statistic</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">sigma_rob</span></code></p>
<blockquote>
<div><p>This contains an estimate of the standard deviation of the final residuals
from the theory of robust regression (see Street et al, 1988).</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">sigma</span></code></p>
<blockquote>
<div><p>This contains an estimate of the standard deviation of the final residuals
by attemping to reconcile <code class="code docutils literal notranslate"><span class="pre">sigma_rob</span></code> and <code class="code docutils literal notranslate"><span class="pre">sigma_ols</span></code>
in a reasonable way.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">Rsq</span></code></p>
<blockquote>
<div><p>This contains the <img class="math" src="_images/math/c9aafc49551d1e3663fa14ea35217f5f8760c6be.png" alt="R^2"/> coefficient of determination statistic using
the estimate <code class="code docutils literal notranslate"><span class="pre">sigma</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">adj_Rsq</span></code></p>
<blockquote>
<div><p>This contains the adjusted <img class="math" src="_images/math/c9aafc49551d1e3663fa14ea35217f5f8760c6be.png" alt="R^2"/> coefficient of determination statistic
using the estimate <code class="code docutils literal notranslate"><span class="pre">sigma</span></code>.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">rmse</span></code></p>
<blockquote>
<div><p>This contains the root mean squared error of the final residuals</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">sse</span></code></p>
<blockquote>
<div><p>This contains the residual sum of squares taking into account the robust
covariance matrix.</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dof</span></code></p>
<blockquote>
<div><p>This contains the number of degrees of freedom <img class="math" src="_images/math/0fe9722aa30c97f4946a98dca2a1030c412638eb.png" alt="n - p"/></p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">numit</span></code></p>
<blockquote>
<div><p>Upon successful convergence, this contains the number of iterations performed</p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">weights</span></code></p>
<blockquote>
<div><p>This contains the final weight vector of length <code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code></p>
</div></blockquote>
<p><code class="code docutils literal notranslate"><span class="pre">gsl_vector</span> <span class="pre">*</span> <span class="pre">r</span></code></p>
<blockquote>
<div><p>This contains the final residual vector of length <code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code>, <img class="math" src="_images/math/337af926c0a6897677095257998619bb210f66f0.png" alt="r = y - X c"/></p>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="large-dense-linear-systems">
<span id="index-8"></span><h2>Large dense linear systems<a class="headerlink" href="#large-dense-linear-systems" title="Permalink to this heading">¶</a></h2>
<p>This module is concerned with solving large dense least squares systems
<img class="math" src="_images/math/a1ec2bab0c0e39fb28fbab2fbb2436ce067232fa.png" alt="X c = y"/> where the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> matrix
<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> has <img class="math" src="_images/math/d935c10c806c96be90f4934ecedadb687a564890.png" alt="n &gt;&gt; p"/> (ie: many more rows than columns).
This type of matrix is called a “tall skinny” matrix, and for
some applications, it may not be possible to fit the
entire matrix in memory at once to use the standard SVD approach.
Therefore, the algorithms in this module are designed to allow
the user to construct smaller blocks of the matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> and
accumulate those blocks into the larger system one at a time. The
algorithms in this module never need to store the entire matrix
<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> in memory. The large linear least squares routines
support data weights and Tikhonov regularization, and are
designed to minimize the residual</p>
<div class="math">
<p><img src="_images/math/c4a1da929344f61da379b7b9e1a4868b3d3237f1.png" alt="\chi^2 = || y - Xc ||_W^2 + \lambda^2 || L c ||^2"/></p>
</div><p>where <img class="math" src="_images/math/e5b4bb56c8a593a62ae474d2b008601486633c57.png" alt="y"/> is the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> observation vector,
<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is the <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> design matrix, <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/> is
the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/083794f6b6375b92a331ddd53c8cc62a3a0a2a6d.png" alt="1"/> solution vector,
<img class="math" src="_images/math/80a48286f7653341c11da72e4739a79fd43b19ff.png" alt="W = \diag(w_1,...,w_n)"/> is the data weighting matrix,
<img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/> is an <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> regularization matrix,
<img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> is a regularization parameter,
and <img class="math" src="_images/math/90318343df24eb2dbc5fc98eab73e2224f98db1e.png" alt="||r||_W^2 = r^T W r"/>. In the discussion which follows,
we will assume that the system has been converted into Tikhonov
standard form,</p>
<div class="math">
<p><img src="_images/math/6869e58f32e10de3235ac54bd0977fff503855d4.png" alt="\chi^2 = || \tilde{y} - \tilde{X} \tilde{c} ||^2 + \lambda^2 || \tilde{c} ||^2"/></p>
</div><p>and we will drop the tilde characters from the various parameters.
For a discussion of the transformation to standard form,
see <a class="reference internal" href="#sec-regularized-regression"><span class="std std-ref">Regularized regression</span></a>.</p>
<p>The basic idea is to partition the matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> and observation
vector <img class="math" src="_images/math/e5b4bb56c8a593a62ae474d2b008601486633c57.png" alt="y"/> as</p>
<div class="math">
<p><img src="_images/math/8e7ce06ba6822138683ec6291db741f48c72f0c8.png" alt="\left(
  \begin{array}{c}
    X_1 \\
    X_2 \\
    X_3 \\
    \vdots \\
    X_k
  \end{array}
\right)
c =
\left(
  \begin{array}{c}
    y_1 \\
    y_2 \\
    y_3 \\
    \vdots \\
    y_k
  \end{array}
\right)"/></p>
</div><p>into <img class="math" src="_images/math/71e6c03676f7f43b827bdaf404bc29149f5d99d7.png" alt="k"/> blocks, where each block (<img class="math" src="_images/math/7127c43b2185f054eed2664d21deee167b9fcb7a.png" alt="X_i,y_i"/>) may have
any number of rows, but each <img class="math" src="_images/math/de92d570bb8cd7ac37485299512c8171b0425403.png" alt="X_i"/> has <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> columns.
The sections below describe the methods available for solving
this partitioned system. The functions are declared in
the header file <code class="file docutils literal notranslate"><span class="pre">gsl_multilarge.h</span></code>.</p>
<div class="section" id="normal-equations-approach">
<span id="index-9"></span><h3>Normal Equations Approach<a class="headerlink" href="#normal-equations-approach" title="Permalink to this heading">¶</a></h3>
<p>The normal equations approach to the large linear least squares
problem described above is popular due to its speed and simplicity.
Since the normal equations solution to the problem is given by</p>
<div class="math">
<p><img src="_images/math/ea964b3b92f5c197af38d4c34414c012d50812ca.png" alt="c = \left( X^T X + \lambda^2 I \right)^{-1} X^T y"/></p>
</div><p>only the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> matrix <img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/> and
<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-1 vector <img class="math" src="_images/math/1701f4408fc6370638f94abc4229b5e913592962.png" alt="X^T y"/> need to be stored. Using
the partition scheme described above, these are given by</p>
<div class="math">
<p><img src="_images/math/f926750c88cf13aedfc8f56455a9555020be6f6d.png" alt="X^T X &amp;= \sum_i X_i^T X_i \\
X^T y &amp;= \sum_i X_i^T y_i"/></p>
</div><p>Since the matrix <img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/> is symmetric, only half of it
needs to be calculated. Once all of the blocks <img class="math" src="_images/math/066fc5892e461b4e533013009d350f86cf887dcb.png" alt="(X_i,y_i)"/>
have been accumulated into the final <img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/> and <img class="math" src="_images/math/1701f4408fc6370638f94abc4229b5e913592962.png" alt="X^T y"/>,
the system can be solved with a Cholesky factorization of the
<img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/> matrix. The <img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/> matrix is first transformed via
a diagonal scaling transformation to attempt to reduce its condition
number as much as possible to recover a more accurate solution vector.
The normal equations approach is the fastest method for solving the
large least squares problem, and is accurate for well-conditioned
matrices <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>. However, for ill-conditioned matrices, as is often
the case for large systems, this method can suffer from numerical
instabilities (see Trefethen and Bau, 1997).  The number of operations
for this method is <img class="math" src="_images/math/c63ef4b0508ce7498e051876636bee9bf9a146e4.png" alt="O(np^2 + {1 \over 3}p^3)"/>.</p>
</div>
<div class="section" id="tall-skinny-qr-tsqr-approach">
<span id="index-10"></span><h3>Tall Skinny QR (TSQR) Approach<a class="headerlink" href="#tall-skinny-qr-tsqr-approach" title="Permalink to this heading">¶</a></h3>
<p>An algorithm which has better numerical stability for ill-conditioned
problems is known as the Tall Skinny QR (TSQR) method. This method
is based on computing the QR decomposition of the least squares
matrix,</p>
<div class="math">
<p><img src="_images/math/267c5deac7f7ff16bc0f7cdbe0cf3f1ad79fe6ba.png" alt="X = Q \begin{pmatrix} R \\ 0 \end{pmatrix}"/></p>
</div><p>where <img class="math" src="_images/math/e103d281ada9f45ddb73d266667a18adc3e50536.png" alt="Q"/> is an <img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/>-by-<img class="math" src="_images/math/f43dc929f43b9ea0d06d0c87855b9e50ee4479ea.png" alt="n"/> orthogonal matrix,
and <img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> is a <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> upper triangular matrix.
If we define,</p>
<div class="math">
<p><img src="_images/math/6aef80c1ea80e3376d0182b48acecfbf894f5fed.png" alt="z = Q^T y = \begin{pmatrix} z_1 \\ z_2 \end{pmatrix}"/></p>
</div><p>where <img class="math" src="_images/math/43d0ebf4def2d4c797d9e525967170b5275ebbb2.png" alt="z_1"/> is <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-1 and <img class="math" src="_images/math/be39ab47829937caa999e3a1959043f478620d56.png" alt="z_2"/> is <img class="math" src="_images/math/3d57422819340c9c5aaeb63f538c2c73c4a5e1d7.png" alt="(n-p)"/>-by-1,
then the residual becomes</p>
<div class="math">
<p><img src="_images/math/23be2ab88ece47c139e442458b7f44a5672b5815.png" alt="\chi^2 &amp;= \left|\left| y - X c \right|\right|^2 + \lambda^2 ||c||^2 \\
       &amp;= \left|\left| Q^T y - \begin{pmatrix} R \\ 0 \end{pmatrix} c \right|\right|^2 + \lambda^2 || c ||^2 \\
       &amp;= \left|\left| \begin{pmatrix} z_1 \\ z_2 \end{pmatrix} - \begin{pmatrix} R \\ 0 \end{pmatrix} c \right|\right|^2 + \lambda^2 || c ||^2 \\
       &amp;= \left|\left| z_1 - R c \right|\right|^2 + || z_2 ||^2 + \lambda^2 || c ||^2 \\
       &amp;= \left|\left| \begin{pmatrix} z_1 \\ 0 \end{pmatrix} - \begin{pmatrix} R \\ \lambda I_p \end{pmatrix} c \right|\right|^2 + || z_2 ||^2"/></p>
</div><p>Since <img class="math" src="_images/math/be39ab47829937caa999e3a1959043f478620d56.png" alt="z_2"/> does not depend on <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>, <img class="math" src="_images/math/01819910bb5ba61b86a3f7905f11513051954f42.png" alt="\chi^2"/> is minimized
by solving the least squares system,</p>
<div class="math">
<p><img src="_images/math/d66c95a0251c7bb4e6fa6f2d22fa0df1b56e0d45.png" alt="\left(
  \begin{array}{c}
    R \\
    \lambda I_p
  \end{array}
\right) c =
\left(
  \begin{array}{c}
    z_1 \\
    0
  \end{array}
\right)"/></p>
</div><p>The matrix on the left hand side is now a much
smaller <img class="math" src="_images/math/ccc9ffb956e3a8e4c7abf30709cae9613ad6b47b.png" alt="2p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> matrix which can
be solved with a standard SVD approach. The
<img class="math" src="_images/math/e103d281ada9f45ddb73d266667a18adc3e50536.png" alt="Q"/> matrix is large, however it does not need to be
explicitly constructed. The TSQR algorithm
computes only the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> matrix
<img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/>, the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-1 vector <img class="math" src="_images/math/43d0ebf4def2d4c797d9e525967170b5275ebbb2.png" alt="z_1"/>,
and the norm <img class="math" src="_images/math/4cfdc991772b52c1fe00a56fa7e1abece6b551ed.png" alt="||z_2||"/>,
and updates these quantities as new blocks
are added to the system. Each time a new block of rows
(<img class="math" src="_images/math/7127c43b2185f054eed2664d21deee167b9fcb7a.png" alt="X_i,y_i"/>) is added, the algorithm performs a QR decomposition
of the matrix</p>
<div class="math">
<p><img src="_images/math/b0d16ff93d7deed1f20e9bf6b296857b3b62c0a8.png" alt="\left(
  \begin{array}{c}
    R_{i-1} \\
    X_i
  \end{array}
\right)"/></p>
</div><p>where <img class="math" src="_images/math/0e01145918b5e5d169d17a26f5bdb9a05b3e4dca.png" alt="R_{i-1}"/> is the upper triangular
<img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> factor for the matrix</p>
<div class="math">
<p><img src="_images/math/0813df582865735082e0ffa05d98989674321e5b.png" alt="\left(
  \begin{array}{c}
    X_1 \\
    \vdots \\
    X_{i-1}
  \end{array}
\right)"/></p>
</div><p>This QR decomposition is done efficiently taking into account
the sparse structure of <img class="math" src="_images/math/0e01145918b5e5d169d17a26f5bdb9a05b3e4dca.png" alt="R_{i-1}"/>. See Demmel et al, 2008 for
more details on how this is accomplished. The number
of operations for this method is <img class="math" src="_images/math/434469335fdc27dc42ab0aec4a1b54c2e31c909c.png" alt="O(2np^2 - {2 \over 3}p^3)"/>.</p>
</div>
<div class="section" id="large-dense-linear-systems-solution-steps">
<span id="index-11"></span><h3>Large Dense Linear Systems Solution Steps<a class="headerlink" href="#large-dense-linear-systems-solution-steps" title="Permalink to this heading">¶</a></h3>
<p>The typical steps required to solve large regularized linear least
squares problems are as follows:</p>
<ol class="arabic simple">
<li><p>Choose the regularization matrix <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>.</p></li>
<li><p>Construct a block of rows of the least squares matrix, right
hand side vector, and weight vector (<img class="math" src="_images/math/de92d570bb8cd7ac37485299512c8171b0425403.png" alt="X_i"/>, <img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/>, <img class="math" src="_images/math/ece130da0e1e9c9e66b0053903b5cffae6299256.png" alt="w_i"/>).</p></li>
<li><p>Transform the block to standard form (<img class="math" src="_images/math/c14270824c36566011602b52f1ae15a16b5ed843.png" alt="\tilde{X_i}"/>, <img class="math" src="_images/math/9e29638b55b75bdf305873a5fa4f42b77d483c29.png" alt="\tilde{y_i}"/>). This
step can be skipped if <img class="math" src="_images/math/a1c0cd9abf11352165b5e8846ec6d28d89562741.png" alt="L = I"/> and <img class="math" src="_images/math/e37a23b6281e5453f4d3ed42c3deb0b047c37766.png" alt="W = I"/>.</p></li>
<li><p>Accumulate the standard form block (<img class="math" src="_images/math/c14270824c36566011602b52f1ae15a16b5ed843.png" alt="\tilde{X_i}"/>, <img class="math" src="_images/math/9e29638b55b75bdf305873a5fa4f42b77d483c29.png" alt="\tilde{y_i}"/>) into
the system.</p></li>
<li><p>Repeat steps 2-4 until the entire matrix and right hand side vector have
been accumulated.</p></li>
<li><p>Determine an appropriate regularization parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> (using for example
L-curve analysis).</p></li>
<li><p>Solve the standard form system using the chosen <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/>.</p></li>
<li><p>Backtransform the standard form solution <img class="math" src="_images/math/d595cf6fc55e8feab2b73cc1099ccdb6ec695d46.png" alt="\tilde{c}"/> to recover the
original solution vector <img class="math" src="_images/math/9d8e96031ca3d760ae8d01f085c4b4b7d82d382e.png" alt="c"/>.</p></li>
</ol>
</div>
<div class="section" id="large-dense-linear-least-squares-routines">
<span id="index-12"></span><h3>Large Dense Linear Least Squares Routines<a class="headerlink" href="#large-dense-linear-least-squares-routines" title="Permalink to this heading">¶</a></h3>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_workspace">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></span><a class="headerlink" href="#c.gsl_multilarge_linear_workspace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This workspace contains parameters for solving large linear least squares problems.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_alloc">
<a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type" title="gsl_multilarge_linear_type"><span class="n"><span class="pre">gsl_multilarge_linear_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">T</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function allocates a workspace for solving large linear least squares
systems. The least squares matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> has <a class="reference internal" href="#c.gsl_multilarge_linear_alloc" title="p"><code class="xref c c-data docutils literal notranslate"><span class="pre">p</span></code></a> columns,
but may have any number of rows.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_type</span></span></span><a class="headerlink" href="#c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The parameter <a class="reference internal" href="#c.gsl_multilarge_linear_alloc" title="T"><code class="xref c c-data docutils literal notranslate"><span class="pre">T</span></code></a> specifies
the method to be used for solving the large least squares system
and may be selected from the following choices</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type.gsl_multilarge_linear_normal">
<a class="reference internal" href="#c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type" title="gsl_multilarge_linear_type"><span class="n"><span class="pre">gsl_multilarge_linear_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_normal</span></span></span><a class="headerlink" href="#c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type.gsl_multilarge_linear_normal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies the normal equations approach for
solving the least squares system. This method is suitable
in cases where performance is critical and it is known that the
least squares matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is well conditioned. The size
of this workspace is <img class="math" src="_images/math/5cb735e059063137fb61199b773a6aad24f33a01.png" alt="O(p^2)"/>.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type.gsl_multilarge_linear_tsqr">
<a class="reference internal" href="#c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type" title="gsl_multilarge_linear_type"><span class="n"><span class="pre">gsl_multilarge_linear_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_tsqr</span></span></span><a class="headerlink" href="#c.gsl_multilarge_linear_alloc.gsl_multilarge_linear_type.gsl_multilarge_linear_tsqr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This specifies the sequential Tall Skinny QR (TSQR) approach for
solving the least squares system. This method is a good
general purpose choice for large systems, but requires about
twice as many operations as the normal equations method for
<img class="math" src="_images/math/d935c10c806c96be90f4934ecedadb687a564890.png" alt="n &gt;&gt; p"/>. The size of this workspace is <img class="math" src="_images/math/5cb735e059063137fb61199b773a6aad24f33a01.png" alt="O(p^2)"/>.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function frees the memory associated with the
workspace <a class="reference internal" href="#c.gsl_multilarge_linear_free" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_name</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns a string pointer to the name
of the multilarge solver.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_reset">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_reset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function resets the workspace <a class="reference internal" href="#c.gsl_multilarge_linear_reset" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a> so
it can begin to accumulate a new least squares
system.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_stdform1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_stdform1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_stdform1" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_wstdform1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_wstdform1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_wstdform1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions define a regularization matrix
<img class="math" src="_images/math/c04aeaa2e316655ead39b01d5d1b62af409679c8.png" alt="L = \diag(l_0,l_1,...,l_{p-1})"/>.
The diagonal matrix element <img class="math" src="_images/math/799fdcdc5a755a13e87ed5f26d03acd53305516f.png" alt="l_i"/> is provided by the
<img class="math" src="_images/math/8ba3c887c6b69d4f3fc99ada2119799a385a325f.png" alt="i"/>-th element of the input vector <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a>.
The block (<a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>) is converted to standard form and
the parameters (<img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>, <img class="math" src="_images/math/fb66b789ec86f2ea9b05b20a80f9485ef0dd4f55.png" alt="\tilde{y}"/>) are stored in <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a>
and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> on output.  <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> have the same dimensions as
<a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>. Optional data weights may be supplied in the
vector <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>. In order to apply this transformation,
<img class="math" src="_images/math/9a74993ef564e44ea7bb959c0555afff5884e9e0.png" alt="L^{-1}"/> must exist and so none of the <img class="math" src="_images/math/799fdcdc5a755a13e87ed5f26d03acd53305516f.png" alt="l_i"/>
may be zero. After the standard form system has been solved,
use <a class="reference internal" href="#c.gsl_multilarge_linear_genform1" title="gsl_multilarge_linear_genform1"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multilarge_linear_genform1()</span></code></a> to recover the original solution vector.
It is allowed to have <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> = <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> = <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform1" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> for an
in-place transform.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_L_decomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_L_decomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tau</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_L_decomp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function calculates the QR decomposition of the <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>
regularization matrix <a class="reference internal" href="#c.gsl_multilarge_linear_L_decomp" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a>. <a class="reference internal" href="#c.gsl_multilarge_linear_L_decomp" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a> must have <img class="math" src="_images/math/bb6504b682fe562d5163328de253718ef192a0b9.png" alt="m \ge p"/>.  On output,
the Householder scalars are stored in the vector <a class="reference internal" href="#c.gsl_multilarge_linear_L_decomp" title="tau"><code class="xref c c-data docutils literal notranslate"><span class="pre">tau</span></code></a> of size <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>.
These outputs will be used by <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="gsl_multilarge_linear_wstdform2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multilarge_linear_wstdform2()</span></code></a> to complete the
transformation to standard form.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_stdform2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_stdform2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">LQR</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Ltau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_stdform2" title="Permalink to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_wstdform2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_wstdform2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">LQR</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Ltau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Xs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_wstdform2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These functions convert a block of rows (<a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>, <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>) to standard
form (<img class="math" src="_images/math/1586311a8a86cb0e862f7f8bd0407cd2995f9480.png" alt="\tilde{X}"/>, <img class="math" src="_images/math/fb66b789ec86f2ea9b05b20a80f9485ef0dd4f55.png" alt="\tilde{y}"/>) which are stored in <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a>
respectively. <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a>, <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>, and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a> must all have the same number of rows.
The <img class="math" src="_images/math/d8aab746990b1e68a457b5fa326f991469488b82.png" alt="m"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> regularization matrix <code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code> is specified by the inputs
<a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="LQR"><code class="xref c c-data docutils literal notranslate"><span class="pre">LQR</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="Ltau"><code class="xref c c-data docutils literal notranslate"><span class="pre">Ltau</span></code></a>, which are outputs from <a class="reference internal" href="#c.gsl_multilarge_linear_L_decomp" title="gsl_multilarge_linear_L_decomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multilarge_linear_L_decomp()</span></code></a>.
<a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="Xs"><code class="xref c c-data docutils literal notranslate"><span class="pre">Xs</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="ys"><code class="xref c c-data docutils literal notranslate"><span class="pre">ys</span></code></a> have the same dimensions as <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a>. After the
standard form system has been solved, use <a class="reference internal" href="#c.gsl_multilarge_linear_genform2" title="gsl_multilarge_linear_genform2"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multilarge_linear_genform2()</span></code></a> to
recover the original solution vector. Optional data weights may be supplied in the
vector <a class="reference internal" href="#c.gsl_multilarge_linear_wstdform2" title="w"><code class="xref c c-data docutils literal notranslate"><span class="pre">w</span></code></a>, where <img class="math" src="_images/math/b04dd2ceeeb4d3b4997d06afd068d326bf508861.png" alt="W = \diag(w)"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_accumulate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_accumulate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">y</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_accumulate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function accumulates the standard form block (<img class="math" src="_images/math/0823708aa1fe1536511801c43269d0085a6d825c.png" alt="X,y"/>) into the
current least squares system. <a class="reference internal" href="#c.gsl_multilarge_linear_accumulate" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_accumulate" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> have the same number
of rows, which can be arbitrary.  <a class="reference internal" href="#c.gsl_multilarge_linear_accumulate" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> must have <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> columns.
For the TSQR method, <a class="reference internal" href="#c.gsl_multilarge_linear_accumulate" title="X"><code class="xref c c-data docutils literal notranslate"><span class="pre">X</span></code></a> and <a class="reference internal" href="#c.gsl_multilarge_linear_accumulate" title="y"><code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code></a> are destroyed on output.
For the normal equations method, they are both unchanged.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_solve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_solve</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">lambda</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rnorm</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">snorm</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_solve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>After all blocks (<img class="math" src="_images/math/7127c43b2185f054eed2664d21deee167b9fcb7a.png" alt="X_i,y_i"/>) have been accumulated into
the large least squares system, this function will compute
the solution vector which is stored in <a class="reference internal" href="#c.gsl_multilarge_linear_solve" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> on output.
The regularization parameter <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> is provided in
<a class="reference internal" href="#c.gsl_multilarge_linear_solve" title="lambda"><code class="xref c c-data docutils literal notranslate"><span class="pre">lambda</span></code></a>. On output, <a class="reference internal" href="#c.gsl_multilarge_linear_solve" title="rnorm"><code class="xref c c-data docutils literal notranslate"><span class="pre">rnorm</span></code></a> contains the residual norm
<img class="math" src="_images/math/9b1e41e441e1aa28d2f3dc8950679da98d08f1a8.png" alt="||y - X c||_W"/> and <a class="reference internal" href="#c.gsl_multilarge_linear_solve" title="snorm"><code class="xref c c-data docutils literal notranslate"><span class="pre">snorm</span></code></a> contains the solution
norm <img class="math" src="_images/math/4096020c4dcaa6e48790dd0d53081a7923320328.png" alt="||L c||"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_genform1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_genform1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">L</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_genform1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>After a regularized system has been solved with
<img class="math" src="_images/math/9b034af2b5b38d62812c122df790dba7e16c1ee0.png" alt="L = \diag(\l_0,\l_1,...,\l_{p-1})"/>,
this function backtransforms the standard form solution vector <a class="reference internal" href="#c.gsl_multilarge_linear_genform1" title="cs"><code class="xref c c-data docutils literal notranslate"><span class="pre">cs</span></code></a>
to recover the solution vector of the original problem <a class="reference internal" href="#c.gsl_multilarge_linear_genform1" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a>. The
diagonal matrix elements <img class="math" src="_images/math/799fdcdc5a755a13e87ed5f26d03acd53305516f.png" alt="l_i"/> are provided in
the vector <a class="reference internal" href="#c.gsl_multilarge_linear_genform1" title="L"><code class="xref c c-data docutils literal notranslate"><span class="pre">L</span></code></a>. It is allowed to have <a class="reference internal" href="#c.gsl_multilarge_linear_genform1" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a> = <a class="reference internal" href="#c.gsl_multilarge_linear_genform1" title="cs"><code class="xref c c-data docutils literal notranslate"><span class="pre">cs</span></code></a> for an
in-place transform.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_genform2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_genform2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">LQR</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Ltau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_genform2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>After a regularized system has been solved with a regularization matrix <img class="math" src="_images/math/022e294d9cc6b55633e3693ba894200d32b283ad.png" alt="L"/>,
specified by (<a class="reference internal" href="#c.gsl_multilarge_linear_genform2" title="LQR"><code class="xref c c-data docutils literal notranslate"><span class="pre">LQR</span></code></a>, <a class="reference internal" href="#c.gsl_multilarge_linear_genform2" title="Ltau"><code class="xref c c-data docutils literal notranslate"><span class="pre">Ltau</span></code></a>), this function backtransforms the standard form
solution <a class="reference internal" href="#c.gsl_multilarge_linear_genform2" title="cs"><code class="xref c c-data docutils literal notranslate"><span class="pre">cs</span></code></a>
to recover the solution vector of the original problem, which is stored in <a class="reference internal" href="#c.gsl_multilarge_linear_genform2" title="c"><code class="xref c c-data docutils literal notranslate"><span class="pre">c</span></code></a>,
of length <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_lcurve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_lcurve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reg_param</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rho</span></span>, <a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">eta</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_lcurve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the L-curve for a large least squares system
after it has been fully accumulated into the workspace <a class="reference internal" href="#c.gsl_multilarge_linear_lcurve" title="work"><code class="xref c c-data docutils literal notranslate"><span class="pre">work</span></code></a>.
The output vectors <a class="reference internal" href="#c.gsl_multilarge_linear_lcurve" title="reg_param"><code class="xref c c-data docutils literal notranslate"><span class="pre">reg_param</span></code></a>, <a class="reference internal" href="#c.gsl_multilarge_linear_lcurve" title="rho"><code class="xref c c-data docutils literal notranslate"><span class="pre">rho</span></code></a>, and <a class="reference internal" href="#c.gsl_multilarge_linear_lcurve" title="eta"><code class="xref c c-data docutils literal notranslate"><span class="pre">eta</span></code></a> must all
be the same size, and will contain the regularization parameters
<img class="math" src="_images/math/bb25874f406594c2fab03b21c91e2678f1d52391.png" alt="\lambda_i"/>, residual norms <img class="math" src="_images/math/91f5dc9d3074eec263bc403de9b35541248bcb81.png" alt="||y - X c_i||"/>, and solution
norms <img class="math" src="_images/math/91e027cc6ac8b9369b0c078fbaf56ce22865866a.png" alt="|| L c_i ||"/> which compose the L-curve, where <img class="math" src="_images/math/8f3ed3aa23232b84b9d4f7e1d0068c62e5869384.png" alt="c_i"/>
is the regularized solution vector corresponding to <img class="math" src="_images/math/bb25874f406594c2fab03b21c91e2678f1d52391.png" alt="\lambda_i"/>.
The user may determine the number of points on the L-curve by
adjusting the size of these input arrays. For the TSQR method,
the regularization parameters <img class="math" src="_images/math/bb25874f406594c2fab03b21c91e2678f1d52391.png" alt="\lambda_i"/> are estimated from the
singular values of the triangular <img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> factor. For the normal
equations method, they are estimated from the eigenvalues of the
<img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/> matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_matrix_ptr">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_matrix" title="gsl_matrix"><span class="n"><span class="pre">gsl_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_matrix_ptr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_matrix_ptr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For the normal equations method, this function returns a pointer to the <img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/> matrix
of size <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>. For the TSQR method, this function returns a pointer to the
upper triangular <img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> matrix of size <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-<img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_rhs_ptr">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="vectors.html#c.gsl_vector" title="gsl_vector"><span class="n"><span class="pre">gsl_vector</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_rhs_ptr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_rhs_ptr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For the normal equations method, this function returns a pointer to the <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/>-by-1 right hand
side vector <img class="math" src="_images/math/1701f4408fc6370638f94abc4229b5e913592962.png" alt="X^T y"/>. For the TSQR method, this function returns a pointer to a vector of length
<img class="math" src="_images/math/b14dcebeba93c4aa051ac5f56d81b156a896798b.png" alt="p+1"/>. The first <img class="math" src="_images/math/fb0d29f420855f76f8e9deaf5ff8c5580e97a4f0.png" alt="p"/> elements of this vector contain <img class="math" src="_images/math/43d0ebf4def2d4c797d9e525967170b5275ebbb2.png" alt="z_1"/>, while the last element
contains <img class="math" src="_images/math/4cfdc991772b52c1fe00a56fa7e1abece6b551ed.png" alt="||z_2||"/>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_multilarge_linear_rcond">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_multilarge_linear_rcond</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rcond</span></span>, <a class="reference internal" href="#c.gsl_multilarge_linear_workspace" title="gsl_multilarge_linear_workspace"><span class="n"><span class="pre">gsl_multilarge_linear_workspace</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_multilarge_linear_rcond" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function computes the reciprocal condition number, stored in
<a class="reference internal" href="#c.gsl_multilarge_linear_rcond" title="rcond"><code class="xref c c-data docutils literal notranslate"><span class="pre">rcond</span></code></a>, of the least squares matrix after it has been accumulated
into the workspace <a class="reference internal" href="#c.gsl_multilarge_linear_rcond" title="work"><code class="xref c c-data docutils literal notranslate"><span class="pre">work</span></code></a>. For the TSQR algorithm, this is
accomplished by calculating the SVD of the <img class="math" src="_images/math/e7ab078b9051b4f8f0bad24ab0ac0f62ea8be575.png" alt="R"/> factor, which
has the same singular values as the matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>. For the normal
equations method, this is done by computing the eigenvalues of
<img class="math" src="_images/math/da939efa089e6deefde4f0b69bd5bbdb3f024fb7.png" alt="X^T X"/>, which could be inaccurate for ill-conditioned matrices
<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="troubleshooting">
<span id="index-13"></span><h2>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permalink to this heading">¶</a></h2>
<p>When using models based on polynomials, care should be taken when constructing the design matrix
<img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/>. If the <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> values are large, then the matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> could be ill-conditioned
since its columns are powers of <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>, leading to unstable least-squares solutions.
In this case it can often help to center and scale the <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/> values using the mean and standard deviation:</p>
<div class="math">
<p><img src="_images/math/5c98bcbbe3b5c6b1473a07dc50d1cb2c35693c43.png" alt="x' = {x - \mu(x) \over \sigma(x)}"/></p>
</div><p>and then construct the <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> matrix using the transformed values <img class="math" src="_images/math/5f9daf987989e00316cb5fe482843f00ad0c6a92.png" alt="x'"/>.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<p>The example programs in this section demonstrate the various linear regression methods.</p>
<div class="section" id="simple-linear-regression-example">
<h3>Simple Linear Regression Example<a class="headerlink" href="#simple-linear-regression-example" title="Permalink to this heading">¶</a></h3>
<p>The following program computes a least squares straight-line fit to a
simple dataset, and outputs the best-fit line and its
associated one standard-deviation error bars.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_fit.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1970</span><span class="p">,</span> <span class="mi">1980</span><span class="p">,</span> <span class="mi">1990</span><span class="p">,</span> <span class="mi">2000</span> <span class="p">};</span>
  <span class="n">double</span> <span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>   <span class="mi">12</span><span class="p">,</span>   <span class="mi">11</span><span class="p">,</span>   <span class="mi">14</span><span class="p">,</span>   <span class="mi">13</span> <span class="p">};</span>
  <span class="n">double</span> <span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>  <span class="mf">0.1</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.4</span> <span class="p">};</span>

  <span class="n">double</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">cov00</span><span class="p">,</span> <span class="n">cov01</span><span class="p">,</span> <span class="n">cov11</span><span class="p">,</span> <span class="n">chisq</span><span class="p">;</span>

  <span class="n">gsl_fit_wlinear</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">c0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cov00</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cov01</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cov11</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">chisq</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# best fit: Y = </span><span class="si">%g</span><span class="s2"> + </span><span class="si">%g</span><span class="s2"> X</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# covariance matrix:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# [ </span><span class="si">%g</span><span class="s2">, </span><span class="si">%g</span><span class="se">\n</span><span class="s2">#   </span><span class="si">%g</span><span class="s2">, </span><span class="si">%g</span><span class="s2">]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">cov00</span><span class="p">,</span> <span class="n">cov01</span><span class="p">,</span> <span class="n">cov01</span><span class="p">,</span> <span class="n">cov11</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# chisq = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;data: </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                   <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">30</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">130</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mf">100.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">double</span> <span class="n">yf</span><span class="p">,</span> <span class="n">yf_err</span><span class="p">;</span>

      <span class="n">gsl_fit_linear_est</span> <span class="p">(</span><span class="n">xf</span><span class="p">,</span>
                          <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span>
                          <span class="n">cov00</span><span class="p">,</span> <span class="n">cov01</span><span class="p">,</span> <span class="n">cov11</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">yf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">yf_err</span><span class="p">);</span>

      <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;fit: </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">);</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;hi : </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span> <span class="o">+</span> <span class="n">yf_err</span><span class="p">);</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;lo : </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span> <span class="o">-</span> <span class="n">yf_err</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following commands extract the data from the output of the program
and display it using the GNU plotutils “graph” utility:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./demo &gt; tmp
$ more tmp
# best fit: Y = -106.6 + 0.06 X
# covariance matrix:
# [ 39602, -19.9
#   -19.9, 0.01]
# chisq = 0.8

$ for n in data fit hi lo ;
   do
     grep &quot;^$n&quot; tmp | cut -d: -f2 &gt; $n ;
   done
$ graph -T X -X x -Y y -y 0 20 -m 0 -S 2 -Ie data
     -S 0 -I a -m 1 fit -m 2 hi -m 2 lo
</pre></div>
</div>
<p>The result is shown in <a class="reference internal" href="#fig-fit-wlinear"><span class="std std-numref">Fig. 30</span></a>.</p>
<div class="figure align-default" id="id1">
<span id="fig-fit-wlinear"></span><img alt="_images/fit-wlinear.png" src="_images/fit-wlinear.png" />
<p class="caption"><span class="caption-number">Fig. 30 </span><span class="caption-text">Straight line fit with 1-<img class="math" src="_images/math/0b7620936fd7a90e5dde43c07609be992245871a.png" alt="\sigma"/> error bars</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="multi-parameter-linear-regression-example">
<h3>Multi-parameter Linear Regression Example<a class="headerlink" href="#multi-parameter-linear-regression-example" title="Permalink to this heading">¶</a></h3>
<p>The following program performs a quadratic fit <img class="math" src="_images/math/10f2dd0addac5c8a73d8646f0adfcaa17f9cd27e.png" alt="y = c_0 + c_1 x + c_2 x^2"/>
to a weighted dataset using the generalised linear fitting function
<a class="reference internal" href="#c.gsl_multifit_wlinear" title="gsl_multifit_wlinear"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_multifit_wlinear()</span></code></a>.  The model matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> for a quadratic
fit is given by,</p>
<div class="math">
<p><img src="_images/math/72698b6d309343b129f901be1c538b177e64d0f5.png" alt="X =
\left(
  \begin{array}{ccc}
    1 &amp; x_0 &amp; x_0^2 \\
    1 &amp; x_1 &amp; x_1^2 \\
    1 &amp; x_2 &amp; x_2^2 \\
    \dots &amp; \dots &amp; \dots
  \end{array}
\right)"/></p>
</div><p>where the column of ones corresponds to the constant term <img class="math" src="_images/math/a6819810a3fc2bc92ac2dad7a2ab2cf2dfeabfc6.png" alt="c_0"/>.
The two remaining columns corresponds to the terms <img class="math" src="_images/math/8cbac4b191055c821ccf6eb46b32dba3b0cb6feb.png" alt="c_1 x"/> and
<img class="math" src="_images/math/3b29bd8550f2380addfde771a8f5e7a1e0b671d6.png" alt="c_2 x^2"/>.</p>
<p>The program reads <code class="xref c c-data docutils literal notranslate"><span class="pre">n</span></code> lines of data in the format (<code class="xref c c-data docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code>,
<code class="xref c c-data docutils literal notranslate"><span class="pre">err</span></code>) where <code class="xref c c-data docutils literal notranslate"><span class="pre">err</span></code> is the error (standard deviation) in the
value <code class="xref c c-data docutils literal notranslate"><span class="pre">y</span></code>.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">chisq</span><span class="p">;</span>
  <span class="n">gsl_matrix</span> <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">cov</span><span class="p">;</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s2">&quot;usage: fit n &lt; data</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
      <span class="n">exit</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">X</span> <span class="o">=</span> <span class="n">gsl_matrix_alloc</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">w</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span> <span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">cov</span> <span class="o">=</span> <span class="n">gsl_matrix_alloc</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">fscanf</span> <span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%lg</span><span class="s2"> </span><span class="si">%lg</span><span class="s2"> </span><span class="si">%lg</span><span class="s2">&quot;</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">xi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">yi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ei</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;error reading file</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
          <span class="n">exit</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

      <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> +/- </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

      <span class="n">gsl_matrix_set</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
      <span class="n">gsl_matrix_set</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="p">);</span>
      <span class="n">gsl_matrix_set</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">xi</span><span class="o">*</span><span class="n">xi</span><span class="p">);</span>

      <span class="n">gsl_vector_set</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span><span class="p">);</span>
      <span class="n">gsl_vector_set</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">ei</span><span class="o">*</span><span class="n">ei</span><span class="p">));</span>
    <span class="p">}</span>

  <span class="p">{</span>
    <span class="n">gsl_multifit_linear_workspace</span> <span class="o">*</span> <span class="n">work</span>
      <span class="o">=</span> <span class="n">gsl_multifit_linear_alloc</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">gsl_multifit_wlinear</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">chisq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
    <span class="n">gsl_multifit_linear_free</span> <span class="p">(</span><span class="n">work</span><span class="p">);</span>
  <span class="p">}</span>

<span class="c1">#define C(i) (gsl_vector_get(c,(i)))</span>
<span class="c1">#define COV(i,j) (gsl_matrix_get(cov,(i),(j)))</span>

  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# best fit: Y = </span><span class="si">%g</span><span class="s2"> + </span><span class="si">%g</span><span class="s2"> X + </span><span class="si">%g</span><span class="s2"> X^2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# covariance matrix:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;[ </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="s2">  </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">COV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;  </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="s2">  </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">COV</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;  </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="s2"> ]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">COV</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# chisq = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">gsl_matrix_free</span> <span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span> <span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span> <span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span> <span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">gsl_matrix_free</span> <span class="p">(</span><span class="n">cov</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A suitable set of data for fitting can be generated using the following
program.  It outputs a set of points with gaussian errors from the curve
<img class="math" src="_images/math/39bfc6db0a0d53c4957525bafeec1e8b1c98f13f.png" alt="y = e^x"/> in the region <img class="math" src="_images/math/b194d1a58620c39118684984cc00eb233f16fc2d.png" alt="0 &lt; x &lt; 2"/>.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;math.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_randist.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">gsl_rng_type</span> <span class="o">*</span> <span class="n">T</span><span class="p">;</span>
  <span class="n">gsl_rng</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>

  <span class="n">gsl_rng_env_setup</span> <span class="p">();</span>

  <span class="n">T</span> <span class="o">=</span> <span class="n">gsl_rng_default</span><span class="p">;</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">gsl_rng_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">x</span><span class="o">+=</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">exp</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">y0</span><span class="p">;</span>
      <span class="n">double</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">gsl_ran_gaussian</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>

      <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">gsl_rng_free</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The data can be prepared by running the resulting executable program:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ GSL_RNG_TYPE=mt19937_1999 ./generate &gt; exp.dat
$ more exp.dat
0.1 0.97935 0.110517
0.2 1.3359 0.12214
0.3 1.52573 0.134986
0.4 1.60318 0.149182
0.5 1.81731 0.164872
0.6 1.92475 0.182212
....
</pre></div>
</div>
<p>To fit the data use the previous program, with the number of data points
given as the first argument.  In this case there are 19 data points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./fit 19 &lt; exp.dat
0.1 0.97935 +/- 0.110517
0.2 1.3359 +/- 0.12214
...
# best fit: Y = 1.02318 + 0.956201 X + 0.876796 X^2
# covariance matrix:
[ +1.25612e-02, -3.64387e-02, +1.94389e-02
  -3.64387e-02, +1.42339e-01, -8.48761e-02
  +1.94389e-02, -8.48761e-02, +5.60243e-02 ]
# chisq = 23.0987
</pre></div>
</div>
<p>The parameters of the quadratic fit match the coefficients of the
expansion of <img class="math" src="_images/math/a5d640d8739ed81ca11e295bd8dab5570997e588.png" alt="e^x"/>, taking into account the errors on the
parameters and the <img class="math" src="_images/math/d8be0f1ec105667b3fd7406bc39c58f6443ec220.png" alt="O(x^3)"/> difference between the exponential and
quadratic functions for the larger values of <img class="math" src="_images/math/43f98bc915444c1fdc19b396ac4fbc66f194c578.png" alt="x"/>.  The errors on
the parameters are given by the square-root of the corresponding
diagonal elements of the covariance matrix.  The chi-squared per degree
of freedom is 1.4, indicating a reasonable fit to the data.</p>
<p><a class="reference internal" href="#fig-fit-wlinear2"><span class="std std-numref">Fig. 31</span></a> shows the resulting fit.</p>
<div class="figure align-default" id="id2">
<span id="fig-fit-wlinear2"></span><img alt="_images/fit-wlinear2.png" src="_images/fit-wlinear2.png" />
<p class="caption"><span class="caption-number">Fig. 31 </span><span class="caption-text">Weighted fit example with error bars</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="regularized-linear-regression-example-1">
<h3>Regularized Linear Regression Example 1<a class="headerlink" href="#regularized-linear-regression-example-1" title="Permalink to this heading">¶</a></h3>
<p>The next program demonstrates the difference between ordinary and
regularized least squares when the design matrix is near-singular.
In this program, we generate two random normally distributed variables
<img class="math" src="_images/math/71fb5a1cc0758ba70654e6dc934c374032656d2f.png" alt="u"/> and <img class="math" src="_images/math/5fdec03022aa06df18d924e8a33c9d7c6db2ebc8.png" alt="v"/>, with <img class="math" src="_images/math/bc35fa3ee9a9e360cdf0e59b63c6a5fc62599aaf.png" alt="v = u + noise"/> so that <img class="math" src="_images/math/71fb5a1cc0758ba70654e6dc934c374032656d2f.png" alt="u"/>
and <img class="math" src="_images/math/5fdec03022aa06df18d924e8a33c9d7c6db2ebc8.png" alt="v"/> are nearly colinear. We then set a third dependent
variable <img class="math" src="_images/math/b82449f7f669d5359a6d5d6bea830ea5100e9336.png" alt="y = u + v + noise"/> and solve for the coefficients
<img class="math" src="_images/math/aebe0f3fe0d80dc7aa5952e08ca4ae19a29fa632.png" alt="c_1,c_2"/> of the model <img class="math" src="_images/math/402021f6d2eab1e586ae1f8b924ad3bf1527609d.png" alt="Y(c_1,c_2) = c_1 u + c_2 v"/>.
Since <img class="math" src="_images/math/bb8be20bd860a16359ac5c46f017f6d9e21ad780.png" alt="u \approx v"/>, the design matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is nearly
singular, leading to unstable ordinary least squares solutions.</p>
<p>Here is the program output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matrix</span> <span class="n">condition</span> <span class="n">number</span> <span class="o">=</span> <span class="mf">1.025113e+04</span>

<span class="o">===</span> <span class="n">Unregularized</span> <span class="n">fit</span> <span class="o">===</span>
<span class="n">best</span> <span class="n">fit</span><span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">43.6588</span> <span class="n">u</span> <span class="o">+</span> <span class="mf">45.6636</span> <span class="n">v</span>
<span class="n">residual</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">31.6248</span>
<span class="n">solution</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">63.1764</span>
<span class="n">chisq</span><span class="o">/</span><span class="n">dof</span> <span class="o">=</span> <span class="mf">1.00213</span>

<span class="o">===</span> <span class="n">Regularized</span> <span class="n">fit</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">curve</span><span class="p">)</span> <span class="o">===</span>
<span class="n">optimal</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">4.51103</span>
<span class="n">best</span> <span class="n">fit</span><span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">1.00113</span> <span class="n">u</span> <span class="o">+</span> <span class="mf">1.0032</span> <span class="n">v</span>
<span class="n">residual</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">31.6547</span>
<span class="n">solution</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">1.41728</span>
<span class="n">chisq</span><span class="o">/</span><span class="n">dof</span> <span class="o">=</span> <span class="mf">1.04499</span>

<span class="o">===</span> <span class="n">Regularized</span> <span class="n">fit</span> <span class="p">(</span><span class="n">GCV</span><span class="p">)</span> <span class="o">===</span>
<span class="n">optimal</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">0.0232029</span>
<span class="n">best</span> <span class="n">fit</span><span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">19.8367</span> <span class="n">u</span> <span class="o">+</span> <span class="mf">21.8417</span> <span class="n">v</span>
<span class="n">residual</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">31.6332</span>
<span class="n">solution</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">29.5051</span>
<span class="n">chisq</span><span class="o">/</span><span class="n">dof</span> <span class="o">=</span> <span class="mf">1.00314</span>
</pre></div>
</div>
<p>We see that the ordinary least squares solution is completely wrong,
while the L-curve regularized method with the optimal
<img class="math" src="_images/math/d86f00ef347a3385a0fdbed7989b38346f212644.png" alt="\lambda = 4.51103"/> finds the correct solution
<img class="math" src="_images/math/9a0dd472716f52a6382f85b95029291e5df93312.png" alt="c_1 \approx c_2 \approx 1"/>. The GCV regularized method finds
a regularization parameter <img class="math" src="_images/math/71c0a4c8b3b5924ae0a40aea4b4065ef83d8ca0a.png" alt="\lambda = 0.0232029"/> which is too
small to give an accurate solution, although it performs better than OLS.
The L-curve and its computed corner, as well as the GCV curve and its
minimum are plotted in <a class="reference internal" href="#fig-regularized"><span class="std std-numref">Fig. 32</span></a>.</p>
<div class="figure align-default" id="id3">
<span id="fig-regularized"></span><img alt="_images/regularized.png" src="_images/regularized.png" />
<p class="caption"><span class="caption-number">Fig. 32 </span><span class="caption-text">L-curve and GCV curve for example program.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The program is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;gsl/gsl_math.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_rng.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_randist.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit.h&gt;</span>

<span class="nb">int</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">observations</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">model</span> <span class="n">parameters</span> <span class="o">*/</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">gsl_rng</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">gsl_rng_alloc</span><span class="p">(</span><span class="n">gsl_rng_default</span><span class="p">);</span>
  <span class="n">gsl_matrix</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="n">gsl_matrix_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">/*</span> <span class="n">generate</span> <span class="n">first</span> <span class="n">random</span> <span class="n">variable</span> <span class="n">u</span> <span class="o">*/</span>
      <span class="n">double</span> <span class="n">ui</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">*</span> <span class="n">gsl_ran_gaussian</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

      <span class="o">/*</span> <span class="nb">set</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">noise</span> <span class="o">*/</span>
      <span class="n">double</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">ui</span> <span class="o">+</span> <span class="n">gsl_ran_gaussian</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span>

      <span class="o">/*</span> <span class="nb">set</span> <span class="n">y</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="n">noise</span> <span class="o">*/</span>
      <span class="n">double</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">ui</span> <span class="o">+</span> <span class="n">vi</span> <span class="o">+</span> <span class="n">gsl_ran_gaussian</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">since</span> <span class="n">u</span> <span class="o">=~</span> <span class="n">v</span><span class="p">,</span> <span class="n">the</span> <span class="n">matrix</span> <span class="n">X</span> <span class="ow">is</span> <span class="n">ill</span><span class="o">-</span><span class="n">conditioned</span> <span class="o">*/</span>
      <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
      <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vi</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">rhs</span> <span class="n">vector</span> <span class="o">*/</span>
      <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="p">{</span>
    <span class="n">const</span> <span class="n">size_t</span> <span class="n">npoints</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>                   <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">points</span> <span class="n">on</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="ow">and</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_workspace</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span>
      <span class="n">gsl_multifit_linear_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>          <span class="o">/*</span> <span class="n">OLS</span> <span class="n">solution</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c_lcurve</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>   <span class="o">/*</span> <span class="n">regularized</span> <span class="n">solution</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">curve</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c_gcv</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>      <span class="o">/*</span> <span class="n">regularized</span> <span class="n">solution</span> <span class="p">(</span><span class="n">GCV</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">reg_param</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">rho</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>  <span class="o">/*</span> <span class="n">residual</span> <span class="n">norms</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">eta</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>  <span class="o">/*</span> <span class="n">solution</span> <span class="n">norms</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">G</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>    <span class="o">/*</span> <span class="n">GCV</span> <span class="n">function</span> <span class="n">values</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">lambda_l</span><span class="p">;</span>                              <span class="o">/*</span> <span class="n">optimal</span> <span class="n">regularization</span> <span class="n">parameter</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">curve</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">lambda_gcv</span><span class="p">;</span>                            <span class="o">/*</span> <span class="n">optimal</span> <span class="n">regularization</span> <span class="n">parameter</span> <span class="p">(</span><span class="n">GCV</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">G_gcv</span><span class="p">;</span>                                 <span class="o">/*</span> <span class="n">G</span><span class="p">(</span><span class="n">lambda_gcv</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">size_t</span> <span class="n">reg_idx</span><span class="p">;</span>                               <span class="o">/*</span> <span class="n">index</span> <span class="n">of</span> <span class="n">optimal</span> <span class="k">lambda</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">rcond</span><span class="p">;</span>                                 <span class="o">/*</span> <span class="n">reciprocal</span> <span class="n">condition</span> <span class="n">number</span> <span class="n">of</span> <span class="n">X</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">chisq</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">snorm</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">compute</span> <span class="n">SVD</span> <span class="n">of</span> <span class="n">X</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

    <span class="n">rcond</span> <span class="o">=</span> <span class="n">gsl_multifit_linear_rcond</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;matrix condition number = </span><span class="si">%e</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">unregularized</span> <span class="p">(</span><span class="n">standard</span><span class="p">)</span> <span class="n">least</span> <span class="n">squares</span> <span class="n">fit</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_solve</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnorm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snorm</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">chisq</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">rnorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;=== Unregularized fit ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;best fit: y = </span><span class="si">%g</span><span class="s2"> u + </span><span class="si">%g</span><span class="s2"> v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
      <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;residual norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;solution norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">snorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;chisq/dof = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">calculate</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="ow">and</span> <span class="n">find</span> <span class="n">its</span> <span class="n">corner</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_lcurve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">reg_param</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">gsl_multifit_linear_lcorner</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_idx</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">store</span> <span class="n">optimal</span> <span class="n">regularization</span> <span class="n">parameter</span> <span class="o">*/</span>
    <span class="n">lambda_l</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">reg_param</span><span class="p">,</span> <span class="n">reg_idx</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">regularize</span> <span class="k">with</span> <span class="n">lambda_l</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_solve</span><span class="p">(</span><span class="n">lambda_l</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c_lcurve</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnorm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snorm</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">chisq</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">rnorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">lambda_l</span> <span class="o">*</span> <span class="n">snorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Regularized fit (L-curve) ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;optimal lambda: </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">lambda_l</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;best fit: y = </span><span class="si">%g</span><span class="s2"> u + </span><span class="si">%g</span><span class="s2"> v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">c_lcurve</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">c_lcurve</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;residual norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;solution norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">snorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;chisq/dof = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">calculate</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="ow">and</span> <span class="n">find</span> <span class="n">its</span> <span class="n">minimum</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_gcv</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">reg_param</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lambda_gcv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">G_gcv</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">regularize</span> <span class="k">with</span> <span class="n">lambda_gcv</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_solve</span><span class="p">(</span><span class="n">lambda_gcv</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c_gcv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnorm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snorm</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">chisq</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">rnorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">lambda_gcv</span> <span class="o">*</span> <span class="n">snorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Regularized fit (GCV) ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;optimal lambda: </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">lambda_gcv</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;best fit: y = </span><span class="si">%g</span><span class="s2"> u + </span><span class="si">%g</span><span class="s2"> v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">c_gcv</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">c_gcv</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;residual norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;solution norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">snorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;chisq/dof = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">output</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="ow">and</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="o">*/</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">reg_param</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
      <span class="p">}</span>

    <span class="o">/*</span> <span class="n">output</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="n">corner</span> <span class="n">point</span> <span class="o">*/</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
           <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">reg_idx</span><span class="p">),</span>
           <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">reg_idx</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">output</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="n">corner</span> <span class="n">minimum</span> <span class="o">*/</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
           <span class="n">lambda_gcv</span><span class="p">,</span>
           <span class="n">G_gcv</span><span class="p">);</span>

    <span class="n">gsl_multifit_linear_free</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">c_lcurve</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">reg_param</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">rho</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">eta</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">gsl_rng_free</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
  <span class="n">gsl_matrix_free</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="regularized-linear-regression-example-2">
<h3>Regularized Linear Regression Example 2<a class="headerlink" href="#regularized-linear-regression-example-2" title="Permalink to this heading">¶</a></h3>
<p>The following example program minimizes the cost function</p>
<div class="math">
<p><img src="_images/math/346de1da48fa4e9d5c42eb53e490334cb22b5c83.png" alt="||y - X c||^2 + \lambda^2 ||x||^2"/></p>
</div><p>where <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is the <img class="math" src="_images/math/8f8a44e9f9b7ef1fb7d0e9585dc08a38a6f89021.png" alt="10"/>-by-<img class="math" src="_images/math/2f10cd52a41801d16c321dd286f201558f839c51.png" alt="8"/> Hilbert matrix whose
entries are given by</p>
<div class="math">
<p><img src="_images/math/7029ece5a7a723c9d444d828114e540a4f439717.png" alt="X_{ij} = {1 \over i + j - 1}"/></p>
</div><p>and the right hand side vector is given by
<img class="math" src="_images/math/aec485cb5570fc30b08e31e4d2390af58f0d8b97.png" alt="y = [1,-1,1,-1,1,-1,1,-1,1,-1]^T"/>. Solutions
are computed for <img class="math" src="_images/math/f166f842a7124f6cfc52e3ce99e95eedf12d0ff6.png" alt="\lambda = 0"/> (unregularized) as
well as for optimal parameters <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/> chosen by
analyzing the L-curve and GCV curve.</p>
<p>Here is the program output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matrix</span> <span class="n">condition</span> <span class="n">number</span> <span class="o">=</span> <span class="mf">3.565872e+09</span>

<span class="o">===</span> <span class="n">Unregularized</span> <span class="n">fit</span> <span class="o">===</span>
<span class="n">residual</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">2.15376</span>
<span class="n">solution</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">2.92217e+09</span>
<span class="n">chisq</span><span class="o">/</span><span class="n">dof</span> <span class="o">=</span> <span class="mf">2.31934</span>

<span class="o">===</span> <span class="n">Regularized</span> <span class="n">fit</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">curve</span><span class="p">)</span> <span class="o">===</span>
<span class="n">optimal</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">7.11407e-07</span>
<span class="n">residual</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">2.60386</span>
<span class="n">solution</span> <span class="n">norm</span> <span class="o">=</span> <span class="mi">424507</span>
<span class="n">chisq</span><span class="o">/</span><span class="n">dof</span> <span class="o">=</span> <span class="mf">3.43565</span>

<span class="o">===</span> <span class="n">Regularized</span> <span class="n">fit</span> <span class="p">(</span><span class="n">GCV</span><span class="p">)</span> <span class="o">===</span>
<span class="n">optimal</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">1.72278</span>
<span class="n">residual</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">3.1375</span>
<span class="n">solution</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">0.139357</span>
<span class="n">chisq</span><span class="o">/</span><span class="n">dof</span> <span class="o">=</span> <span class="mf">4.95076</span>
</pre></div>
</div>
<p>Here we see the unregularized solution results in a large solution
norm due to the ill-conditioned matrix. The L-curve solution finds
a small value of <img class="math" src="_images/math/2d6f07b34942b3d6376f93c62942616ca153995e.png" alt="\lambda = 7.11e-7"/> which still results in
a badly conditioned system and a large solution norm. The GCV method
finds a parameter <img class="math" src="_images/math/595c3dfe601684fc7b9a2f1a072672133a45f171.png" alt="\lambda = 1.72"/> which results in a well-conditioned
system and small solution norm.</p>
<p>The L-curve and its computed corner, as well as the GCV curve and its
minimum are plotted in <a class="reference internal" href="#fig-regularized2"><span class="std std-numref">Fig. 33</span></a>.</p>
<div class="figure align-default" id="id4">
<span id="fig-regularized2"></span><img alt="_images/regularized2.png" src="_images/regularized2.png" />
<p class="caption"><span class="caption-number">Fig. 33 </span><span class="caption-text">L-curve and GCV curve for example program.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>The program is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;gsl/gsl_math.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_blas.h&gt;</span>

<span class="n">static</span> <span class="nb">int</span>
<span class="n">hilbert_matrix</span><span class="p">(</span><span class="n">gsl_matrix</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">N</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size1</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">M</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size2</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">gsl_matrix_set</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mf">1.0</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">GSL_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">observations</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">model</span> <span class="n">parameters</span> <span class="o">*/</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">gsl_matrix</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="n">gsl_matrix_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">construct</span> <span class="n">Hilbert</span> <span class="n">matrix</span> <span class="ow">and</span> <span class="n">rhs</span> <span class="n">vector</span> <span class="o">*/</span>
  <span class="n">hilbert_matrix</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>

  <span class="p">{</span>
    <span class="n">double</span> <span class="n">val</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">val</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span>
    <span class="n">const</span> <span class="n">size_t</span> <span class="n">npoints</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>                   <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">points</span> <span class="n">on</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="ow">and</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_workspace</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span>
      <span class="n">gsl_multifit_linear_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>          <span class="o">/*</span> <span class="n">OLS</span> <span class="n">solution</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c_lcurve</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>   <span class="o">/*</span> <span class="n">regularized</span> <span class="n">solution</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">curve</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c_gcv</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>      <span class="o">/*</span> <span class="n">regularized</span> <span class="n">solution</span> <span class="p">(</span><span class="n">GCV</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">reg_param</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">rho</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>  <span class="o">/*</span> <span class="n">residual</span> <span class="n">norms</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">eta</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>  <span class="o">/*</span> <span class="n">solution</span> <span class="n">norms</span> <span class="o">*/</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">G</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">npoints</span><span class="p">);</span>    <span class="o">/*</span> <span class="n">GCV</span> <span class="n">function</span> <span class="n">values</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">lambda_l</span><span class="p">;</span>                              <span class="o">/*</span> <span class="n">optimal</span> <span class="n">regularization</span> <span class="n">parameter</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">curve</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">lambda_gcv</span><span class="p">;</span>                            <span class="o">/*</span> <span class="n">optimal</span> <span class="n">regularization</span> <span class="n">parameter</span> <span class="p">(</span><span class="n">GCV</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">G_gcv</span><span class="p">;</span>                                 <span class="o">/*</span> <span class="n">G</span><span class="p">(</span><span class="n">lambda_gcv</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">size_t</span> <span class="n">reg_idx</span><span class="p">;</span>                               <span class="o">/*</span> <span class="n">index</span> <span class="n">of</span> <span class="n">optimal</span> <span class="k">lambda</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">rcond</span><span class="p">;</span>                                 <span class="o">/*</span> <span class="n">reciprocal</span> <span class="n">condition</span> <span class="n">number</span> <span class="n">of</span> <span class="n">X</span> <span class="o">*/</span>
    <span class="n">double</span> <span class="n">chisq</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">snorm</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">compute</span> <span class="n">SVD</span> <span class="n">of</span> <span class="n">X</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

    <span class="n">rcond</span> <span class="o">=</span> <span class="n">gsl_multifit_linear_rcond</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;matrix condition number = </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">unregularized</span> <span class="p">(</span><span class="n">standard</span><span class="p">)</span> <span class="n">least</span> <span class="n">squares</span> <span class="n">fit</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_solve</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnorm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snorm</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">chisq</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">rnorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Unregularized fit ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;residual norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;solution norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">snorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;chisq/dof = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">calculate</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="ow">and</span> <span class="n">find</span> <span class="n">its</span> <span class="n">corner</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_lcurve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">reg_param</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">gsl_multifit_linear_lcorner</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_idx</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">store</span> <span class="n">optimal</span> <span class="n">regularization</span> <span class="n">parameter</span> <span class="o">*/</span>
    <span class="n">lambda_l</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">reg_param</span><span class="p">,</span> <span class="n">reg_idx</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">regularize</span> <span class="k">with</span> <span class="n">lambda_l</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_solve</span><span class="p">(</span><span class="n">lambda_l</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c_lcurve</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnorm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snorm</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">chisq</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">rnorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">lambda_l</span> <span class="o">*</span> <span class="n">snorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Regularized fit (L-curve) ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;optimal lambda: </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">lambda_l</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;residual norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;solution norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">snorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;chisq/dof = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">calculate</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="ow">and</span> <span class="n">find</span> <span class="n">its</span> <span class="n">minimum</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_gcv</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">reg_param</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lambda_gcv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">G_gcv</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">regularize</span> <span class="k">with</span> <span class="n">lambda_gcv</span> <span class="o">*/</span>
    <span class="n">gsl_multifit_linear_solve</span><span class="p">(</span><span class="n">lambda_gcv</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c_gcv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnorm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snorm</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="n">chisq</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">rnorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">lambda_gcv</span> <span class="o">*</span> <span class="n">snorm</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Regularized fit (GCV) ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;optimal lambda: </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">lambda_gcv</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;residual norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;solution norm = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">snorm</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;chisq/dof = </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chisq</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">output</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="ow">and</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="o">*/</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">reg_param</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
      <span class="p">}</span>

    <span class="o">/*</span> <span class="n">output</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="n">corner</span> <span class="n">point</span> <span class="o">*/</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
           <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">reg_idx</span><span class="p">),</span>
           <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">reg_idx</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">output</span> <span class="n">GCV</span> <span class="n">curve</span> <span class="n">corner</span> <span class="n">minimum</span> <span class="o">*/</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
           <span class="n">lambda_gcv</span><span class="p">,</span>
           <span class="n">G_gcv</span><span class="p">);</span>

    <span class="n">gsl_multifit_linear_free</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">c_lcurve</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">reg_param</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">rho</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">eta</span><span class="p">);</span>
    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">gsl_matrix_free</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="robust-linear-regression-example">
<h3>Robust Linear Regression Example<a class="headerlink" href="#robust-linear-regression-example" title="Permalink to this heading">¶</a></h3>
<p>The next program demonstrates the advantage of robust least squares on
a dataset with outliers. The program generates linear <img class="math" src="_images/math/3c19dfc48609e2f9aa0192505880bedbb90a72f3.png" alt="(x,y)"/>
data pairs on the line <img class="math" src="_images/math/e6a7caaf26e0000eb3745206ea782757bfc69681.png" alt="y = 1.45 x + 3.88"/>, adds some random
noise, and inserts 3 outliers into the dataset. Both the robust
and ordinary least squares (OLS) coefficients are computed for
comparison.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_randist.h&gt;</span>

<span class="nb">int</span>
<span class="n">dofit</span><span class="p">(</span><span class="n">const</span> <span class="n">gsl_multifit_robust_type</span> <span class="o">*</span><span class="n">T</span><span class="p">,</span>
      <span class="n">const</span> <span class="n">gsl_matrix</span> <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="n">const</span> <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span>
      <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">gsl_matrix</span> <span class="o">*</span><span class="n">cov</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">gsl_multifit_robust_workspace</span> <span class="o">*</span> <span class="n">work</span>
    <span class="o">=</span> <span class="n">gsl_multifit_robust_alloc</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">size1</span><span class="p">,</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">size2</span><span class="p">);</span>

  <span class="n">s</span> <span class="o">=</span> <span class="n">gsl_multifit_robust</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
  <span class="n">gsl_multifit_robust_free</span> <span class="p">(</span><span class="n">work</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">main</span> <span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="o">/*</span> <span class="n">linear</span> <span class="n">fit</span> <span class="o">*/</span>
  <span class="n">gsl_matrix</span> <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">cov</span><span class="p">;</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">c_ols</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.45</span><span class="p">;</span> <span class="o">/*</span> <span class="n">slope</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">double</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">3.88</span><span class="p">;</span> <span class="o">/*</span> <span class="n">intercept</span> <span class="o">*/</span>
  <span class="n">gsl_rng</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s2">&quot;usage: robfit n</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
      <span class="n">exit</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">X</span> <span class="o">=</span> <span class="n">gsl_matrix_alloc</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">c_ols</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">cov</span> <span class="o">=</span> <span class="n">gsl_matrix_alloc</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

  <span class="n">r</span> <span class="o">=</span> <span class="n">gsl_rng_alloc</span><span class="p">(</span><span class="n">gsl_rng_default</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">generate</span> <span class="n">linear</span> <span class="n">dataset</span> <span class="o">*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">dx</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">ei</span> <span class="o">=</span> <span class="n">gsl_rng_uniform</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">xi</span> <span class="o">=</span> <span class="o">-</span><span class="mf">5.0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dx</span><span class="p">;</span>
      <span class="n">double</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

      <span class="n">gsl_vector_set</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span><span class="p">);</span>
      <span class="n">gsl_vector_set</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span> <span class="o">+</span> <span class="n">ei</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="o">/*</span> <span class="n">add</span> <span class="n">a</span> <span class="n">few</span> <span class="n">outliers</span> <span class="o">*/</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.7</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">8.3</span><span class="p">);</span>

  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.7</span><span class="p">);</span>

  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">);</span>
  <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.0</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">construct</span> <span class="n">design</span> <span class="n">matrix</span> <span class="n">X</span> <span class="k">for</span> <span class="n">linear</span> <span class="n">fit</span> <span class="o">*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

      <span class="n">gsl_matrix_set</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
      <span class="n">gsl_matrix_set</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="o">/*</span> <span class="n">perform</span> <span class="n">robust</span> <span class="ow">and</span> <span class="n">OLS</span> <span class="n">fit</span> <span class="o">*/</span>
  <span class="n">dofit</span><span class="p">(</span><span class="n">gsl_multifit_robust_ols</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c_ols</span><span class="p">,</span> <span class="n">cov</span><span class="p">);</span>
  <span class="n">dofit</span><span class="p">(</span><span class="n">gsl_multifit_robust_bisquare</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cov</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">output</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">model</span> <span class="o">*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">double</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">gsl_vector_view</span> <span class="n">v</span> <span class="o">=</span> <span class="n">gsl_matrix_row</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">double</span> <span class="n">y_ols</span><span class="p">,</span> <span class="n">y_rob</span><span class="p">,</span> <span class="n">y_err</span><span class="p">;</span>

      <span class="n">gsl_multifit_robust_est</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_rob</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_err</span><span class="p">);</span>
      <span class="n">gsl_multifit_robust_est</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">c_ols</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_ols</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_err</span><span class="p">);</span>

      <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">y_rob</span><span class="p">,</span> <span class="n">y_ols</span><span class="p">);</span>
    <span class="p">}</span>

<span class="c1">#define C(i) (gsl_vector_get(c,(i)))</span>
<span class="c1">#define COV(i,j) (gsl_matrix_get(cov,(i),(j)))</span>

  <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# best fit: Y = </span><span class="si">%g</span><span class="s2"> + </span><span class="si">%g</span><span class="s2"> X</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# covariance matrix:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;# [ </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">COV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;#   </span><span class="si">%+.5e</span><span class="s2">, </span><span class="si">%+.5e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">COV</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">COV</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">gsl_matrix_free</span> <span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span> <span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span> <span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span> <span class="p">(</span><span class="n">c_ols</span><span class="p">);</span>
  <span class="n">gsl_matrix_free</span> <span class="p">(</span><span class="n">cov</span><span class="p">);</span>
  <span class="n">gsl_rng_free</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output from the program is shown in <a class="reference internal" href="#fig-robust"><span class="std std-numref">Fig. 34</span></a>.</p>
<div class="figure align-default" id="id5">
<span id="fig-robust"></span><img alt="_images/robust.png" src="_images/robust.png" />
<p class="caption"><span class="caption-number">Fig. 34 </span><span class="caption-text">Linear fit to dataset with outliers.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="large-dense-linear-regression-example">
<h3>Large Dense Linear Regression Example<a class="headerlink" href="#large-dense-linear-regression-example" title="Permalink to this heading">¶</a></h3>
<p>The following program demostrates the large dense linear least squares
solvers. This example is adapted from Trefethen and Bau,
and fits the function <img class="math" src="_images/math/565b1bf462021900b9fd21620c27bf14b53bfe78.png" alt="f(t) = \exp{(\sin^3{(10t)}})"/> on
the interval <img class="math" src="_images/math/e7e8ac4ddd4ab0fc62c2a6435f8373f48c776858.png" alt="[0,1]"/> with a degree 15 polynomial. The
program generates <img class="math" src="_images/math/25a382063b0ccf717f324d811c2eecc5db2322e2.png" alt="n = 50000"/> equally spaced points
<img class="math" src="_images/math/0adefa77e09c6c526f71ab3063c42ab84b72082e.png" alt="t_i"/> on this interval, calculates the function value
and adds random noise to determine the observation value
<img class="math" src="_images/math/1b3578a89dede64b23bf558874c50fd32641e2cb.png" alt="y_i"/>. The entries of the least squares matrix are
<img class="math" src="_images/math/4acdb4578520e49191710750deb81af3b176084c.png" alt="X_{ij} = t_i^j"/>, representing a polynomial fit. The
matrix is highly ill-conditioned, with a condition number
of about <img class="math" src="_images/math/2546219452b7c0d643d2264b7141cd671b1619bb.png" alt="2.4 \cdot 10^{11}"/>. The program accumulates the
matrix into the least squares system in 5 blocks, each with
10000 rows. This way the full matrix <img class="math" src="_images/math/a5ff3717ce7e8e5b109e09a32e89321eef3862bf.png" alt="X"/> is never
stored in memory. We solve the system with both the
normal equations and TSQR methods. The results are shown
in <a class="reference internal" href="#fig-multilarge"><span class="std std-numref">Fig. 35</span></a>. In the top left plot, the TSQR
solution provides a reasonable agreement to the exact solution,
while the normal equations method fails completely since the
Cholesky factorization fails due to the ill-conditioning of the matrix.
In the bottom left plot, we show the L-curve calculated from TSQR, which exhibits multiple corners.
In the top right panel, we plot a regularized solution using
<img class="math" src="_images/math/858deee1fa33a681f6cc33233f3cf989bcd67e18.png" alt="\lambda = 10^{-5}"/>. The TSQR and normal solutions now agree,
however they are unable to provide a good fit due to the damping.
This indicates that for some ill-conditioned
problems, regularizing the normal equations does not improve the
solution. This is further illustrated in the bottom right panel,
where we plot the L-curve calculated from the normal equations.
The curve agrees with the TSQR curve for larger damping parameters,
but for small <img class="math" src="_images/math/ab8c818c5b43470e387a04bc496e8c092a6f5317.png" alt="\lambda"/>, the normal equations approach cannot
provide accurate solution vectors leading to numerical
inaccuracies in the left portion of the curve.</p>
<div class="figure align-default" id="id6">
<span id="fig-multilarge"></span><img alt="_images/multilarge.png" src="_images/multilarge.png" />
<p class="caption"><span class="caption-number">Fig. 35 </span><span class="caption-text">Top left: unregularized solutions; top right: regularized solutions;
bottom left: L-curve for TSQR method; bottom right: L-curve from normal equations method.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;gsl/gsl_math.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_rng.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_randist.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multifit.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_multilarge.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_blas.h&gt;</span>
<span class="c1">#include &lt;gsl/gsl_errno.h&gt;</span>

<span class="o">/*</span> <span class="n">function</span> <span class="n">to</span> <span class="n">be</span> <span class="n">fitted</span> <span class="o">*/</span>
<span class="n">double</span>
<span class="n">func</span><span class="p">(</span><span class="n">const</span> <span class="n">double</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="mf">10.0</span> <span class="o">*</span> <span class="n">t</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">/*</span> <span class="n">construct</span> <span class="n">a</span> <span class="n">row</span> <span class="n">of</span> <span class="n">the</span> <span class="n">least</span> <span class="n">squares</span> <span class="n">matrix</span> <span class="o">*/</span>
<span class="nb">int</span>
<span class="n">build_row</span><span class="p">(</span><span class="n">const</span> <span class="n">double</span> <span class="n">t</span><span class="p">,</span> <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">row</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">row</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">Xj</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">j</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">gsl_vector_set</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">Xj</span><span class="p">);</span>
      <span class="n">Xj</span> <span class="o">*=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">solve_system</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span> <span class="n">print_data</span><span class="p">,</span> <span class="n">const</span> <span class="n">gsl_multilarge_linear_type</span> <span class="o">*</span> <span class="n">T</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">double</span> <span class="k">lambda</span><span class="p">,</span> <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span><span class="p">,</span>
             <span class="n">gsl_vector</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">nblock</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">blocks</span> <span class="n">to</span> <span class="n">accumulate</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">nrows</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span> <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">rows</span> <span class="n">per</span> <span class="n">block</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_linear_workspace</span> <span class="o">*</span> <span class="n">w</span> <span class="o">=</span>
    <span class="n">gsl_multilarge_linear_alloc</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_matrix</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="n">gsl_matrix_alloc</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">nrows</span><span class="p">);</span>
  <span class="n">gsl_rng</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">gsl_rng_alloc</span><span class="p">(</span><span class="n">gsl_rng_default</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">nlcurve</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">reg_param</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">nlcurve</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">rho</span> <span class="o">=</span> <span class="n">gsl_vector_calloc</span><span class="p">(</span><span class="n">nlcurve</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">eta</span> <span class="o">=</span> <span class="n">gsl_vector_calloc</span><span class="p">(</span><span class="n">nlcurve</span><span class="p">);</span>
  <span class="n">size_t</span> <span class="n">rowidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">rcond</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">rowidx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">size_t</span> <span class="n">nleft</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">rowidx</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">rows</span> <span class="n">left</span> <span class="n">to</span> <span class="n">accumulate</span> <span class="o">*/</span>
      <span class="n">size_t</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">GSL_MIN</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">nleft</span><span class="p">);</span> <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">block</span> <span class="o">*/</span>
      <span class="n">gsl_matrix_view</span> <span class="n">Xv</span> <span class="o">=</span> <span class="n">gsl_matrix_submatrix</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
      <span class="n">gsl_vector_view</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">gsl_vector_subvector</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
      <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>

      <span class="o">/*</span> <span class="n">build</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">block</span> <span class="k">with</span> <span class="s1">&#39;nr&#39;</span> <span class="n">rows</span> <span class="o">*/</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">gsl_vector_view</span> <span class="n">row</span> <span class="o">=</span> <span class="n">gsl_matrix_row</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Xv</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
          <span class="n">double</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
          <span class="n">double</span> <span class="n">ei</span> <span class="o">=</span> <span class="n">gsl_ran_gaussian</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">fi</span><span class="p">);</span> <span class="o">/*</span> <span class="n">noise</span> <span class="o">*/</span>
          <span class="n">double</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">fi</span> <span class="o">+</span> <span class="n">ei</span><span class="p">;</span>

          <span class="o">/*</span> <span class="n">construct</span> <span class="n">this</span> <span class="n">row</span> <span class="n">of</span> <span class="n">LS</span> <span class="n">matrix</span> <span class="o">*/</span>
          <span class="n">build_row</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row</span><span class="o">.</span><span class="n">vector</span><span class="p">);</span>

          <span class="o">/*</span> <span class="nb">set</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="n">value</span> <span class="k">with</span> <span class="n">added</span> <span class="n">noise</span> <span class="o">*/</span>
          <span class="n">gsl_vector_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">yv</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span><span class="p">);</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">print_data</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">yi</span><span class="p">);</span>

          <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">;</span>
        <span class="p">}</span>

      <span class="o">/*</span> <span class="n">accumulate</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">block</span> <span class="n">into</span> <span class="n">LS</span> <span class="n">system</span> <span class="o">*/</span>
      <span class="n">gsl_multilarge_linear_accumulate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Xv</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">yv</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

      <span class="n">rowidx</span> <span class="o">+=</span> <span class="n">nr</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">print_data</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">compute</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_linear_lcurve</span><span class="p">(</span><span class="n">reg_param</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">solve</span> <span class="n">large</span> <span class="n">LS</span> <span class="n">system</span> <span class="ow">and</span> <span class="n">store</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">c</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_linear_solve</span><span class="p">(</span><span class="k">lambda</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnorm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snorm</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">compute</span> <span class="n">reciprocal</span> <span class="n">condition</span> <span class="n">number</span> <span class="o">*/</span>
  <span class="n">gsl_multilarge_linear_rcond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcond</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;=== Method </span><span class="si">%s</span><span class="s2"> ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">gsl_multilarge_linear_name</span><span class="p">(</span><span class="n">w</span><span class="p">));</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;condition number = </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">rcond</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;residual norm    = </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;solution norm    = </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">snorm</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">output</span> <span class="n">L</span><span class="o">-</span><span class="n">curve</span> <span class="o">*/</span>
  <span class="p">{</span>
    <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlcurve</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.12e</span><span class="s2"> </span><span class="si">%.12e</span><span class="s2"> </span><span class="si">%.12e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">reg_param</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
               <span class="n">gsl_vector_get</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">gsl_matrix_free</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="n">gsl_multilarge_linear_free</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="n">gsl_rng_free</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">reg_param</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">rho</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">eta</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span>
<span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">observations</span> <span class="o">*/</span>
  <span class="n">const</span> <span class="n">size_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>      <span class="o">/*</span> <span class="n">polynomial</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*/</span>
  <span class="n">double</span> <span class="k">lambda</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>      <span class="o">/*</span> <span class="n">regularization</span> <span class="n">parameter</span> <span class="o">*/</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c_tsqr</span> <span class="o">=</span> <span class="n">gsl_vector_calloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">c_normal</span> <span class="o">=</span> <span class="n">gsl_vector_calloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">lambda</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="o">/*</span> <span class="n">turn</span> <span class="n">off</span> <span class="n">error</span> <span class="n">handler</span> <span class="n">so</span> <span class="n">normal</span> <span class="n">equations</span> <span class="n">method</span> <span class="n">won</span><span class="s1">&#39;t abort */</span>
  <span class="n">gsl_set_error_handler_off</span><span class="p">();</span>

  <span class="o">/*</span> <span class="n">solve</span> <span class="n">system</span> <span class="k">with</span> <span class="n">TSQR</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gsl_multilarge_linear_tsqr</span><span class="p">,</span> <span class="k">lambda</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c_tsqr</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">solve</span> <span class="n">system</span> <span class="k">with</span> <span class="n">Normal</span> <span class="n">equations</span> <span class="n">method</span> <span class="o">*/</span>
  <span class="n">solve_system</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gsl_multilarge_linear_normal</span><span class="p">,</span> <span class="k">lambda</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c_normal</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">output</span> <span class="n">solutions</span> <span class="o">*/</span>
  <span class="p">{</span>
    <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">double</span> <span class="n">t</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="n">t</span> <span class="o">+=</span> <span class="mf">0.01</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">double</span> <span class="n">f_exact</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="n">double</span> <span class="n">f_tsqr</span><span class="p">,</span> <span class="n">f_normal</span><span class="p">;</span>

        <span class="n">build_row</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_tsqr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f_tsqr</span><span class="p">);</span>
        <span class="n">gsl_blas_ddot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_normal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f_normal</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="s2"> </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">f_exact</span><span class="p">,</span> <span class="n">f_tsqr</span><span class="p">,</span> <span class="n">f_normal</span><span class="p">);</span>
      <span class="p">}</span>

    <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">c_tsqr</span><span class="p">);</span>
  <span class="n">gsl_vector_free</span><span class="p">(</span><span class="n">c_normal</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="references-and-further-reading">
<h2>References and Further Reading<a class="headerlink" href="#references-and-further-reading" title="Permalink to this heading">¶</a></h2>
<p>A summary of formulas and techniques for least squares fitting can be
found in the “Statistics” chapter of the Annual Review of Particle
Physics prepared by the Particle Data Group,</p>
<ul class="simple">
<li><p><em>Review of Particle Properties</em>,
R.M. Barnett et al., Physical Review D54, 1 (1996)
<a class="reference external" href="http://pdg.lbl.gov">http://pdg.lbl.gov</a></p></li>
</ul>
<p>The Review of Particle Physics is available online at the website given
above.</p>
<p id="index-14">The tests used to prepare these routines are based on the NIST
Statistical Reference Datasets. The datasets and their documentation are
available from NIST at the following website,</p>
<p><a class="reference external" href="http://www.nist.gov/itl/div898/strd/index.html">http://www.nist.gov/itl/div898/strd/index.html</a></p>
<p>More information on Tikhonov regularization can be found in</p>
<ul class="simple">
<li><p>Hansen, P. C. (1998), Rank-Deficient and Discrete Ill-Posed Problems:
Numerical Aspects of Linear Inversion. SIAM Monogr. on Mathematical
Modeling and Computation, Society for Industrial and Applied Mathematics</p></li>
<li><p>M. Rezghi and S. M. Hosseini (2009), A new variant of L-curve for
Tikhonov regularization, Journal of Computational and Applied Mathematics,
Volume 231, Issue 2, pages 914-924.</p></li>
</ul>
<p>The GSL implementation of robust linear regression closely follows the publications</p>
<ul class="simple">
<li><p>DuMouchel, W. and F. O’Brien (1989), “Integrating a robust
option into a multiple regression computing environment,”
Computer Science and Statistics:  Proceedings of the 21st
Symposium on the Interface, American Statistical Association</p></li>
<li><p>Street, J.O., R.J. Carroll, and D. Ruppert (1988), “A note on
computing robust regression estimates via iteratively
reweighted least squares,” The American Statistician, v. 42,
pp. 152-154.</p></li>
</ul>
<p>More information about the normal equations and TSQR approach for solving
large linear least squares systems can be found in the publications</p>
<ul class="simple">
<li><p>Trefethen, L. N. and Bau, D. (1997), “Numerical Linear Algebra”, SIAM.</p></li>
<li><p>Demmel, J., Grigori, L., Hoemmen, M. F., and Langou, J.
“Communication-optimal parallel and sequential QR and LU factorizations”,
UCB Technical Report No. UCB/EECS-2008-89, 2008.</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="nls.html" class="btn btn-neutral float-right" title="Nonlinear Least-Squares Fitting" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="multimin.html" class="btn btn-neutral float-left" title="Multidimensional Minimization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 1996-2024 The GSL Team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>