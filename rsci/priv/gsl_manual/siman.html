

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Simulated Annealing &mdash; GSL 2.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Ordinary Differential Equations" href="ode-initval.html" />
    <link rel="prev" title="Monte Carlo Integration" href="montecarlo.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GSL
          

          
          </a>

          
            
            
              <div class="version">
                2.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Using the Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="err.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Mathematical Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="poly.html">Polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="specfunc.html">Special Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="vectors.html">Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiset.html">Multisets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="eigen.html">Eigensystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Fast Fourier Transforms (FFTs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Numerical Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="rng.html">Random Number Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="qrng.html">Quasi-Random Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="randist.html">Random Number Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="rstat.html">Running Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="movstat.html">Moving Window Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Digital Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="histogram.html">Histograms</a></li>
<li class="toctree-l1"><a class="reference internal" href="ntuple.html">N-tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="montecarlo.html">Monte Carlo Integration</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Simulated Annealing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simulated-annealing-algorithm">Simulated Annealing algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulated-annealing-functions">Simulated Annealing functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#trivial-example">Trivial example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#traveling-salesman-problem">Traveling Salesman Problem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references-and-further-reading">References and Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ode-initval.html">Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="interp.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="diff.html">Numerical Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheb.html">Chebyshev Approximations</a></li>
<li class="toctree-l1"><a class="reference internal" href="sum.html">Series Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dwt.html">Wavelet Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dht.html">Discrete Hankel Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="roots.html">One Dimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="min.html">One Dimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiroots.html">Multidimensional Root-Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="multimin.html">Multidimensional Minimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="lls.html">Linear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="nls.html">Nonlinear Least-Squares Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="bspline.html">Basis Splines</a></li>
<li class="toctree-l1"><a class="reference internal" href="spmatrix.html">Sparse Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="spblas.html">Sparse BLAS Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="splinalg.html">Sparse Linear Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="const.html">Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="ieee754.html">IEEE floating-point arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debugging Numerical Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributors to GSL</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoconf.html">Autoconf Macros</a></li>
<li class="toctree-l1"><a class="reference internal" href="cblas.html">GSL CBLAS Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpl.html">GNU General Public License</a></li>
<li class="toctree-l1"><a class="reference internal" href="fdl.html">GNU Free Documentation License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GSL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Simulated Annealing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/siman.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="ode-initval.html" class="btn btn-neutral float-right" title="Ordinary Differential Equations" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="montecarlo.html" class="btn btn-neutral float-left" title="Monte Carlo Integration" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="simulated-annealing">
<span id="index-0"></span><h1>Simulated Annealing<a class="headerlink" href="#simulated-annealing" title="Permalink to this heading">¶</a></h1>
<p>Stochastic search techniques are used when the structure of a space is
not well understood or is not smooth, so that techniques like Newton’s
method (which requires calculating Jacobian derivative matrices) cannot
be used. In particular, these techniques are frequently used to solve
combinatorial optimization problems, such as the traveling salesman
problem.</p>
<p>The goal is to find a point in the space at which a real valued
<em>energy function</em> (or <em>cost function</em>) is minimized.  Simulated
annealing is a minimization technique which has given good results in
avoiding local minima; it is based on the idea of taking a random walk
through the space at successively lower temperatures, where the
probability of taking a step is given by a Boltzmann distribution.</p>
<p>The functions described in this chapter are declared in the header file
<code class="file docutils literal notranslate"><span class="pre">gsl_siman.h</span></code>.</p>
<div class="section" id="simulated-annealing-algorithm">
<h2>Simulated Annealing algorithm<a class="headerlink" href="#simulated-annealing-algorithm" title="Permalink to this heading">¶</a></h2>
<p>The simulated annealing algorithm takes random walks through the problem
space, looking for points with low energies; in these random walks, the
probability of taking a step is determined by the Boltzmann distribution,</p>
<div class="math">
<p><img src="_images/math/ef502f4b90866c8396c7817be2612c74166848a5.png" alt="p = e^{-(E_{i+1} - E_i)/(kT)}"/></p>
</div><p>if
<img class="math" src="_images/math/5e495f47cd7eff24e4edbb26905d64771009897a.png" alt="E_{i+1} &gt; E_i"/>, and
<img class="math" src="_images/math/5710ce0ba2ecca538290ee04e400fc844d26d0a1.png" alt="p = 1"/> when
<img class="math" src="_images/math/40ab244a1a327ce771a3b9d48f826a3c9c528aba.png" alt="E_{i+1} \le E_i"/>.</p>
<p>In other words, a step will occur if the new energy is lower.  If
the new energy is higher, the transition can still occur, and its
likelihood is proportional to the temperature <img class="math" src="_images/math/da008f30aec40b729feeb13989fbe54555b2bba0.png" alt="T"/> and inversely
proportional to the energy difference
<img class="math" src="_images/math/a1d07b3d4dc218952a8495b682f774c616ecfe23.png" alt="E_{i+1} - E_i"/>.</p>
<p id="index-1">The temperature <img class="math" src="_images/math/da008f30aec40b729feeb13989fbe54555b2bba0.png" alt="T"/> is initially set to a high value, and a random
walk is carried out at that temperature.  Then the temperature is
lowered very slightly according to a <em>cooling schedule</em>, for
example: <img class="math" src="_images/math/2d5b083c7012dae63dd2a5947cc34f98243af9f4.png" alt="T \rightarrow T/\mu_T"/>
where <img class="math" src="_images/math/3b5f09916141c25d27eb415528021fdb24c5acdf.png" alt="\mu_T"/> is slightly greater than 1.</p>
<p>The slight probability of taking a step that gives higher energy is what
allows simulated annealing to frequently get out of local minima.</p>
</div>
<div class="section" id="simulated-annealing-functions">
<h2>Simulated Annealing functions<a class="headerlink" href="#simulated-annealing-functions" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.gsl_siman_solve">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_solve</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="rng.html#c.gsl_rng" title="gsl_rng"><span class="n"><span class="pre">gsl_rng</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x0_p</span></span>, <a class="reference internal" href="#c.gsl_siman_Efunc_t" title="gsl_siman_Efunc_t"><span class="n"><span class="pre">gsl_siman_Efunc_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Ef</span></span>, <a class="reference internal" href="#c.gsl_siman_step_t" title="gsl_siman_step_t"><span class="n"><span class="pre">gsl_siman_step_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">take_step</span></span>, <a class="reference internal" href="#c.gsl_siman_metric_t" title="gsl_siman_metric_t"><span class="n"><span class="pre">gsl_siman_metric_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">distance</span></span>, <a class="reference internal" href="#c.gsl_siman_print_t" title="gsl_siman_print_t"><span class="n"><span class="pre">gsl_siman_print_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">print_position</span></span>, <a class="reference internal" href="#c.gsl_siman_copy_t" title="gsl_siman_copy_t"><span class="n"><span class="pre">gsl_siman_copy_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">copyfunc</span></span>, <a class="reference internal" href="#c.gsl_siman_copy_construct_t" title="gsl_siman_copy_construct_t"><span class="n"><span class="pre">gsl_siman_copy_construct_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">copy_constructor</span></span>, <a class="reference internal" href="#c.gsl_siman_destroy_t" title="gsl_siman_destroy_t"><span class="n"><span class="pre">gsl_siman_destroy_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">destructor</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">element_size</span></span>, <a class="reference internal" href="#c.gsl_siman_params_t" title="gsl_siman_params_t"><span class="n"><span class="pre">gsl_siman_params_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gsl_siman_solve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function performs a simulated annealing search through a given
space.  The space is specified by providing the functions <a class="reference internal" href="#c.gsl_siman_solve" title="Ef"><code class="xref c c-data docutils literal notranslate"><span class="pre">Ef</span></code></a> and
<a class="reference internal" href="#c.gsl_siman_solve" title="distance"><code class="xref c c-data docutils literal notranslate"><span class="pre">distance</span></code></a>.  The simulated annealing steps are generated using the
random number generator <a class="reference internal" href="#c.gsl_siman_solve" title="r"><code class="xref c c-data docutils literal notranslate"><span class="pre">r</span></code></a> and the function <a class="reference internal" href="#c.gsl_siman_solve" title="take_step"><code class="xref c c-data docutils literal notranslate"><span class="pre">take_step</span></code></a>.</p>
<p>The starting configuration of the system should be given by <a class="reference internal" href="#c.gsl_siman_solve" title="x0_p"><code class="xref c c-data docutils literal notranslate"><span class="pre">x0_p</span></code></a>.
The routine offers two modes for updating configurations, a fixed-size
mode and a variable-size mode.  In the fixed-size mode the configuration
is stored as a single block of memory of size <a class="reference internal" href="#c.gsl_siman_solve" title="element_size"><code class="xref c c-data docutils literal notranslate"><span class="pre">element_size</span></code></a>.
Copies of this configuration are created, copied and destroyed
internally using the standard library functions <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>.  The function pointers <a class="reference internal" href="#c.gsl_siman_solve" title="copyfunc"><code class="xref c c-data docutils literal notranslate"><span class="pre">copyfunc</span></code></a>,
<a class="reference internal" href="#c.gsl_siman_solve" title="copy_constructor"><code class="xref c c-data docutils literal notranslate"><span class="pre">copy_constructor</span></code></a> and <a class="reference internal" href="#c.gsl_siman_solve" title="destructor"><code class="xref c c-data docutils literal notranslate"><span class="pre">destructor</span></code></a> should be null pointers in
fixed-size mode.  In the variable-size mode the functions
<a class="reference internal" href="#c.gsl_siman_solve" title="copyfunc"><code class="xref c c-data docutils literal notranslate"><span class="pre">copyfunc</span></code></a>, <a class="reference internal" href="#c.gsl_siman_solve" title="copy_constructor"><code class="xref c c-data docutils literal notranslate"><span class="pre">copy_constructor</span></code></a> and <a class="reference internal" href="#c.gsl_siman_solve" title="destructor"><code class="xref c c-data docutils literal notranslate"><span class="pre">destructor</span></code></a> are used to
create, copy and destroy configurations internally.  The variable
<a class="reference internal" href="#c.gsl_siman_solve" title="element_size"><code class="xref c c-data docutils literal notranslate"><span class="pre">element_size</span></code></a> should be zero in the variable-size mode.</p>
<p>The <a class="reference internal" href="#c.gsl_siman_solve" title="params"><code class="xref c c-data docutils literal notranslate"><span class="pre">params</span></code></a> structure (described below) controls the run by
providing the temperature schedule and other tunable parameters to the
algorithm.</p>
<p>On exit the best result achieved during the search is placed in
<a class="reference internal" href="#c.gsl_siman_solve" title="x0_p"><code class="xref c c-data docutils literal notranslate"><span class="pre">x0_p</span></code></a>.  If the annealing process has been successful this
should be a good approximation to the optimal point in the space.</p>
<p>If the function pointer <a class="reference internal" href="#c.gsl_siman_solve" title="print_position"><code class="xref c c-data docutils literal notranslate"><span class="pre">print_position</span></code></a> is not null, a debugging
log will be printed to <code class="code docutils literal notranslate"><span class="pre">stdout</span></code> with the following columns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#-iter  #-evals  temperature  position  energy  best_energy</span>
</pre></div>
</div>
<p>and the output of the function <a class="reference internal" href="#c.gsl_siman_solve" title="print_position"><code class="xref c c-data docutils literal notranslate"><span class="pre">print_position</span></code></a> itself.  If
<a class="reference internal" href="#c.gsl_siman_solve" title="print_position"><code class="xref c c-data docutils literal notranslate"><span class="pre">print_position</span></code></a> is null then no information is printed.</p>
</dd></dl>

<p>The simulated annealing routines require several user-specified
functions to define the configuration space and energy function.  The
prototypes for these functions are given below.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_Efunc_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_Efunc_t</span></span></span><a class="headerlink" href="#c.gsl_siman_Efunc_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function type should return the energy of a configuration <code class="xref c c-data docutils literal notranslate"><span class="pre">xp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="p">(</span><span class="o">*</span><span class="n">gsl_siman_Efunc_t</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">xp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_step_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_step_t</span></span></span><a class="headerlink" href="#c.gsl_siman_step_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function type should modify the configuration <code class="xref c c-data docutils literal notranslate"><span class="pre">xp</span></code> using a random step
taken from the generator <code class="xref c c-data docutils literal notranslate"><span class="pre">r</span></code>, up to a maximum distance of
<code class="xref c c-data docutils literal notranslate"><span class="pre">step_size</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gsl_siman_step_t</span><span class="p">)</span> <span class="p">(</span><span class="n">const</span> <span class="n">gsl_rng</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span>
                          <span class="n">double</span> <span class="n">step_size</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_metric_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_metric_t</span></span></span><a class="headerlink" href="#c.gsl_siman_metric_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function type should return the distance between two configurations
<code class="xref c c-data docutils literal notranslate"><span class="pre">xp</span></code> and <code class="xref c c-data docutils literal notranslate"><span class="pre">yp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="p">(</span><span class="o">*</span><span class="n">gsl_siman_metric_t</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">yp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_print_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_print_t</span></span></span><a class="headerlink" href="#c.gsl_siman_print_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function type should print the contents of the configuration <code class="xref c c-data docutils literal notranslate"><span class="pre">xp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gsl_siman_print_t</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">xp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_copy_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_copy_t</span></span></span><a class="headerlink" href="#c.gsl_siman_copy_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function type should copy the configuration <code class="xref c c-data docutils literal notranslate"><span class="pre">source</span></code> into <code class="xref c c-data docutils literal notranslate"><span class="pre">dest</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gsl_siman_copy_t</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_copy_construct_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_copy_construct_t</span></span></span><a class="headerlink" href="#c.gsl_siman_copy_construct_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function type should create a new copy of the configuration <code class="xref c c-data docutils literal notranslate"><span class="pre">xp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">gsl_siman_copy_construct_t</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">xp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_destroy_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_destroy_t</span></span></span><a class="headerlink" href="#c.gsl_siman_destroy_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function type should destroy the configuration <code class="xref c c-data docutils literal notranslate"><span class="pre">xp</span></code>, freeing its
memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gsl_siman_destroy_t</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">xp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.gsl_siman_params_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_siman_params_t</span></span></span><a class="headerlink" href="#c.gsl_siman_params_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These are the parameters that control a run of <a class="reference internal" href="#c.gsl_siman_solve" title="gsl_siman_solve"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_siman_solve()</span></code></a>.
This structure contains all the information needed to control the
search, beyond the energy function, the step function and the initial
guess.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">n_tries</span></code></p></td>
<td><p>The number of points to try for each step.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">iters_fixed_T</span></code></p></td>
<td><p>The number of iterations at each temperature.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">step_size</span></code></p></td>
<td><p>The maximum step size in the random walk.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">double</span> <span class="pre">k,</span> <span class="pre">t_initial,</span> <span class="pre">mu_t,</span> <span class="pre">t_min</span></code></p></td>
<td><p>The parameters of the Boltzmann distribution and cooling
schedule.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<p>The simulated annealing package is clumsy, and it has to be because it
is written in C, for C callers, and tries to be polymorphic at the same
time.  But here we provide some examples which can be pasted into your
application with little change and should make things easier.</p>
<div class="section" id="trivial-example">
<h3>Trivial example<a class="headerlink" href="#trivial-example" title="Permalink to this heading">¶</a></h3>
<p>The first example, in one dimensional Cartesian space, sets up an energy
function which is a damped sine wave; this has many local minima, but
only one global minimum, somewhere between 1.0 and 1.5.  The initial
guess given is 15.5, which is several local minima away from the global
minimum.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gsl/gsl_siman.h&gt;

/* set up parameters for this simulated annealing run */

/* how many points do we try before stepping */
#define N_TRIES 200

/* how many iterations for each T? */
#define ITERS_FIXED_T 1000

/* max step size in random walk */
#define STEP_SIZE 1.0

/* Boltzmann constant */
#define K 1.0

/* initial temperature */
#define T_INITIAL 0.008

/* damping factor for temperature */
#define MU_T 1.003
#define T_MIN 2.0e-6

gsl_siman_params_t params
  = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
     K, T_INITIAL, MU_T, T_MIN};

/* now some functions to test in one dimension */
double E1(void *xp)
{
  double x = * ((double *) xp);

  return exp(-pow((x-1.0),2.0))*sin(8*x);
}

double M1(void *xp, void *yp)
{
  double x = *((double *) xp);
  double y = *((double *) yp);

  return fabs(x - y);
}

void S1(const gsl_rng * r, void *xp, double step_size)
{
  double old_x = *((double *) xp);
  double new_x;

  double u = gsl_rng_uniform(r);
  new_x = u * 2 * step_size - step_size + old_x;

  memcpy(xp, &amp;new_x, sizeof(new_x));
}

void P1(void *xp)
{
  printf (&quot;%12g&quot;, *((double *) xp));
}

int
main(void)
{
  const gsl_rng_type * T;
  gsl_rng * r;

  double x_initial = 15.5;

  gsl_rng_env_setup();

  T = gsl_rng_default;
  r = gsl_rng_alloc(T);

  gsl_siman_solve(r, &amp;x_initial, E1, S1, M1, P1,
                  NULL, NULL, NULL,
                  sizeof(double), params);

  gsl_rng_free (r);
  return 0;
}
</pre></div>
</div>
<p><a class="reference internal" href="#fig-siman-test"><span class="std std-numref">Fig. 16</span></a> is generated by running
<code class="code docutils literal notranslate"><span class="pre">siman_test</span></code> in the following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./siman_test | awk &#39;!/^#/ {print $1, $4}&#39;
 | graph -y 1.34 1.4 -W0 -X generation -Y position
 | plot -Tps &gt; siman-test.eps
</pre></div>
</div>
<p><a class="reference internal" href="#fig-siman-energy"><span class="std std-numref">Fig. 17</span></a> is generated by running
<code class="code docutils literal notranslate"><span class="pre">siman_test</span></code> in the following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./siman_test | awk &#39;!/^#/ {print $1, $5}&#39;
 | graph -y -0.88 -0.83 -W0 -X generation -Y energy
 | plot -Tps &gt; siman-energy.eps
</pre></div>
</div>
<div class="figure align-default" id="id1">
<span id="fig-siman-test"></span><a class="reference internal image-reference" href="_images/siman-test.png"><img alt="_images/siman-test.png" src="_images/siman-test.png" style="width: 384.0px; height: 288.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">Example of a simulated annealing run: at higher temperatures (early in
the plot) you see that the solution can fluctuate, but at lower
temperatures it converges.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-default" id="id2">
<span id="fig-siman-energy"></span><a class="reference internal image-reference" href="_images/siman-energy.png"><img alt="_images/siman-energy.png" src="_images/siman-energy.png" style="width: 384.0px; height: 288.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">Simulated annealing energy vs generation</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="traveling-salesman-problem">
<span id="index-2"></span><h3>Traveling Salesman Problem<a class="headerlink" href="#traveling-salesman-problem" title="Permalink to this heading">¶</a></h3>
<p>The TSP (<em>Traveling Salesman Problem</em>) is the classic combinatorial
optimization problem.  I have provided a very simple version of it,
based on the coordinates of twelve cities in the southwestern United
States.  This should maybe be called the <em>Flying Salesman Problem</em>,
since I am using the great-circle distance between cities, rather than
the driving distance.  Also: I assume the earth is a sphere, so I don’t
use geoid distances.</p>
<p>The <a class="reference internal" href="#c.gsl_siman_solve" title="gsl_siman_solve"><code class="xref c c-func docutils literal notranslate"><span class="pre">gsl_siman_solve()</span></code></a> routine finds a route which is 3490.62
Kilometers long; this is confirmed by an exhaustive search of all
possible routes with the same initial city.</p>
<p>The full code is given below.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>/* siman/siman_tsp.c
 *
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Mark Galassi
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include &lt;config.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_math.h&gt;
#include &lt;gsl/gsl_rng.h&gt;
#include &lt;gsl/gsl_siman.h&gt;
#include &lt;gsl/gsl_ieee_utils.h&gt;

/* set up parameters for this simulated annealing run */

#define N_TRIES 200             /* how many points do we try before stepping */
#define ITERS_FIXED_T 2000      /* how many iterations for each T? */
#define STEP_SIZE 1.0           /* max step size in random walk */
#define K 1.0                   /* Boltzmann constant */
#define T_INITIAL 5000.0        /* initial temperature */
#define MU_T 1.002              /* damping factor for temperature */
#define T_MIN 5.0e-1

gsl_siman_params_t params = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
                             K, T_INITIAL, MU_T, T_MIN};

struct s_tsp_city {
  const char * name;
  double lat, longitude;        /* coordinates */
};
typedef struct s_tsp_city Stsp_city;

void prepare_distance_matrix(void);
void exhaustive_search(void);
void print_distance_matrix(void);
double city_distance(Stsp_city c1, Stsp_city c2);
double Etsp(void *xp);
double Mtsp(void *xp, void *yp);
void Stsp(const gsl_rng * r, void *xp, double step_size);
void Ptsp(void *xp);

/* in this table, latitude and longitude are obtained from the US
   Census Bureau, at http://www.census.gov/cgi-bin/gazetteer */

Stsp_city cities[] = {{&quot;Santa Fe&quot;,    35.68,   105.95},
                      {&quot;Phoenix&quot;,     33.54,   112.07},
                      {&quot;Albuquerque&quot;, 35.12,   106.62},
                      {&quot;Clovis&quot;,      34.41,   103.20},
                      {&quot;Durango&quot;,     37.29,   107.87},
                      {&quot;Dallas&quot;,      32.79,    96.77},
                      {&quot;Tesuque&quot;,     35.77,   105.92},
                      {&quot;Grants&quot;,      35.15,   107.84},
                      {&quot;Los Alamos&quot;,  35.89,   106.28},
                      {&quot;Las Cruces&quot;,  32.34,   106.76},
                      {&quot;Cortez&quot;,      37.35,   108.58},
                      {&quot;Gallup&quot;,      35.52,   108.74}};

#define N_CITIES (sizeof(cities)/sizeof(Stsp_city))

double distance_matrix[N_CITIES][N_CITIES];

/* distance between two cities */
double city_distance(Stsp_city c1, Stsp_city c2)
{
  const double earth_radius = 6375.000; /* 6000KM approximately */
  /* sin and cos of lat and long; must convert to radians */
  double sla1 = sin(c1.lat*M_PI/180), cla1 = cos(c1.lat*M_PI/180),
    slo1 = sin(c1.longitude*M_PI/180), clo1 = cos(c1.longitude*M_PI/180);
  double sla2 = sin(c2.lat*M_PI/180), cla2 = cos(c2.lat*M_PI/180),
    slo2 = sin(c2.longitude*M_PI/180), clo2 = cos(c2.longitude*M_PI/180);

  double x1 = cla1*clo1;
  double x2 = cla2*clo2;

  double y1 = cla1*slo1;
  double y2 = cla2*slo2;

  double z1 = sla1;
  double z2 = sla2;

  double dot_product = x1*x2 + y1*y2 + z1*z2;

  double angle = acos(dot_product);

  /* distance is the angle (in radians) times the earth radius */
  return angle*earth_radius;
}

/* energy for the travelling salesman problem */
double Etsp(void *xp)
{
  /* an array of N_CITIES integers describing the order */
  int *route = (int *) xp;
  double E = 0;
  unsigned int i;

  for (i = 0; i &lt; N_CITIES; ++i) {
    /* use the distance_matrix to optimize this calculation; it had
       better be allocated!! */
    E += distance_matrix[route[i]][route[(i + 1) % N_CITIES]];
  }

  return E;
}

double Mtsp(void *xp, void *yp)
{
  int *route1 = (int *) xp, *route2 = (int *) yp;
  double distance = 0;
  unsigned int i;

  for (i = 0; i &lt; N_CITIES; ++i) {
    distance += ((route1[i] == route2[i]) ? 0 : 1);
  }

  return distance;
}

/* take a step through the TSP space */
void Stsp(const gsl_rng * r, void *xp, double step_size)
{
  int x1, x2, dummy;
  int *route = (int *) xp;

  step_size = 0 ; /* prevent warnings about unused parameter */

  /* pick the two cities to swap in the matrix; we leave the first
     city fixed */
  x1 = (gsl_rng_get (r) % (N_CITIES-1)) + 1;
  do {
    x2 = (gsl_rng_get (r) % (N_CITIES-1)) + 1;
  } while (x2 == x1);

  dummy = route[x1];
  route[x1] = route[x2];
  route[x2] = dummy;
}

void Ptsp(void *xp)
{
  unsigned int i;
  int *route = (int *) xp;
  printf(&quot;  [&quot;);
  for (i = 0; i &lt; N_CITIES; ++i) {
    printf(&quot; %d &quot;, route[i]);
  }
  printf(&quot;]  &quot;);
}

int main(void)
{
  int x_initial[N_CITIES];
  unsigned int i;

  const gsl_rng * r = gsl_rng_alloc (gsl_rng_env_setup()) ;

  gsl_ieee_env_setup ();

  prepare_distance_matrix();

  /* set up a trivial initial route */
  printf(&quot;# initial order of cities:\n&quot;);
  for (i = 0; i &lt; N_CITIES; ++i) {
    printf(&quot;# \&quot;%s\&quot;\n&quot;, cities[i].name);
    x_initial[i] = i;
  }

  printf(&quot;# distance matrix is:\n&quot;);
  print_distance_matrix();

  printf(&quot;# initial coordinates of cities (longitude and latitude)\n&quot;);
  /* this can be plotted with */
  /* ./siman_tsp &gt; hhh ; grep city_coord hhh | awk &#39;{print $2 &quot;   &quot; $3}&#39; | xyplot -ps -d &quot;xy&quot; &gt; c.eps */
  for (i = 0; i &lt; N_CITIES+1; ++i) {
    printf(&quot;###initial_city_coord: %g %g \&quot;%s\&quot;\n&quot;,
           -cities[x_initial[i % N_CITIES]].longitude,
           cities[x_initial[i % N_CITIES]].lat,
           cities[x_initial[i % N_CITIES]].name);
  }

/*   exhaustive_search(); */

  gsl_siman_solve(r, x_initial, Etsp, Stsp, Mtsp, Ptsp, NULL, NULL, NULL,
                  N_CITIES*sizeof(int), params);

  printf(&quot;# final order of cities:\n&quot;);
  for (i = 0; i &lt; N_CITIES; ++i) {
    printf(&quot;# \&quot;%s\&quot;\n&quot;, cities[x_initial[i]].name);
  }

  printf(&quot;# final coordinates of cities (longitude and latitude)\n&quot;);
  /* this can be plotted with */
  /* ./siman_tsp &gt; hhh ; grep city_coord hhh | awk &#39;{print $2 &quot;   &quot; $3}&#39; | xyplot -ps -d &quot;xy&quot; &gt; c.eps */
  for (i = 0; i &lt; N_CITIES+1; ++i) {
    printf(&quot;###final_city_coord: %g %g %s\n&quot;,
           -cities[x_initial[i % N_CITIES]].longitude,
           cities[x_initial[i % N_CITIES]].lat,
           cities[x_initial[i % N_CITIES]].name);
  }

  printf(&quot;# &quot;);
  fflush(stdout);
#if 0
  system(&quot;date&quot;);
#endif /* 0 */
  fflush(stdout);

  return 0;
}

void prepare_distance_matrix()
{
  unsigned int i, j;
  double dist;

  for (i = 0; i &lt; N_CITIES; ++i) {
    for (j = 0; j &lt; N_CITIES; ++j) {
      if (i == j) {
        dist = 0;
      } else {
        dist = city_distance(cities[i], cities[j]);
      }
      distance_matrix[i][j] = dist;
    }
  }
}

void print_distance_matrix()
{
  unsigned int i, j;

  for (i = 0; i &lt; N_CITIES; ++i) {
    printf(&quot;# &quot;);
    for (j = 0; j &lt; N_CITIES; ++j) {
      printf(&quot;%15.8f   &quot;, distance_matrix[i][j]);
    }
    printf(&quot;\n&quot;);
  }
}

/* [only works for 12] search the entire space for solutions */
static double best_E = 1.0e100, second_E = 1.0e100, third_E = 1.0e100;
static int best_route[N_CITIES];
static int second_route[N_CITIES];
static int third_route[N_CITIES];
static void do_all_perms(int *route, int n);

void exhaustive_search()
{
  static int initial_route[N_CITIES] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
  printf(&quot;\n# &quot;);
  fflush(stdout);
#if 0
  system(&quot;date&quot;);
#endif
  fflush(stdout);
  do_all_perms(initial_route, 1);
  printf(&quot;\n# &quot;);
  fflush(stdout);
#if 0
  system(&quot;date&quot;);
#endif /* 0 */
  fflush(stdout);

  printf(&quot;# exhaustive best route: &quot;);
  Ptsp(best_route);
  printf(&quot;\n# its energy is: %g\n&quot;, best_E);

  printf(&quot;# exhaustive second_best route: &quot;);
  Ptsp(second_route);
  printf(&quot;\n# its energy is: %g\n&quot;, second_E);

  printf(&quot;# exhaustive third_best route: &quot;);
  Ptsp(third_route);
  printf(&quot;\n# its energy is: %g\n&quot;, third_E);
}

/* James Theiler&#39;s recursive algorithm for generating all routes */
static void do_all_perms(int *route, int n)
{
  if (n == (N_CITIES-1)) {
    /* do it! calculate the energy/cost for that route */
    double E;
    E = Etsp(route);            /* TSP energy function */
    /* now save the best 3 energies and routes */
    if (E &lt; best_E) {
      third_E = second_E;
      memcpy(third_route, second_route, N_CITIES*sizeof(*route));
      second_E = best_E;
      memcpy(second_route, best_route, N_CITIES*sizeof(*route));
      best_E = E;
      memcpy(best_route, route, N_CITIES*sizeof(*route));
    } else if (E &lt; second_E) {
      third_E = second_E;
      memcpy(third_route, second_route, N_CITIES*sizeof(*route));
      second_E = E;
      memcpy(second_route, route, N_CITIES*sizeof(*route));
    } else if (E &lt; third_E) {
      third_E = E;
      memcpy(route, third_route, N_CITIES*sizeof(*route));
    }
  } else {
    int new_route[N_CITIES];
    unsigned int j;
    int swap_tmp;
    memcpy(new_route, route, N_CITIES*sizeof(*route));
    for (j = n; j &lt; N_CITIES; ++j) {
      swap_tmp = new_route[j];
      new_route[j] = new_route[n];
      new_route[n] = swap_tmp;
      do_all_perms(new_route, n+1);
    }
  }
}
</pre></div>
</div>
<p>Below are some plots generated in the following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./siman_tsp &gt; tsp.output
$ grep -v &quot;^#&quot; tsp.output
 | awk &#39;{print $1, $NF}&#39;
 | graph -y 3300 6500 -W0 -X generation -Y distance
    -L &quot;TSP - 12 southwest cities&quot;
 | plot -Tps &gt; 12-cities.eps
$ grep initial_city_coord tsp.output
  | awk &#39;{print $2, $3}&#39;
  | graph -X &quot;longitude (- means west)&quot; -Y &quot;latitude&quot;
     -L &quot;TSP - initial-order&quot; -f 0.03 -S 1 0.1
  | plot -Tps &gt; initial-route.eps
$ grep final_city_coord tsp.output
  | awk &#39;{print $2, $3}&#39;
  | graph -X &quot;longitude (- means west)&quot; -Y &quot;latitude&quot;
     -L &quot;TSP - final-order&quot; -f 0.03 -S 1 0.1
  | plot -Tps &gt; final-route.eps
</pre></div>
</div>
<p>This is the output showing the initial order of the cities; longitude is
negative, since it is west and I want the plot to look like a map:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># initial coordinates of cities (longitude and latitude)</span>
<span class="c1">###initial_city_coord: -105.95 35.68 Santa Fe</span>
<span class="c1">###initial_city_coord: -112.07 33.54 Phoenix</span>
<span class="c1">###initial_city_coord: -106.62 35.12 Albuquerque</span>
<span class="c1">###initial_city_coord: -103.2 34.41 Clovis</span>
<span class="c1">###initial_city_coord: -107.87 37.29 Durango</span>
<span class="c1">###initial_city_coord: -96.77 32.79 Dallas</span>
<span class="c1">###initial_city_coord: -105.92 35.77 Tesuque</span>
<span class="c1">###initial_city_coord: -107.84 35.15 Grants</span>
<span class="c1">###initial_city_coord: -106.28 35.89 Los Alamos</span>
<span class="c1">###initial_city_coord: -106.76 32.34 Las Cruces</span>
<span class="c1">###initial_city_coord: -108.58 37.35 Cortez</span>
<span class="c1">###initial_city_coord: -108.74 35.52 Gallup</span>
<span class="c1">###initial_city_coord: -105.95 35.68 Santa Fe</span>
</pre></div>
</div>
<p>The optimal route turns out to be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># final coordinates of cities (longitude and latitude)</span>
<span class="c1">###final_city_coord: -105.95 35.68 Santa Fe</span>
<span class="c1">###final_city_coord: -103.2 34.41 Clovis</span>
<span class="c1">###final_city_coord: -96.77 32.79 Dallas</span>
<span class="c1">###final_city_coord: -106.76 32.34 Las Cruces</span>
<span class="c1">###final_city_coord: -112.07 33.54 Phoenix</span>
<span class="c1">###final_city_coord: -108.74 35.52 Gallup</span>
<span class="c1">###final_city_coord: -108.58 37.35 Cortez</span>
<span class="c1">###final_city_coord: -107.87 37.29 Durango</span>
<span class="c1">###final_city_coord: -107.84 35.15 Grants</span>
<span class="c1">###final_city_coord: -106.62 35.12 Albuquerque</span>
<span class="c1">###final_city_coord: -106.28 35.89 Los Alamos</span>
<span class="c1">###final_city_coord: -105.92 35.77 Tesuque</span>
<span class="c1">###final_city_coord: -105.95 35.68 Santa Fe</span>
</pre></div>
</div>
<div class="figure align-default" id="id3">
<a class="reference internal image-reference" href="_images/siman-initial-route.png"><img alt="_images/siman-initial-route.png" src="_images/siman-initial-route.png" style="width: 384.0px; height: 288.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 18 </span><span class="caption-text">Initial route for the 12 southwestern cities Flying Salesman Problem.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-default" id="id4">
<a class="reference internal image-reference" href="_images/siman-final-route.png"><img alt="_images/siman-final-route.png" src="_images/siman-final-route.png" style="width: 384.0px; height: 288.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 19 </span><span class="caption-text">Final (optimal) route for the 12 southwestern cities Flying Salesman Problem.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>Here’s a plot of the cost function (energy) versus generation (point in
the calculation at which a new temperature is set) for this problem:</p>
<div class="figure align-default" id="id5">
<a class="reference internal image-reference" href="_images/siman-12-cities.png"><img alt="_images/siman-12-cities.png" src="_images/siman-12-cities.png" style="width: 384.0px; height: 288.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 20 </span><span class="caption-text">Example of a simulated annealing run for the 12 southwestern cities
Flying Salesman Problem.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="references-and-further-reading">
<h2>References and Further Reading<a class="headerlink" href="#references-and-further-reading" title="Permalink to this heading">¶</a></h2>
<p>Further information is available in the following book,</p>
<ul class="simple">
<li><p><em>Modern Heuristic Techniques for Combinatorial Problems</em>, Colin R. Reeves
(ed.), McGraw-Hill, 1995 (ISBN 0-07-709239-2).</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="ode-initval.html" class="btn btn-neutral float-right" title="Ordinary Differential Equations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="montecarlo.html" class="btn btn-neutral float-left" title="Monte Carlo Integration" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 1996-2024 The GSL Team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>